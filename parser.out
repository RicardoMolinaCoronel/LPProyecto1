Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APOSTROPHE
    ASYNC
    AWAIT
    CATCH
    CLOSE
    COMMENT
    DO
    DOLLAR
    DOUBQUOTMARK
    EXIT
    FILE
    IMPORT
    IN
    IS
    ITERABLE
    MAIN
    METHOD
    NOTEQUAL
    OPENWRITE
    PRINT
    READLINESYNC
    SET
    TRY
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> class_content_repeat
Rule 2     class_content -> map
Rule 3     class_content -> ifElseStatement
Rule 4     class_content -> function_lambda
Rule 5     class_content -> declarationExpression
Rule 6     class_content -> forStatement
Rule 7     class_content -> while
Rule 8     class_content -> stack
Rule 9     class_content -> inferedReturnFunction
Rule 10    class_content -> expression SEMICOLON
Rule 11    class_content_repeat -> class_content
Rule 12    class_content_repeat -> class_content_repeat class_content
Rule 13    class_content -> bool
Rule 14    class_content -> semanticlist
Rule 15    map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 16    map_identifier -> MAP
Rule 17    map_identifier -> MAP map_type_specified
Rule 18    map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 19    datatype -> returnType
Rule 20    datatype -> VAR
Rule 21    returnType -> INT
Rule 22    returnType -> STRING
Rule 23    returnType -> BOOL
Rule 24    returnType -> DOUBLE
Rule 25    returnType -> DYNAMIC
Rule 26    returnType -> VOID
Rule 27    returnType -> map_identifier
Rule 28    empty -> <empty>
Rule 29    map_content -> map_pairs
Rule 30    map_content -> empty
Rule 31    map_pair -> map_key COLON map_value
Rule 32    map_pairs -> map_pair
Rule 33    map_pairs -> map_pair COMMA map_pairs
Rule 34    map_key -> value
Rule 35    map_value -> value
Rule 36    ifElseStatement -> ifStatement
Rule 37    ifElseStatement -> ifStatement elifStatement_repeat
Rule 38    elifStatement_repeat -> elifStatement
Rule 39    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 40    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 41    elifStatement -> ELSE ifStatement
Rule 42    elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 43    forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 44    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
Rule 45    while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 46    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
Rule 47    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 48    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
Rule 49    value -> INTEGER
Rule 50    value -> FLOAT
Rule 51    value -> STR
Rule 52    value -> BOOLEAN
Rule 53    value -> IDENTIFIER
Rule 54    opt_value -> value
Rule 55    opt_value -> empty
Rule 56    deniable_values -> IDENTIFIER
Rule 57    deniable_values -> BOOLEAN
Rule 58    negation_values -> deniable_values
Rule 59    negation_values -> EXMARK deniable_values
Rule 60    condition_values -> negation_values
Rule 61    condition_values -> INTEGER
Rule 62    condition_values -> FLOAT
Rule 63    condition_values -> STR
Rule 64    condition_operator -> DOUBLEQUAL
Rule 65    condition_operator -> LESSTHAN
Rule 66    condition_operator -> GREATERTHAN
Rule 67    condition_operator -> LESSTHAN EQUAL
Rule 68    condition_operator -> GREATERTHAN EQUAL
Rule 69    number -> FLOAT
Rule 70    number -> INTEGER
Rule 71    condition -> IDENTIFIER condition_operator condition_values
Rule 72    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 73    condition -> BOOLEAN condition_operator BOOLEAN
Rule 74    condition -> number condition_operator number
Rule 75    condition -> STR condition_operator STR
Rule 76    conditions -> condition
Rule 77    conditions -> condition condition_connector conditions
Rule 78    condition_connector -> AND
Rule 79    condition_connector -> OR
Rule 80    condition_connector -> AMPERSAND AMPERSAND
Rule 81    condition_connector -> PIPELINE PIPELINE
Rule 82    function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 83    function_argument -> datatype IDENTIFIER
Rule 84    function_argument -> empty
Rule 85    function_arguments_repeat -> function_argument
Rule 86    function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 87    optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 88    optFunction_argumentsExpression -> empty
Rule 89    optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 90    optFunction_arguments -> optFunction_argument
Rule 91    optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 92    expression -> operableTypes operatorExpression operableTypes
Rule 93    expression -> value
Rule 94    expression -> operableTypes operatorExpression operatorExpression
Rule 95    operableTypes -> IDENTIFIER
Rule 96    operableTypes -> number
Rule 97    operatorExpression -> PLUS
Rule 98    operatorExpression -> MINUS
Rule 99    operatorExpression -> TIMES
Rule 100   operatorExpression -> DIVISION
Rule 101   declarationExpression -> datatype IDENTIFIER SEMICOLON
Rule 102   declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON
Rule 103   boolvalue -> TRUE
Rule 104   boolvalue -> FALSE
Rule 105   bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
Rule 106   booloperation -> boolvalue condition_connector boolvalue
Rule 107   booloperation -> IDENTIFIER condition_connector boolvalue
Rule 108   booloperation -> IDENTIFIER condition_connector IDENTIFIER
Rule 109   booloperation -> boolvalue condition_connector IDENTIFIER
Rule 110   booloperations -> booloperation
Rule 111   booloperations -> booloperation condition_connector booloperations
Rule 112   semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
Rule 113   insidelist -> value
Rule 114   insidelist -> value COMMA value
Rule 115   insidelist -> value COMMA insidelist

Terminals, with rules where they appear

AMPERSAND            : 80 80
AND                  : 78
APOSTROPHE           : 
ASYNC                : 
AWAIT                : 
BOOL                 : 23 105
BOOLEAN              : 52 57 73 73
CATCH                : 
CLOSE                : 
COLON                : 31
COMMA                : 18 33 86 91 114 115
COMMENT              : 
DIVISION             : 100
DO                   : 
DOLLAR               : 
DOT                  : 47
DOUBLE               : 24
DOUBLEQUAL           : 64
DOUBQUOTMARK         : 
DYNAMIC              : 25
ELSE                 : 41 42
EQUAL                : 15 44 46 47 67 68 82 102 105 112
EXIT                 : 
EXMARK               : 59 72
FALSE                : 104
FILE                 : 
FINAL                : 44 46 47
FLOAT                : 50 62 69
FOR                  : 43
GREATERTHAN          : 18 44 46 66 68 82 112
IDENTIFIER           : 15 44 46 47 47 48 53 56 71 72 82 83 89 95 101 102 105 107 108 108 109 112
IF                   : 40
IMPORT               : 
IN                   : 
INT                  : 21
INTEGER              : 49 61 70
IS                   : 
ITERABLE             : 
LCURLYBRACKET        : 15 40 42 43 45 48 87
LESSTHAN             : 18 44 46 65 67 112
LIST                 : 112
LPAREN               : 40 43 44 45 46 47 48 82
LSQUAREBRACKET       : 112
MAIN                 : 
MAP                  : 16 17
METHOD               : 
MINUS                : 98
NOTEQUAL             : 
OF                   : 47
OPENWRITE            : 
OR                   : 79
PIPELINE             : 81 81
PLUS                 : 97
PRINT                : 
RCURLYBRACKET        : 15 40 42 43 45 48 87
READLINESYNC         : 
REQUIRED             : 89
RETURN               : 48
RPAREN               : 40 43 44 45 46 47 48 82
RSQUAREBRACKET       : 112
SEMICOLON            : 10 15 43 43 44 46 47 48 82 101 102 105 112
SET                  : 
STACK                : 44 46 47
STR                  : 51 63 75 75
STRING               : 22
TIMES                : 99
TRUE                 : 103
TRY                  : 
VAR                  : 20
VOID                 : 26
WHILE                : 45
WRITE                : 
error                : 

Nonterminals, with rules where they appear

bool                 : 13
booloperation        : 110 111
booloperations       : 111
boolvalue            : 105 106 106 107 109
class                : 0
class_content        : 11 12
class_content_repeat : 1 12 40 42 45
condition            : 43 76 77
condition_connector  : 77 106 107 108 109 111
condition_operator   : 71 72 73 74 75
condition_values     : 71 72
conditions           : 40 45 77
datatype             : 18 18 44 46 82 83 89 101 102 112
declarationExpression : 5 43
deniable_values      : 58 59
elifStatement        : 38 39
elifStatement_repeat : 37 39
empty                : 30 55 84 88
expression           : 10 43 48 82 102
forStatement         : 6
function_argument    : 85 86
function_arguments_repeat : 48 82 86
function_lambda      : 4
ifElseStatement      : 3
ifStatement          : 36 37 41
inferedReturnFunction : 9
insidelist           : 112 115
map                  : 2
map_content          : 15
map_identifier       : 15 27
map_key              : 31
map_pair             : 32 33
map_pairs            : 29 33
map_type_specified   : 17
map_value            : 31
negation_values      : 60
number               : 74 74 96
operableTypes        : 92 92 94
operatorExpression   : 92 94 94
optFunction_argument : 90 91
optFunction_arguments : 87 91
optFunction_argumentsExpression : 82
opt_value            : 44
returnType           : 19
semanticlist         : 14
stack                : 8
value                : 34 35 54 93 113 114 114 115
while                : 7

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . class_content_repeat
    (11) class_content_repeat -> . class_content
    (12) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . bool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (82) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (105) bool -> . BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
    (112) semanticlist -> . LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    FOR             shift and go to state 19
    WHILE           shift and go to state 20
    FINAL           shift and go to state 21
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 24
    LIST            shift and go to state 25
    MAP             shift and go to state 26
    IF              shift and go to state 27
    VAR             shift and go to state 29
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    INT             shift and go to state 35
    STRING          shift and go to state 36
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39

    class                          shift and go to state 1
    class_content_repeat           shift and go to state 2
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    bool                           shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    returnType                     shift and go to state 28
    number                         shift and go to state 30

state 1

    (0) S' -> class .



state 2

    (1) class -> class_content_repeat .
    (12) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . bool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (82) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (105) bool -> . BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
    (112) semanticlist -> . LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    $end            reduce using rule 1 (class -> class_content_repeat .)
    FOR             shift and go to state 19
    WHILE           shift and go to state 20
    FINAL           shift and go to state 21
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 24
    LIST            shift and go to state 25
    MAP             shift and go to state 26
    IF              shift and go to state 27
    VAR             shift and go to state 29
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    INT             shift and go to state 35
    STRING          shift and go to state 36
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39

    class_content                  shift and go to state 40
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    bool                           shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    returnType                     shift and go to state 28
    number                         shift and go to state 30

state 3

    (11) class_content_repeat -> class_content .

    FOR             reduce using rule 11 (class_content_repeat -> class_content .)
    WHILE           reduce using rule 11 (class_content_repeat -> class_content .)
    FINAL           reduce using rule 11 (class_content_repeat -> class_content .)
    IDENTIFIER      reduce using rule 11 (class_content_repeat -> class_content .)
    BOOL            reduce using rule 11 (class_content_repeat -> class_content .)
    LIST            reduce using rule 11 (class_content_repeat -> class_content .)
    MAP             reduce using rule 11 (class_content_repeat -> class_content .)
    IF              reduce using rule 11 (class_content_repeat -> class_content .)
    VAR             reduce using rule 11 (class_content_repeat -> class_content .)
    INTEGER         reduce using rule 11 (class_content_repeat -> class_content .)
    FLOAT           reduce using rule 11 (class_content_repeat -> class_content .)
    STR             reduce using rule 11 (class_content_repeat -> class_content .)
    BOOLEAN         reduce using rule 11 (class_content_repeat -> class_content .)
    INT             reduce using rule 11 (class_content_repeat -> class_content .)
    STRING          reduce using rule 11 (class_content_repeat -> class_content .)
    DOUBLE          reduce using rule 11 (class_content_repeat -> class_content .)
    DYNAMIC         reduce using rule 11 (class_content_repeat -> class_content .)
    VOID            reduce using rule 11 (class_content_repeat -> class_content .)
    $end            reduce using rule 11 (class_content_repeat -> class_content .)
    RCURLYBRACKET   reduce using rule 11 (class_content_repeat -> class_content .)


state 4

    (2) class_content -> map .

    FOR             reduce using rule 2 (class_content -> map .)
    WHILE           reduce using rule 2 (class_content -> map .)
    FINAL           reduce using rule 2 (class_content -> map .)
    IDENTIFIER      reduce using rule 2 (class_content -> map .)
    BOOL            reduce using rule 2 (class_content -> map .)
    LIST            reduce using rule 2 (class_content -> map .)
    MAP             reduce using rule 2 (class_content -> map .)
    IF              reduce using rule 2 (class_content -> map .)
    VAR             reduce using rule 2 (class_content -> map .)
    INTEGER         reduce using rule 2 (class_content -> map .)
    FLOAT           reduce using rule 2 (class_content -> map .)
    STR             reduce using rule 2 (class_content -> map .)
    BOOLEAN         reduce using rule 2 (class_content -> map .)
    INT             reduce using rule 2 (class_content -> map .)
    STRING          reduce using rule 2 (class_content -> map .)
    DOUBLE          reduce using rule 2 (class_content -> map .)
    DYNAMIC         reduce using rule 2 (class_content -> map .)
    VOID            reduce using rule 2 (class_content -> map .)
    $end            reduce using rule 2 (class_content -> map .)
    RCURLYBRACKET   reduce using rule 2 (class_content -> map .)


state 5

    (3) class_content -> ifElseStatement .

    FOR             reduce using rule 3 (class_content -> ifElseStatement .)
    WHILE           reduce using rule 3 (class_content -> ifElseStatement .)
    FINAL           reduce using rule 3 (class_content -> ifElseStatement .)
    IDENTIFIER      reduce using rule 3 (class_content -> ifElseStatement .)
    BOOL            reduce using rule 3 (class_content -> ifElseStatement .)
    LIST            reduce using rule 3 (class_content -> ifElseStatement .)
    MAP             reduce using rule 3 (class_content -> ifElseStatement .)
    IF              reduce using rule 3 (class_content -> ifElseStatement .)
    VAR             reduce using rule 3 (class_content -> ifElseStatement .)
    INTEGER         reduce using rule 3 (class_content -> ifElseStatement .)
    FLOAT           reduce using rule 3 (class_content -> ifElseStatement .)
    STR             reduce using rule 3 (class_content -> ifElseStatement .)
    BOOLEAN         reduce using rule 3 (class_content -> ifElseStatement .)
    INT             reduce using rule 3 (class_content -> ifElseStatement .)
    STRING          reduce using rule 3 (class_content -> ifElseStatement .)
    DOUBLE          reduce using rule 3 (class_content -> ifElseStatement .)
    DYNAMIC         reduce using rule 3 (class_content -> ifElseStatement .)
    VOID            reduce using rule 3 (class_content -> ifElseStatement .)
    $end            reduce using rule 3 (class_content -> ifElseStatement .)
    RCURLYBRACKET   reduce using rule 3 (class_content -> ifElseStatement .)


state 6

    (4) class_content -> function_lambda .

    FOR             reduce using rule 4 (class_content -> function_lambda .)
    WHILE           reduce using rule 4 (class_content -> function_lambda .)
    FINAL           reduce using rule 4 (class_content -> function_lambda .)
    IDENTIFIER      reduce using rule 4 (class_content -> function_lambda .)
    BOOL            reduce using rule 4 (class_content -> function_lambda .)
    LIST            reduce using rule 4 (class_content -> function_lambda .)
    MAP             reduce using rule 4 (class_content -> function_lambda .)
    IF              reduce using rule 4 (class_content -> function_lambda .)
    VAR             reduce using rule 4 (class_content -> function_lambda .)
    INTEGER         reduce using rule 4 (class_content -> function_lambda .)
    FLOAT           reduce using rule 4 (class_content -> function_lambda .)
    STR             reduce using rule 4 (class_content -> function_lambda .)
    BOOLEAN         reduce using rule 4 (class_content -> function_lambda .)
    INT             reduce using rule 4 (class_content -> function_lambda .)
    STRING          reduce using rule 4 (class_content -> function_lambda .)
    DOUBLE          reduce using rule 4 (class_content -> function_lambda .)
    DYNAMIC         reduce using rule 4 (class_content -> function_lambda .)
    VOID            reduce using rule 4 (class_content -> function_lambda .)
    $end            reduce using rule 4 (class_content -> function_lambda .)
    RCURLYBRACKET   reduce using rule 4 (class_content -> function_lambda .)


state 7

    (5) class_content -> declarationExpression .

    FOR             reduce using rule 5 (class_content -> declarationExpression .)
    WHILE           reduce using rule 5 (class_content -> declarationExpression .)
    FINAL           reduce using rule 5 (class_content -> declarationExpression .)
    IDENTIFIER      reduce using rule 5 (class_content -> declarationExpression .)
    BOOL            reduce using rule 5 (class_content -> declarationExpression .)
    LIST            reduce using rule 5 (class_content -> declarationExpression .)
    MAP             reduce using rule 5 (class_content -> declarationExpression .)
    IF              reduce using rule 5 (class_content -> declarationExpression .)
    VAR             reduce using rule 5 (class_content -> declarationExpression .)
    INTEGER         reduce using rule 5 (class_content -> declarationExpression .)
    FLOAT           reduce using rule 5 (class_content -> declarationExpression .)
    STR             reduce using rule 5 (class_content -> declarationExpression .)
    BOOLEAN         reduce using rule 5 (class_content -> declarationExpression .)
    INT             reduce using rule 5 (class_content -> declarationExpression .)
    STRING          reduce using rule 5 (class_content -> declarationExpression .)
    DOUBLE          reduce using rule 5 (class_content -> declarationExpression .)
    DYNAMIC         reduce using rule 5 (class_content -> declarationExpression .)
    VOID            reduce using rule 5 (class_content -> declarationExpression .)
    $end            reduce using rule 5 (class_content -> declarationExpression .)
    RCURLYBRACKET   reduce using rule 5 (class_content -> declarationExpression .)


state 8

    (6) class_content -> forStatement .

    FOR             reduce using rule 6 (class_content -> forStatement .)
    WHILE           reduce using rule 6 (class_content -> forStatement .)
    FINAL           reduce using rule 6 (class_content -> forStatement .)
    IDENTIFIER      reduce using rule 6 (class_content -> forStatement .)
    BOOL            reduce using rule 6 (class_content -> forStatement .)
    LIST            reduce using rule 6 (class_content -> forStatement .)
    MAP             reduce using rule 6 (class_content -> forStatement .)
    IF              reduce using rule 6 (class_content -> forStatement .)
    VAR             reduce using rule 6 (class_content -> forStatement .)
    INTEGER         reduce using rule 6 (class_content -> forStatement .)
    FLOAT           reduce using rule 6 (class_content -> forStatement .)
    STR             reduce using rule 6 (class_content -> forStatement .)
    BOOLEAN         reduce using rule 6 (class_content -> forStatement .)
    INT             reduce using rule 6 (class_content -> forStatement .)
    STRING          reduce using rule 6 (class_content -> forStatement .)
    DOUBLE          reduce using rule 6 (class_content -> forStatement .)
    DYNAMIC         reduce using rule 6 (class_content -> forStatement .)
    VOID            reduce using rule 6 (class_content -> forStatement .)
    $end            reduce using rule 6 (class_content -> forStatement .)
    RCURLYBRACKET   reduce using rule 6 (class_content -> forStatement .)


state 9

    (7) class_content -> while .

    FOR             reduce using rule 7 (class_content -> while .)
    WHILE           reduce using rule 7 (class_content -> while .)
    FINAL           reduce using rule 7 (class_content -> while .)
    IDENTIFIER      reduce using rule 7 (class_content -> while .)
    BOOL            reduce using rule 7 (class_content -> while .)
    LIST            reduce using rule 7 (class_content -> while .)
    MAP             reduce using rule 7 (class_content -> while .)
    IF              reduce using rule 7 (class_content -> while .)
    VAR             reduce using rule 7 (class_content -> while .)
    INTEGER         reduce using rule 7 (class_content -> while .)
    FLOAT           reduce using rule 7 (class_content -> while .)
    STR             reduce using rule 7 (class_content -> while .)
    BOOLEAN         reduce using rule 7 (class_content -> while .)
    INT             reduce using rule 7 (class_content -> while .)
    STRING          reduce using rule 7 (class_content -> while .)
    DOUBLE          reduce using rule 7 (class_content -> while .)
    DYNAMIC         reduce using rule 7 (class_content -> while .)
    VOID            reduce using rule 7 (class_content -> while .)
    $end            reduce using rule 7 (class_content -> while .)
    RCURLYBRACKET   reduce using rule 7 (class_content -> while .)


state 10

    (8) class_content -> stack .

    FOR             reduce using rule 8 (class_content -> stack .)
    WHILE           reduce using rule 8 (class_content -> stack .)
    FINAL           reduce using rule 8 (class_content -> stack .)
    IDENTIFIER      reduce using rule 8 (class_content -> stack .)
    BOOL            reduce using rule 8 (class_content -> stack .)
    LIST            reduce using rule 8 (class_content -> stack .)
    MAP             reduce using rule 8 (class_content -> stack .)
    IF              reduce using rule 8 (class_content -> stack .)
    VAR             reduce using rule 8 (class_content -> stack .)
    INTEGER         reduce using rule 8 (class_content -> stack .)
    FLOAT           reduce using rule 8 (class_content -> stack .)
    STR             reduce using rule 8 (class_content -> stack .)
    BOOLEAN         reduce using rule 8 (class_content -> stack .)
    INT             reduce using rule 8 (class_content -> stack .)
    STRING          reduce using rule 8 (class_content -> stack .)
    DOUBLE          reduce using rule 8 (class_content -> stack .)
    DYNAMIC         reduce using rule 8 (class_content -> stack .)
    VOID            reduce using rule 8 (class_content -> stack .)
    $end            reduce using rule 8 (class_content -> stack .)
    RCURLYBRACKET   reduce using rule 8 (class_content -> stack .)


state 11

    (9) class_content -> inferedReturnFunction .

    FOR             reduce using rule 9 (class_content -> inferedReturnFunction .)
    WHILE           reduce using rule 9 (class_content -> inferedReturnFunction .)
    FINAL           reduce using rule 9 (class_content -> inferedReturnFunction .)
    IDENTIFIER      reduce using rule 9 (class_content -> inferedReturnFunction .)
    BOOL            reduce using rule 9 (class_content -> inferedReturnFunction .)
    LIST            reduce using rule 9 (class_content -> inferedReturnFunction .)
    MAP             reduce using rule 9 (class_content -> inferedReturnFunction .)
    IF              reduce using rule 9 (class_content -> inferedReturnFunction .)
    VAR             reduce using rule 9 (class_content -> inferedReturnFunction .)
    INTEGER         reduce using rule 9 (class_content -> inferedReturnFunction .)
    FLOAT           reduce using rule 9 (class_content -> inferedReturnFunction .)
    STR             reduce using rule 9 (class_content -> inferedReturnFunction .)
    BOOLEAN         reduce using rule 9 (class_content -> inferedReturnFunction .)
    INT             reduce using rule 9 (class_content -> inferedReturnFunction .)
    STRING          reduce using rule 9 (class_content -> inferedReturnFunction .)
    DOUBLE          reduce using rule 9 (class_content -> inferedReturnFunction .)
    DYNAMIC         reduce using rule 9 (class_content -> inferedReturnFunction .)
    VOID            reduce using rule 9 (class_content -> inferedReturnFunction .)
    $end            reduce using rule 9 (class_content -> inferedReturnFunction .)
    RCURLYBRACKET   reduce using rule 9 (class_content -> inferedReturnFunction .)


state 12

    (10) class_content -> expression . SEMICOLON

    SEMICOLON       shift and go to state 41


state 13

    (13) class_content -> bool .

    FOR             reduce using rule 13 (class_content -> bool .)
    WHILE           reduce using rule 13 (class_content -> bool .)
    FINAL           reduce using rule 13 (class_content -> bool .)
    IDENTIFIER      reduce using rule 13 (class_content -> bool .)
    BOOL            reduce using rule 13 (class_content -> bool .)
    LIST            reduce using rule 13 (class_content -> bool .)
    MAP             reduce using rule 13 (class_content -> bool .)
    IF              reduce using rule 13 (class_content -> bool .)
    VAR             reduce using rule 13 (class_content -> bool .)
    INTEGER         reduce using rule 13 (class_content -> bool .)
    FLOAT           reduce using rule 13 (class_content -> bool .)
    STR             reduce using rule 13 (class_content -> bool .)
    BOOLEAN         reduce using rule 13 (class_content -> bool .)
    INT             reduce using rule 13 (class_content -> bool .)
    STRING          reduce using rule 13 (class_content -> bool .)
    DOUBLE          reduce using rule 13 (class_content -> bool .)
    DYNAMIC         reduce using rule 13 (class_content -> bool .)
    VOID            reduce using rule 13 (class_content -> bool .)
    $end            reduce using rule 13 (class_content -> bool .)
    RCURLYBRACKET   reduce using rule 13 (class_content -> bool .)


state 14

    (14) class_content -> semanticlist .

    FOR             reduce using rule 14 (class_content -> semanticlist .)
    WHILE           reduce using rule 14 (class_content -> semanticlist .)
    FINAL           reduce using rule 14 (class_content -> semanticlist .)
    IDENTIFIER      reduce using rule 14 (class_content -> semanticlist .)
    BOOL            reduce using rule 14 (class_content -> semanticlist .)
    LIST            reduce using rule 14 (class_content -> semanticlist .)
    MAP             reduce using rule 14 (class_content -> semanticlist .)
    IF              reduce using rule 14 (class_content -> semanticlist .)
    VAR             reduce using rule 14 (class_content -> semanticlist .)
    INTEGER         reduce using rule 14 (class_content -> semanticlist .)
    FLOAT           reduce using rule 14 (class_content -> semanticlist .)
    STR             reduce using rule 14 (class_content -> semanticlist .)
    BOOLEAN         reduce using rule 14 (class_content -> semanticlist .)
    INT             reduce using rule 14 (class_content -> semanticlist .)
    STRING          reduce using rule 14 (class_content -> semanticlist .)
    DOUBLE          reduce using rule 14 (class_content -> semanticlist .)
    DYNAMIC         reduce using rule 14 (class_content -> semanticlist .)
    VOID            reduce using rule 14 (class_content -> semanticlist .)
    $end            reduce using rule 14 (class_content -> semanticlist .)
    RCURLYBRACKET   reduce using rule 14 (class_content -> semanticlist .)


state 15

    (15) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (27) returnType -> map_identifier .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 42

  ! IDENTIFIER      [ reduce using rule 27 (returnType -> map_identifier .) ]


state 16

    (48) inferedReturnFunction -> IDENTIFIER . LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) operableTypes -> IDENTIFIER .
    (53) value -> IDENTIFIER .

    LPAREN          shift and go to state 43
    PLUS            reduce using rule 95 (operableTypes -> IDENTIFIER .)
    MINUS           reduce using rule 95 (operableTypes -> IDENTIFIER .)
    TIMES           reduce using rule 95 (operableTypes -> IDENTIFIER .)
    DIVISION        reduce using rule 95 (operableTypes -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (value -> IDENTIFIER .)


state 17

    (36) ifElseStatement -> ifStatement .
    (37) ifElseStatement -> ifStatement . elifStatement_repeat
    (38) elifStatement_repeat -> . elifStatement
    (39) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (41) elifStatement -> . ELSE ifStatement
    (42) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    FOR             reduce using rule 36 (ifElseStatement -> ifStatement .)
    WHILE           reduce using rule 36 (ifElseStatement -> ifStatement .)
    FINAL           reduce using rule 36 (ifElseStatement -> ifStatement .)
    IDENTIFIER      reduce using rule 36 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 36 (ifElseStatement -> ifStatement .)
    LIST            reduce using rule 36 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 36 (ifElseStatement -> ifStatement .)
    IF              reduce using rule 36 (ifElseStatement -> ifStatement .)
    VAR             reduce using rule 36 (ifElseStatement -> ifStatement .)
    INTEGER         reduce using rule 36 (ifElseStatement -> ifStatement .)
    FLOAT           reduce using rule 36 (ifElseStatement -> ifStatement .)
    STR             reduce using rule 36 (ifElseStatement -> ifStatement .)
    BOOLEAN         reduce using rule 36 (ifElseStatement -> ifStatement .)
    INT             reduce using rule 36 (ifElseStatement -> ifStatement .)
    STRING          reduce using rule 36 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 36 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 36 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 36 (ifElseStatement -> ifStatement .)
    $end            reduce using rule 36 (ifElseStatement -> ifStatement .)
    RCURLYBRACKET   reduce using rule 36 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 46

    elifStatement_repeat           shift and go to state 44
    elifStatement                  shift and go to state 45

state 18

    (82) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> datatype . IDENTIFIER SEMICOLON
    (102) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 47


state 19

    (43) forStatement -> FOR . LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    LPAREN          shift and go to state 48


state 20

    (45) while -> WHILE . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 49


state 21

    (44) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> FINAL . IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 50


state 22

    (92) expression -> operableTypes . operatorExpression operableTypes
    (94) expression -> operableTypes . operatorExpression operatorExpression
    (97) operatorExpression -> . PLUS
    (98) operatorExpression -> . MINUS
    (99) operatorExpression -> . TIMES
    (100) operatorExpression -> . DIVISION

    PLUS            shift and go to state 52
    MINUS           shift and go to state 53
    TIMES           shift and go to state 54
    DIVISION        shift and go to state 55

    operatorExpression             shift and go to state 51

state 23

    (93) expression -> value .

    SEMICOLON       reduce using rule 93 (expression -> value .)
    RPAREN          reduce using rule 93 (expression -> value .)


state 24

    (105) bool -> BOOL . IDENTIFIER EQUAL boolvalue SEMICOLON
    (23) returnType -> BOOL .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 56

  ! IDENTIFIER      [ reduce using rule 23 (returnType -> BOOL .) ]


state 25

    (112) semanticlist -> LIST . LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    LESSTHAN        shift and go to state 57


state 26

    (16) map_identifier -> MAP .
    (17) map_identifier -> MAP . map_type_specified
    (18) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 16 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 16 (map_identifier -> MAP .)
    COMMA           reduce using rule 16 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 59

    map_type_specified             shift and go to state 58

state 27

    (40) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 60


state 28

    (19) datatype -> returnType .

    IDENTIFIER      reduce using rule 19 (datatype -> returnType .)
    GREATERTHAN     reduce using rule 19 (datatype -> returnType .)
    COMMA           reduce using rule 19 (datatype -> returnType .)


state 29

    (20) datatype -> VAR .

    IDENTIFIER      reduce using rule 20 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 20 (datatype -> VAR .)
    COMMA           reduce using rule 20 (datatype -> VAR .)


state 30

    (96) operableTypes -> number .

    PLUS            reduce using rule 96 (operableTypes -> number .)
    MINUS           reduce using rule 96 (operableTypes -> number .)
    TIMES           reduce using rule 96 (operableTypes -> number .)
    DIVISION        reduce using rule 96 (operableTypes -> number .)
    SEMICOLON       reduce using rule 96 (operableTypes -> number .)
    RPAREN          reduce using rule 96 (operableTypes -> number .)


state 31

    (49) value -> INTEGER .
    (70) number -> INTEGER .

    SEMICOLON       reduce using rule 49 (value -> INTEGER .)
    RPAREN          reduce using rule 49 (value -> INTEGER .)
    PLUS            reduce using rule 70 (number -> INTEGER .)
    MINUS           reduce using rule 70 (number -> INTEGER .)
    TIMES           reduce using rule 70 (number -> INTEGER .)
    DIVISION        reduce using rule 70 (number -> INTEGER .)


state 32

    (50) value -> FLOAT .
    (69) number -> FLOAT .

    SEMICOLON       reduce using rule 50 (value -> FLOAT .)
    RPAREN          reduce using rule 50 (value -> FLOAT .)
    PLUS            reduce using rule 69 (number -> FLOAT .)
    MINUS           reduce using rule 69 (number -> FLOAT .)
    TIMES           reduce using rule 69 (number -> FLOAT .)
    DIVISION        reduce using rule 69 (number -> FLOAT .)


state 33

    (51) value -> STR .

    SEMICOLON       reduce using rule 51 (value -> STR .)
    COLON           reduce using rule 51 (value -> STR .)
    COMMA           reduce using rule 51 (value -> STR .)
    RCURLYBRACKET   reduce using rule 51 (value -> STR .)
    RPAREN          reduce using rule 51 (value -> STR .)
    RSQUAREBRACKET  reduce using rule 51 (value -> STR .)


state 34

    (52) value -> BOOLEAN .

    SEMICOLON       reduce using rule 52 (value -> BOOLEAN .)
    COLON           reduce using rule 52 (value -> BOOLEAN .)
    COMMA           reduce using rule 52 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 52 (value -> BOOLEAN .)
    RPAREN          reduce using rule 52 (value -> BOOLEAN .)
    RSQUAREBRACKET  reduce using rule 52 (value -> BOOLEAN .)


state 35

    (21) returnType -> INT .

    IDENTIFIER      reduce using rule 21 (returnType -> INT .)
    GREATERTHAN     reduce using rule 21 (returnType -> INT .)
    COMMA           reduce using rule 21 (returnType -> INT .)


state 36

    (22) returnType -> STRING .

    IDENTIFIER      reduce using rule 22 (returnType -> STRING .)
    GREATERTHAN     reduce using rule 22 (returnType -> STRING .)
    COMMA           reduce using rule 22 (returnType -> STRING .)


state 37

    (24) returnType -> DOUBLE .

    IDENTIFIER      reduce using rule 24 (returnType -> DOUBLE .)
    GREATERTHAN     reduce using rule 24 (returnType -> DOUBLE .)
    COMMA           reduce using rule 24 (returnType -> DOUBLE .)


state 38

    (25) returnType -> DYNAMIC .

    IDENTIFIER      reduce using rule 25 (returnType -> DYNAMIC .)
    GREATERTHAN     reduce using rule 25 (returnType -> DYNAMIC .)
    COMMA           reduce using rule 25 (returnType -> DYNAMIC .)


state 39

    (26) returnType -> VOID .

    IDENTIFIER      reduce using rule 26 (returnType -> VOID .)
    GREATERTHAN     reduce using rule 26 (returnType -> VOID .)
    COMMA           reduce using rule 26 (returnType -> VOID .)


state 40

    (12) class_content_repeat -> class_content_repeat class_content .

    FOR             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    WHILE           reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    FINAL           reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    IDENTIFIER      reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    BOOL            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    LIST            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    MAP             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    IF              reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    VAR             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    INTEGER         reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    FLOAT           reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    STR             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    BOOLEAN         reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    INT             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    STRING          reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    DOUBLE          reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    DYNAMIC         reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    VOID            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    $end            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    RCURLYBRACKET   reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)


state 41

    (10) class_content -> expression SEMICOLON .

    FOR             reduce using rule 10 (class_content -> expression SEMICOLON .)
    WHILE           reduce using rule 10 (class_content -> expression SEMICOLON .)
    FINAL           reduce using rule 10 (class_content -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 10 (class_content -> expression SEMICOLON .)
    BOOL            reduce using rule 10 (class_content -> expression SEMICOLON .)
    LIST            reduce using rule 10 (class_content -> expression SEMICOLON .)
    MAP             reduce using rule 10 (class_content -> expression SEMICOLON .)
    IF              reduce using rule 10 (class_content -> expression SEMICOLON .)
    VAR             reduce using rule 10 (class_content -> expression SEMICOLON .)
    INTEGER         reduce using rule 10 (class_content -> expression SEMICOLON .)
    FLOAT           reduce using rule 10 (class_content -> expression SEMICOLON .)
    STR             reduce using rule 10 (class_content -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 10 (class_content -> expression SEMICOLON .)
    INT             reduce using rule 10 (class_content -> expression SEMICOLON .)
    STRING          reduce using rule 10 (class_content -> expression SEMICOLON .)
    DOUBLE          reduce using rule 10 (class_content -> expression SEMICOLON .)
    DYNAMIC         reduce using rule 10 (class_content -> expression SEMICOLON .)
    VOID            reduce using rule 10 (class_content -> expression SEMICOLON .)
    $end            reduce using rule 10 (class_content -> expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 10 (class_content -> expression SEMICOLON .)


state 42

    (15) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 61


state 43

    (48) inferedReturnFunction -> IDENTIFIER LPAREN . function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (85) function_arguments_repeat -> . function_argument
    (86) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (83) function_argument -> . datatype IDENTIFIER
    (84) function_argument -> . empty
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (28) empty -> .
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    COMMA           reduce using rule 28 (empty -> .)
    RPAREN          reduce using rule 28 (empty -> .)
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    function_arguments_repeat      shift and go to state 62
    function_argument              shift and go to state 63
    datatype                       shift and go to state 64
    empty                          shift and go to state 65
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 44

    (37) ifElseStatement -> ifStatement elifStatement_repeat .

    FOR             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    WHILE           reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FINAL           reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    LIST            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IF              reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VAR             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STR             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INT             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STRING          reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    $end            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 45

    (38) elifStatement_repeat -> elifStatement .
    (39) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (38) elifStatement_repeat -> . elifStatement
    (39) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (41) elifStatement -> . ELSE ifStatement
    (42) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    FOR             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    WHILE           reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    FINAL           reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    IDENTIFIER      reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    LIST            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    IF              reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    VAR             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    INTEGER         reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    FLOAT           reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    STR             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    BOOLEAN         reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    INT             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    STRING          reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    $end            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    RCURLYBRACKET   reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 46

    elifStatement                  shift and go to state 45
    elifStatement_repeat           shift and go to state 68

state 46

    (41) elifStatement -> ELSE . ifStatement
    (42) elifStatement -> ELSE . LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 70
    IF              shift and go to state 27

    ifStatement                    shift and go to state 69

state 47

    (82) function_lambda -> datatype IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> datatype IDENTIFIER . SEMICOLON
    (102) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON

    LPAREN          shift and go to state 71
    SEMICOLON       shift and go to state 73
    EQUAL           shift and go to state 72


state 48

    (43) forStatement -> FOR LPAREN . declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    declarationExpression          shift and go to state 74
    datatype                       shift and go to state 75
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 49

    (45) while -> WHILE LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (76) conditions -> . condition
    (77) conditions -> . condition condition_connector conditions
    (71) condition -> . IDENTIFIER condition_operator condition_values
    (72) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (73) condition -> . BOOLEAN condition_operator BOOLEAN
    (74) condition -> . number condition_operator number
    (75) condition -> . STR condition_operator STR
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 78
    EXMARK          shift and go to state 79
    BOOLEAN         shift and go to state 80
    STR             shift and go to state 82
    FLOAT           shift and go to state 83
    INTEGER         shift and go to state 84

    conditions                     shift and go to state 76
    condition                      shift and go to state 77
    number                         shift and go to state 81

state 50

    (44) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> FINAL IDENTIFIER . EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    EQUAL           shift and go to state 85


state 51

    (92) expression -> operableTypes operatorExpression . operableTypes
    (94) expression -> operableTypes operatorExpression . operatorExpression
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (97) operatorExpression -> . PLUS
    (98) operatorExpression -> . MINUS
    (99) operatorExpression -> . TIMES
    (100) operatorExpression -> . DIVISION
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 88
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53
    TIMES           shift and go to state 54
    DIVISION        shift and go to state 55
    FLOAT           shift and go to state 83
    INTEGER         shift and go to state 84

    operableTypes                  shift and go to state 86
    operatorExpression             shift and go to state 87
    number                         shift and go to state 30

state 52

    (97) operatorExpression -> PLUS .

    IDENTIFIER      reduce using rule 97 (operatorExpression -> PLUS .)
    PLUS            reduce using rule 97 (operatorExpression -> PLUS .)
    MINUS           reduce using rule 97 (operatorExpression -> PLUS .)
    TIMES           reduce using rule 97 (operatorExpression -> PLUS .)
    DIVISION        reduce using rule 97 (operatorExpression -> PLUS .)
    FLOAT           reduce using rule 97 (operatorExpression -> PLUS .)
    INTEGER         reduce using rule 97 (operatorExpression -> PLUS .)
    SEMICOLON       reduce using rule 97 (operatorExpression -> PLUS .)
    RPAREN          reduce using rule 97 (operatorExpression -> PLUS .)


state 53

    (98) operatorExpression -> MINUS .

    IDENTIFIER      reduce using rule 98 (operatorExpression -> MINUS .)
    PLUS            reduce using rule 98 (operatorExpression -> MINUS .)
    MINUS           reduce using rule 98 (operatorExpression -> MINUS .)
    TIMES           reduce using rule 98 (operatorExpression -> MINUS .)
    DIVISION        reduce using rule 98 (operatorExpression -> MINUS .)
    FLOAT           reduce using rule 98 (operatorExpression -> MINUS .)
    INTEGER         reduce using rule 98 (operatorExpression -> MINUS .)
    SEMICOLON       reduce using rule 98 (operatorExpression -> MINUS .)
    RPAREN          reduce using rule 98 (operatorExpression -> MINUS .)


state 54

    (99) operatorExpression -> TIMES .

    IDENTIFIER      reduce using rule 99 (operatorExpression -> TIMES .)
    PLUS            reduce using rule 99 (operatorExpression -> TIMES .)
    MINUS           reduce using rule 99 (operatorExpression -> TIMES .)
    TIMES           reduce using rule 99 (operatorExpression -> TIMES .)
    DIVISION        reduce using rule 99 (operatorExpression -> TIMES .)
    FLOAT           reduce using rule 99 (operatorExpression -> TIMES .)
    INTEGER         reduce using rule 99 (operatorExpression -> TIMES .)
    SEMICOLON       reduce using rule 99 (operatorExpression -> TIMES .)
    RPAREN          reduce using rule 99 (operatorExpression -> TIMES .)


state 55

    (100) operatorExpression -> DIVISION .

    IDENTIFIER      reduce using rule 100 (operatorExpression -> DIVISION .)
    PLUS            reduce using rule 100 (operatorExpression -> DIVISION .)
    MINUS           reduce using rule 100 (operatorExpression -> DIVISION .)
    TIMES           reduce using rule 100 (operatorExpression -> DIVISION .)
    DIVISION        reduce using rule 100 (operatorExpression -> DIVISION .)
    FLOAT           reduce using rule 100 (operatorExpression -> DIVISION .)
    INTEGER         reduce using rule 100 (operatorExpression -> DIVISION .)
    SEMICOLON       reduce using rule 100 (operatorExpression -> DIVISION .)
    RPAREN          reduce using rule 100 (operatorExpression -> DIVISION .)


state 56

    (105) bool -> BOOL IDENTIFIER . EQUAL boolvalue SEMICOLON

    EQUAL           shift and go to state 89


state 57

    (112) semanticlist -> LIST LESSTHAN . datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    datatype                       shift and go to state 90
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 58

    (17) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 17 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 17 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 17 (map_identifier -> MAP map_type_specified .)


state 59

    (18) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    datatype                       shift and go to state 91
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 60

    (40) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (76) conditions -> . condition
    (77) conditions -> . condition condition_connector conditions
    (71) condition -> . IDENTIFIER condition_operator condition_values
    (72) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (73) condition -> . BOOLEAN condition_operator BOOLEAN
    (74) condition -> . number condition_operator number
    (75) condition -> . STR condition_operator STR
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 78
    EXMARK          shift and go to state 79
    BOOLEAN         shift and go to state 80
    STR             shift and go to state 82
    FLOAT           shift and go to state 83
    INTEGER         shift and go to state 84

    conditions                     shift and go to state 92
    condition                      shift and go to state 77
    number                         shift and go to state 81

state 61

    (15) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 93


state 62

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat . RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    RPAREN          shift and go to state 94


state 63

    (85) function_arguments_repeat -> function_argument .
    (86) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    RPAREN          reduce using rule 85 (function_arguments_repeat -> function_argument .)
    LCURLYBRACKET   reduce using rule 85 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 95


state 64

    (83) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 96


state 65

    (84) function_argument -> empty .

    COMMA           reduce using rule 84 (function_argument -> empty .)
    RPAREN          reduce using rule 84 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 84 (function_argument -> empty .)


state 66

    (23) returnType -> BOOL .

    IDENTIFIER      reduce using rule 23 (returnType -> BOOL .)
    GREATERTHAN     reduce using rule 23 (returnType -> BOOL .)
    COMMA           reduce using rule 23 (returnType -> BOOL .)


state 67

    (27) returnType -> map_identifier .

    IDENTIFIER      reduce using rule 27 (returnType -> map_identifier .)
    GREATERTHAN     reduce using rule 27 (returnType -> map_identifier .)
    COMMA           reduce using rule 27 (returnType -> map_identifier .)


state 68

    (39) elifStatement_repeat -> elifStatement elifStatement_repeat .

    FOR             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    WHILE           reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FINAL           reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    LIST            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IF              reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VAR             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STR             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INT             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STRING          reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    $end            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 69

    (41) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    FOR             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    WHILE           reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    FINAL           reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    IDENTIFIER      reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    LIST            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    IF              reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    VAR             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    INTEGER         reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    FLOAT           reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    STR             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    BOOLEAN         reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    $end            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    RCURLYBRACKET   reduce using rule 41 (elifStatement -> ELSE ifStatement .)


state 70

    (42) elifStatement -> ELSE LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (11) class_content_repeat -> . class_content
    (12) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . bool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (82) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (105) bool -> . BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
    (112) semanticlist -> . LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    FOR             shift and go to state 19
    WHILE           shift and go to state 20
    FINAL           shift and go to state 21
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 24
    LIST            shift and go to state 25
    MAP             shift and go to state 26
    IF              shift and go to state 27
    VAR             shift and go to state 29
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    INT             shift and go to state 35
    STRING          shift and go to state 36
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39

    class_content_repeat           shift and go to state 97
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    bool                           shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    returnType                     shift and go to state 28
    number                         shift and go to state 30

state 71

    (82) function_lambda -> datatype IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (85) function_arguments_repeat -> . function_argument
    (86) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (83) function_argument -> . datatype IDENTIFIER
    (84) function_argument -> . empty
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (28) empty -> .
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    COMMA           reduce using rule 28 (empty -> .)
    LCURLYBRACKET   reduce using rule 28 (empty -> .)
    RPAREN          reduce using rule 28 (empty -> .)
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    datatype                       shift and go to state 64
    function_arguments_repeat      shift and go to state 98
    function_argument              shift and go to state 63
    empty                          shift and go to state 65
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 72

    (102) declarationExpression -> datatype IDENTIFIER EQUAL . expression SEMICOLON
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34

    expression                     shift and go to state 100
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    number                         shift and go to state 30

state 73

    (101) declarationExpression -> datatype IDENTIFIER SEMICOLON .

    FOR             reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    FINAL           reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    IF              reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    STR             reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    INT             reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    $end            reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 101 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)


state 74

    (43) forStatement -> FOR LPAREN declarationExpression . SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 101


state 75

    (101) declarationExpression -> datatype . IDENTIFIER SEMICOLON
    (102) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 102


state 76

    (45) while -> WHILE LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 103


state 77

    (76) conditions -> condition .
    (77) conditions -> condition . condition_connector conditions
    (78) condition_connector -> . AND
    (79) condition_connector -> . OR
    (80) condition_connector -> . AMPERSAND AMPERSAND
    (81) condition_connector -> . PIPELINE PIPELINE

    RPAREN          reduce using rule 76 (conditions -> condition .)
    AND             shift and go to state 105
    OR              shift and go to state 106
    AMPERSAND       shift and go to state 107
    PIPELINE        shift and go to state 108

    condition_connector            shift and go to state 104

state 78

    (71) condition -> IDENTIFIER . condition_operator condition_values
    (64) condition_operator -> . DOUBLEQUAL
    (65) condition_operator -> . LESSTHAN
    (66) condition_operator -> . GREATERTHAN
    (67) condition_operator -> . LESSTHAN EQUAL
    (68) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 110
    LESSTHAN        shift and go to state 111
    GREATERTHAN     shift and go to state 112

    condition_operator             shift and go to state 109

state 79

    (72) condition -> EXMARK . IDENTIFIER condition_operator condition_values

    IDENTIFIER      shift and go to state 113


state 80

    (73) condition -> BOOLEAN . condition_operator BOOLEAN
    (64) condition_operator -> . DOUBLEQUAL
    (65) condition_operator -> . LESSTHAN
    (66) condition_operator -> . GREATERTHAN
    (67) condition_operator -> . LESSTHAN EQUAL
    (68) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 110
    LESSTHAN        shift and go to state 111
    GREATERTHAN     shift and go to state 112

    condition_operator             shift and go to state 114

state 81

    (74) condition -> number . condition_operator number
    (64) condition_operator -> . DOUBLEQUAL
    (65) condition_operator -> . LESSTHAN
    (66) condition_operator -> . GREATERTHAN
    (67) condition_operator -> . LESSTHAN EQUAL
    (68) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 110
    LESSTHAN        shift and go to state 111
    GREATERTHAN     shift and go to state 112

    condition_operator             shift and go to state 115

state 82

    (75) condition -> STR . condition_operator STR
    (64) condition_operator -> . DOUBLEQUAL
    (65) condition_operator -> . LESSTHAN
    (66) condition_operator -> . GREATERTHAN
    (67) condition_operator -> . LESSTHAN EQUAL
    (68) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 110
    LESSTHAN        shift and go to state 111
    GREATERTHAN     shift and go to state 112

    condition_operator             shift and go to state 116

state 83

    (69) number -> FLOAT .

    DOUBLEQUAL      reduce using rule 69 (number -> FLOAT .)
    LESSTHAN        reduce using rule 69 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 69 (number -> FLOAT .)
    SEMICOLON       reduce using rule 69 (number -> FLOAT .)
    RPAREN          reduce using rule 69 (number -> FLOAT .)
    AND             reduce using rule 69 (number -> FLOAT .)
    OR              reduce using rule 69 (number -> FLOAT .)
    AMPERSAND       reduce using rule 69 (number -> FLOAT .)
    PIPELINE        reduce using rule 69 (number -> FLOAT .)


state 84

    (70) number -> INTEGER .

    DOUBLEQUAL      reduce using rule 70 (number -> INTEGER .)
    LESSTHAN        reduce using rule 70 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 70 (number -> INTEGER .)
    SEMICOLON       reduce using rule 70 (number -> INTEGER .)
    RPAREN          reduce using rule 70 (number -> INTEGER .)
    AND             reduce using rule 70 (number -> INTEGER .)
    OR              reduce using rule 70 (number -> INTEGER .)
    AMPERSAND       reduce using rule 70 (number -> INTEGER .)
    PIPELINE        reduce using rule 70 (number -> INTEGER .)


state 85

    (44) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> FINAL IDENTIFIER EQUAL . STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    STACK           shift and go to state 117


state 86

    (92) expression -> operableTypes operatorExpression operableTypes .

    SEMICOLON       reduce using rule 92 (expression -> operableTypes operatorExpression operableTypes .)
    RPAREN          reduce using rule 92 (expression -> operableTypes operatorExpression operableTypes .)


state 87

    (94) expression -> operableTypes operatorExpression operatorExpression .

    SEMICOLON       reduce using rule 94 (expression -> operableTypes operatorExpression operatorExpression .)
    RPAREN          reduce using rule 94 (expression -> operableTypes operatorExpression operatorExpression .)


state 88

    (95) operableTypes -> IDENTIFIER .

    SEMICOLON       reduce using rule 95 (operableTypes -> IDENTIFIER .)
    RPAREN          reduce using rule 95 (operableTypes -> IDENTIFIER .)


state 89

    (105) bool -> BOOL IDENTIFIER EQUAL . boolvalue SEMICOLON
    (103) boolvalue -> . TRUE
    (104) boolvalue -> . FALSE

    TRUE            shift and go to state 119
    FALSE           shift and go to state 120

    boolvalue                      shift and go to state 118

state 90

    (112) semanticlist -> LIST LESSTHAN datatype . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 121


state 91

    (18) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 122


state 92

    (40) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 123


state 93

    (15) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (29) map_content -> . map_pairs
    (30) map_content -> . empty
    (32) map_pairs -> . map_pair
    (33) map_pairs -> . map_pair COMMA map_pairs
    (28) empty -> .
    (31) map_pair -> . map_key COLON map_value
    (34) map_key -> . value
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER

    RCURLYBRACKET   reduce using rule 28 (empty -> .)
    INTEGER         shift and go to state 131
    FLOAT           shift and go to state 132
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    IDENTIFIER      shift and go to state 124

    map_content                    shift and go to state 125
    map_pairs                      shift and go to state 126
    empty                          shift and go to state 127
    map_pair                       shift and go to state 128
    map_key                        shift and go to state 129
    value                          shift and go to state 130

state 94

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN . LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 133


state 95

    (86) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (85) function_arguments_repeat -> . function_argument
    (86) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (83) function_argument -> . datatype IDENTIFIER
    (84) function_argument -> . empty
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (28) empty -> .
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    COMMA           reduce using rule 28 (empty -> .)
    RPAREN          reduce using rule 28 (empty -> .)
    LCURLYBRACKET   reduce using rule 28 (empty -> .)
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    function_argument              shift and go to state 63
    function_arguments_repeat      shift and go to state 134
    datatype                       shift and go to state 64
    empty                          shift and go to state 65
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 96

    (83) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 83 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 83 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 83 (function_argument -> datatype IDENTIFIER .)


state 97

    (42) elifStatement -> ELSE LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (12) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . bool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (82) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (105) bool -> . BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
    (112) semanticlist -> . LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    RCURLYBRACKET   shift and go to state 135
    FOR             shift and go to state 19
    WHILE           shift and go to state 20
    FINAL           shift and go to state 21
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 24
    LIST            shift and go to state 25
    MAP             shift and go to state 26
    IF              shift and go to state 27
    VAR             shift and go to state 29
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    INT             shift and go to state 35
    STRING          shift and go to state 36
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39

    class_content                  shift and go to state 40
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    bool                           shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    returnType                     shift and go to state 28
    number                         shift and go to state 30

state 98

    (82) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (87) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (88) optFunction_argumentsExpression -> . empty
    (28) empty -> .

    LCURLYBRACKET   shift and go to state 137
    RPAREN          reduce using rule 28 (empty -> .)

    optFunction_argumentsExpression shift and go to state 136
    empty                          shift and go to state 138

state 99

    (95) operableTypes -> IDENTIFIER .
    (53) value -> IDENTIFIER .

    PLUS            reduce using rule 95 (operableTypes -> IDENTIFIER .)
    MINUS           reduce using rule 95 (operableTypes -> IDENTIFIER .)
    TIMES           reduce using rule 95 (operableTypes -> IDENTIFIER .)
    DIVISION        reduce using rule 95 (operableTypes -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (value -> IDENTIFIER .)


state 100

    (102) declarationExpression -> datatype IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 139


state 101

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON . condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (71) condition -> . IDENTIFIER condition_operator condition_values
    (72) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (73) condition -> . BOOLEAN condition_operator BOOLEAN
    (74) condition -> . number condition_operator number
    (75) condition -> . STR condition_operator STR
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 78
    EXMARK          shift and go to state 79
    BOOLEAN         shift and go to state 80
    STR             shift and go to state 82
    FLOAT           shift and go to state 83
    INTEGER         shift and go to state 84

    condition                      shift and go to state 140
    number                         shift and go to state 81

state 102

    (101) declarationExpression -> datatype IDENTIFIER . SEMICOLON
    (102) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON

    SEMICOLON       shift and go to state 73
    EQUAL           shift and go to state 72


state 103

    (45) while -> WHILE LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 141


state 104

    (77) conditions -> condition condition_connector . conditions
    (76) conditions -> . condition
    (77) conditions -> . condition condition_connector conditions
    (71) condition -> . IDENTIFIER condition_operator condition_values
    (72) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (73) condition -> . BOOLEAN condition_operator BOOLEAN
    (74) condition -> . number condition_operator number
    (75) condition -> . STR condition_operator STR
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 78
    EXMARK          shift and go to state 79
    BOOLEAN         shift and go to state 80
    STR             shift and go to state 82
    FLOAT           shift and go to state 83
    INTEGER         shift and go to state 84

    condition                      shift and go to state 77
    conditions                     shift and go to state 142
    number                         shift and go to state 81

state 105

    (78) condition_connector -> AND .

    IDENTIFIER      reduce using rule 78 (condition_connector -> AND .)
    EXMARK          reduce using rule 78 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 78 (condition_connector -> AND .)
    STR             reduce using rule 78 (condition_connector -> AND .)
    FLOAT           reduce using rule 78 (condition_connector -> AND .)
    INTEGER         reduce using rule 78 (condition_connector -> AND .)


state 106

    (79) condition_connector -> OR .

    IDENTIFIER      reduce using rule 79 (condition_connector -> OR .)
    EXMARK          reduce using rule 79 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 79 (condition_connector -> OR .)
    STR             reduce using rule 79 (condition_connector -> OR .)
    FLOAT           reduce using rule 79 (condition_connector -> OR .)
    INTEGER         reduce using rule 79 (condition_connector -> OR .)


state 107

    (80) condition_connector -> AMPERSAND . AMPERSAND

    AMPERSAND       shift and go to state 143


state 108

    (81) condition_connector -> PIPELINE . PIPELINE

    PIPELINE        shift and go to state 144


state 109

    (71) condition -> IDENTIFIER condition_operator . condition_values
    (60) condition_values -> . negation_values
    (61) condition_values -> . INTEGER
    (62) condition_values -> . FLOAT
    (63) condition_values -> . STR
    (58) negation_values -> . deniable_values
    (59) negation_values -> . EXMARK deniable_values
    (56) deniable_values -> . IDENTIFIER
    (57) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    STR             shift and go to state 150
    EXMARK          shift and go to state 152
    IDENTIFIER      shift and go to state 145
    BOOLEAN         shift and go to state 153

    condition_values               shift and go to state 146
    negation_values                shift and go to state 147
    deniable_values                shift and go to state 151

state 110

    (64) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 64 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 64 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 64 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 64 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 64 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 64 (condition_operator -> DOUBLEQUAL .)


state 111

    (65) condition_operator -> LESSTHAN .
    (67) condition_operator -> LESSTHAN . EQUAL

    INTEGER         reduce using rule 65 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 65 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 65 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 65 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 65 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 65 (condition_operator -> LESSTHAN .)
    EQUAL           shift and go to state 154


state 112

    (66) condition_operator -> GREATERTHAN .
    (68) condition_operator -> GREATERTHAN . EQUAL

    INTEGER         reduce using rule 66 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 66 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 66 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 66 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 66 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 66 (condition_operator -> GREATERTHAN .)
    EQUAL           shift and go to state 155


state 113

    (72) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (64) condition_operator -> . DOUBLEQUAL
    (65) condition_operator -> . LESSTHAN
    (66) condition_operator -> . GREATERTHAN
    (67) condition_operator -> . LESSTHAN EQUAL
    (68) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 110
    LESSTHAN        shift and go to state 111
    GREATERTHAN     shift and go to state 112

    condition_operator             shift and go to state 156

state 114

    (73) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 157


state 115

    (74) condition -> number condition_operator . number
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    FLOAT           shift and go to state 83
    INTEGER         shift and go to state 84

    number                         shift and go to state 158

state 116

    (75) condition -> STR condition_operator . STR

    STR             shift and go to state 159


state 117

    (44) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> FINAL IDENTIFIER EQUAL STACK . DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    LESSTHAN        shift and go to state 160
    DOT             shift and go to state 161


state 118

    (105) bool -> BOOL IDENTIFIER EQUAL boolvalue . SEMICOLON

    SEMICOLON       shift and go to state 162


state 119

    (103) boolvalue -> TRUE .

    SEMICOLON       reduce using rule 103 (boolvalue -> TRUE .)


state 120

    (104) boolvalue -> FALSE .

    SEMICOLON       reduce using rule 104 (boolvalue -> FALSE .)


state 121

    (112) semanticlist -> LIST LESSTHAN datatype GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 163


state 122

    (18) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    datatype                       shift and go to state 164
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 123

    (40) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 165


state 124

    (53) value -> IDENTIFIER .

    COLON           reduce using rule 53 (value -> IDENTIFIER .)
    COMMA           reduce using rule 53 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 53 (value -> IDENTIFIER .)
    RSQUAREBRACKET  reduce using rule 53 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (value -> IDENTIFIER .)


state 125

    (15) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 166


state 126

    (29) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 29 (map_content -> map_pairs .)


state 127

    (30) map_content -> empty .

    RCURLYBRACKET   reduce using rule 30 (map_content -> empty .)


state 128

    (32) map_pairs -> map_pair .
    (33) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 32 (map_pairs -> map_pair .)
    COMMA           shift and go to state 167


state 129

    (31) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 168


state 130

    (34) map_key -> value .

    COLON           reduce using rule 34 (map_key -> value .)


state 131

    (49) value -> INTEGER .

    COLON           reduce using rule 49 (value -> INTEGER .)
    COMMA           reduce using rule 49 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 49 (value -> INTEGER .)
    RSQUAREBRACKET  reduce using rule 49 (value -> INTEGER .)
    RPAREN          reduce using rule 49 (value -> INTEGER .)


state 132

    (50) value -> FLOAT .

    COLON           reduce using rule 50 (value -> FLOAT .)
    COMMA           reduce using rule 50 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 50 (value -> FLOAT .)
    RSQUAREBRACKET  reduce using rule 50 (value -> FLOAT .)
    RPAREN          reduce using rule 50 (value -> FLOAT .)


state 133

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET . RETURN expression SEMICOLON RCURLYBRACKET

    RETURN          shift and go to state 169


state 134

    (86) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    RPAREN          reduce using rule 86 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    LCURLYBRACKET   reduce using rule 86 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 135

    (42) elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 136

    (82) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 170


state 137

    (87) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (90) optFunction_arguments -> . optFunction_argument
    (91) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (89) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 173

    optFunction_arguments          shift and go to state 171
    optFunction_argument           shift and go to state 172

state 138

    (88) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 88 (optFunction_argumentsExpression -> empty .)


state 139

    (102) declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .

    FOR             reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 102 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)


state 140

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition . SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 174


state 141

    (45) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (11) class_content_repeat -> . class_content
    (12) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . bool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (82) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (105) bool -> . BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
    (112) semanticlist -> . LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    FOR             shift and go to state 19
    WHILE           shift and go to state 20
    FINAL           shift and go to state 21
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 24
    LIST            shift and go to state 25
    MAP             shift and go to state 26
    IF              shift and go to state 27
    VAR             shift and go to state 29
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    INT             shift and go to state 35
    STRING          shift and go to state 36
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39

    class_content_repeat           shift and go to state 175
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    bool                           shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    returnType                     shift and go to state 28
    number                         shift and go to state 30

state 142

    (77) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 77 (conditions -> condition condition_connector conditions .)


state 143

    (80) condition_connector -> AMPERSAND AMPERSAND .

    IDENTIFIER      reduce using rule 80 (condition_connector -> AMPERSAND AMPERSAND .)
    EXMARK          reduce using rule 80 (condition_connector -> AMPERSAND AMPERSAND .)
    BOOLEAN         reduce using rule 80 (condition_connector -> AMPERSAND AMPERSAND .)
    STR             reduce using rule 80 (condition_connector -> AMPERSAND AMPERSAND .)
    FLOAT           reduce using rule 80 (condition_connector -> AMPERSAND AMPERSAND .)
    INTEGER         reduce using rule 80 (condition_connector -> AMPERSAND AMPERSAND .)


state 144

    (81) condition_connector -> PIPELINE PIPELINE .

    IDENTIFIER      reduce using rule 81 (condition_connector -> PIPELINE PIPELINE .)
    EXMARK          reduce using rule 81 (condition_connector -> PIPELINE PIPELINE .)
    BOOLEAN         reduce using rule 81 (condition_connector -> PIPELINE PIPELINE .)
    STR             reduce using rule 81 (condition_connector -> PIPELINE PIPELINE .)
    FLOAT           reduce using rule 81 (condition_connector -> PIPELINE PIPELINE .)
    INTEGER         reduce using rule 81 (condition_connector -> PIPELINE PIPELINE .)


state 145

    (56) deniable_values -> IDENTIFIER .

    AND             reduce using rule 56 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 56 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 56 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 56 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 56 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 56 (deniable_values -> IDENTIFIER .)


state 146

    (71) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 71 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 71 (condition -> IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 71 (condition -> IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 71 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 71 (condition -> IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 71 (condition -> IDENTIFIER condition_operator condition_values .)


state 147

    (60) condition_values -> negation_values .

    AND             reduce using rule 60 (condition_values -> negation_values .)
    OR              reduce using rule 60 (condition_values -> negation_values .)
    AMPERSAND       reduce using rule 60 (condition_values -> negation_values .)
    PIPELINE        reduce using rule 60 (condition_values -> negation_values .)
    RPAREN          reduce using rule 60 (condition_values -> negation_values .)
    SEMICOLON       reduce using rule 60 (condition_values -> negation_values .)


state 148

    (61) condition_values -> INTEGER .

    AND             reduce using rule 61 (condition_values -> INTEGER .)
    OR              reduce using rule 61 (condition_values -> INTEGER .)
    AMPERSAND       reduce using rule 61 (condition_values -> INTEGER .)
    PIPELINE        reduce using rule 61 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 61 (condition_values -> INTEGER .)
    SEMICOLON       reduce using rule 61 (condition_values -> INTEGER .)


state 149

    (62) condition_values -> FLOAT .

    AND             reduce using rule 62 (condition_values -> FLOAT .)
    OR              reduce using rule 62 (condition_values -> FLOAT .)
    AMPERSAND       reduce using rule 62 (condition_values -> FLOAT .)
    PIPELINE        reduce using rule 62 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 62 (condition_values -> FLOAT .)
    SEMICOLON       reduce using rule 62 (condition_values -> FLOAT .)


state 150

    (63) condition_values -> STR .

    AND             reduce using rule 63 (condition_values -> STR .)
    OR              reduce using rule 63 (condition_values -> STR .)
    AMPERSAND       reduce using rule 63 (condition_values -> STR .)
    PIPELINE        reduce using rule 63 (condition_values -> STR .)
    RPAREN          reduce using rule 63 (condition_values -> STR .)
    SEMICOLON       reduce using rule 63 (condition_values -> STR .)


state 151

    (58) negation_values -> deniable_values .

    AND             reduce using rule 58 (negation_values -> deniable_values .)
    OR              reduce using rule 58 (negation_values -> deniable_values .)
    AMPERSAND       reduce using rule 58 (negation_values -> deniable_values .)
    PIPELINE        reduce using rule 58 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 58 (negation_values -> deniable_values .)
    SEMICOLON       reduce using rule 58 (negation_values -> deniable_values .)


state 152

    (59) negation_values -> EXMARK . deniable_values
    (56) deniable_values -> . IDENTIFIER
    (57) deniable_values -> . BOOLEAN

    IDENTIFIER      shift and go to state 145
    BOOLEAN         shift and go to state 153

    deniable_values                shift and go to state 176

state 153

    (57) deniable_values -> BOOLEAN .

    AND             reduce using rule 57 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 57 (deniable_values -> BOOLEAN .)
    AMPERSAND       reduce using rule 57 (deniable_values -> BOOLEAN .)
    PIPELINE        reduce using rule 57 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 57 (deniable_values -> BOOLEAN .)
    SEMICOLON       reduce using rule 57 (deniable_values -> BOOLEAN .)


state 154

    (67) condition_operator -> LESSTHAN EQUAL .

    INTEGER         reduce using rule 67 (condition_operator -> LESSTHAN EQUAL .)
    FLOAT           reduce using rule 67 (condition_operator -> LESSTHAN EQUAL .)
    STR             reduce using rule 67 (condition_operator -> LESSTHAN EQUAL .)
    EXMARK          reduce using rule 67 (condition_operator -> LESSTHAN EQUAL .)
    IDENTIFIER      reduce using rule 67 (condition_operator -> LESSTHAN EQUAL .)
    BOOLEAN         reduce using rule 67 (condition_operator -> LESSTHAN EQUAL .)


state 155

    (68) condition_operator -> GREATERTHAN EQUAL .

    INTEGER         reduce using rule 68 (condition_operator -> GREATERTHAN EQUAL .)
    FLOAT           reduce using rule 68 (condition_operator -> GREATERTHAN EQUAL .)
    STR             reduce using rule 68 (condition_operator -> GREATERTHAN EQUAL .)
    EXMARK          reduce using rule 68 (condition_operator -> GREATERTHAN EQUAL .)
    IDENTIFIER      reduce using rule 68 (condition_operator -> GREATERTHAN EQUAL .)
    BOOLEAN         reduce using rule 68 (condition_operator -> GREATERTHAN EQUAL .)


state 156

    (72) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (60) condition_values -> . negation_values
    (61) condition_values -> . INTEGER
    (62) condition_values -> . FLOAT
    (63) condition_values -> . STR
    (58) negation_values -> . deniable_values
    (59) negation_values -> . EXMARK deniable_values
    (56) deniable_values -> . IDENTIFIER
    (57) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    STR             shift and go to state 150
    EXMARK          shift and go to state 152
    IDENTIFIER      shift and go to state 145
    BOOLEAN         shift and go to state 153

    condition_values               shift and go to state 177
    negation_values                shift and go to state 147
    deniable_values                shift and go to state 151

state 157

    (73) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 73 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 73 (condition -> BOOLEAN condition_operator BOOLEAN .)
    AMPERSAND       reduce using rule 73 (condition -> BOOLEAN condition_operator BOOLEAN .)
    PIPELINE        reduce using rule 73 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 73 (condition -> BOOLEAN condition_operator BOOLEAN .)
    SEMICOLON       reduce using rule 73 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 158

    (74) condition -> number condition_operator number .

    AND             reduce using rule 74 (condition -> number condition_operator number .)
    OR              reduce using rule 74 (condition -> number condition_operator number .)
    AMPERSAND       reduce using rule 74 (condition -> number condition_operator number .)
    PIPELINE        reduce using rule 74 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 74 (condition -> number condition_operator number .)
    SEMICOLON       reduce using rule 74 (condition -> number condition_operator number .)


state 159

    (75) condition -> STR condition_operator STR .

    AND             reduce using rule 75 (condition -> STR condition_operator STR .)
    OR              reduce using rule 75 (condition -> STR condition_operator STR .)
    AMPERSAND       reduce using rule 75 (condition -> STR condition_operator STR .)
    PIPELINE        reduce using rule 75 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 75 (condition -> STR condition_operator STR .)
    SEMICOLON       reduce using rule 75 (condition -> STR condition_operator STR .)


state 160

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    datatype                       shift and go to state 178
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 161

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT . OF LPAREN IDENTIFIER RPAREN SEMICOLON

    OF              shift and go to state 179


state 162

    (105) bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .

    FOR             reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    WHILE           reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    FINAL           reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    IDENTIFIER      reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    BOOL            reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    LIST            reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    MAP             reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    IF              reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    VAR             reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    INTEGER         reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    FLOAT           reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    STR             reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    BOOLEAN         reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    INT             reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    STRING          reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    DOUBLE          reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    DYNAMIC         reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    VOID            reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    $end            reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)
    RCURLYBRACKET   reduce using rule 105 (bool -> BOOL IDENTIFIER EQUAL boolvalue SEMICOLON .)


state 163

    (112) semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 180


state 164

    (18) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 181


state 165

    (40) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (11) class_content_repeat -> . class_content
    (12) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . bool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (82) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (105) bool -> . BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
    (112) semanticlist -> . LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    FOR             shift and go to state 19
    WHILE           shift and go to state 20
    FINAL           shift and go to state 21
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 24
    LIST            shift and go to state 25
    MAP             shift and go to state 26
    IF              shift and go to state 27
    VAR             shift and go to state 29
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    INT             shift and go to state 35
    STRING          shift and go to state 36
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39

    class_content_repeat           shift and go to state 182
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    bool                           shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    returnType                     shift and go to state 28
    number                         shift and go to state 30

state 166

    (15) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 183


state 167

    (33) map_pairs -> map_pair COMMA . map_pairs
    (32) map_pairs -> . map_pair
    (33) map_pairs -> . map_pair COMMA map_pairs
    (31) map_pair -> . map_key COLON map_value
    (34) map_key -> . value
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER

    INTEGER         shift and go to state 131
    FLOAT           shift and go to state 132
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    IDENTIFIER      shift and go to state 124

    map_pair                       shift and go to state 128
    map_pairs                      shift and go to state 184
    map_key                        shift and go to state 129
    value                          shift and go to state 130

state 168

    (31) map_pair -> map_key COLON . map_value
    (35) map_value -> . value
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER

    INTEGER         shift and go to state 131
    FLOAT           shift and go to state 132
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    IDENTIFIER      shift and go to state 124

    map_value                      shift and go to state 185
    value                          shift and go to state 186

state 169

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN . expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34

    expression                     shift and go to state 187
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    number                         shift and go to state 30

state 170

    (82) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 188


state 171

    (87) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 189


state 172

    (90) optFunction_arguments -> optFunction_argument .
    (91) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 90 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 190


state 173

    (89) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 29
    INT             shift and go to state 35
    STRING          shift and go to state 36
    BOOL            shift and go to state 66
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39
    MAP             shift and go to state 26

    datatype                       shift and go to state 191
    returnType                     shift and go to state 28
    map_identifier                 shift and go to state 67

state 174

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON . expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34

    expression                     shift and go to state 192
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    number                         shift and go to state 30

state 175

    (45) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (12) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . bool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (82) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (105) bool -> . BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
    (112) semanticlist -> . LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    RCURLYBRACKET   shift and go to state 193
    FOR             shift and go to state 19
    WHILE           shift and go to state 20
    FINAL           shift and go to state 21
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 24
    LIST            shift and go to state 25
    MAP             shift and go to state 26
    IF              shift and go to state 27
    VAR             shift and go to state 29
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    INT             shift and go to state 35
    STRING          shift and go to state 36
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39

    class_content                  shift and go to state 40
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    bool                           shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    returnType                     shift and go to state 28
    number                         shift and go to state 30

state 176

    (59) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 59 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 59 (negation_values -> EXMARK deniable_values .)
    AMPERSAND       reduce using rule 59 (negation_values -> EXMARK deniable_values .)
    PIPELINE        reduce using rule 59 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 59 (negation_values -> EXMARK deniable_values .)
    SEMICOLON       reduce using rule 59 (negation_values -> EXMARK deniable_values .)


state 177

    (72) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 72 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 72 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 72 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 72 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 72 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 72 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 178

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN RPAREN SEMICOLON

    GREATERTHAN     shift and go to state 194


state 179

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF . LPAREN IDENTIFIER RPAREN SEMICOLON

    LPAREN          shift and go to state 195


state 180

    (112) semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 196


state 181

    (18) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 18 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 18 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 18 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 182

    (40) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (12) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . bool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (82) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (101) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (102) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (105) bool -> . BOOL IDENTIFIER EQUAL boolvalue SEMICOLON
    (112) semanticlist -> . LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    RCURLYBRACKET   shift and go to state 197
    FOR             shift and go to state 19
    WHILE           shift and go to state 20
    FINAL           shift and go to state 21
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 24
    LIST            shift and go to state 25
    MAP             shift and go to state 26
    IF              shift and go to state 27
    VAR             shift and go to state 29
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    INT             shift and go to state 35
    STRING          shift and go to state 36
    DOUBLE          shift and go to state 37
    DYNAMIC         shift and go to state 38
    VOID            shift and go to state 39

    class_content                  shift and go to state 40
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    bool                           shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    returnType                     shift and go to state 28
    number                         shift and go to state 30

state 183

    (15) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    FOR             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    WHILE           reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FINAL           reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOL            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    LIST            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAP             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IF              reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VAR             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INTEGER         reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FLOAT           reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STR             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INT             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STRING          reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VOID            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    $end            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 184

    (33) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 33 (map_pairs -> map_pair COMMA map_pairs .)


state 185

    (31) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 31 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 31 (map_pair -> map_key COLON map_value .)


state 186

    (35) map_value -> value .

    COMMA           reduce using rule 35 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 35 (map_value -> value .)


state 187

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression . SEMICOLON RCURLYBRACKET

    SEMICOLON       shift and go to state 198


state 188

    (82) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 199


state 189

    (87) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 87 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 190

    (91) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (90) optFunction_arguments -> . optFunction_argument
    (91) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (89) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 173

    optFunction_argument           shift and go to state 172
    optFunction_arguments          shift and go to state 200

state 191

    (89) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 201


state 192

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression . RPAREN LCURLYBRACKET RCURLYBRACKET

    RPAREN          shift and go to state 202


state 193

    (45) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    FOR             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 194

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 203


state 195

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN . IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 204


state 196

    (112) semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelist RSQUAREBRACKET SEMICOLON
    (113) insidelist -> . value
    (114) insidelist -> . value COMMA value
    (115) insidelist -> . value COMMA insidelist
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER

    INTEGER         shift and go to state 131
    FLOAT           shift and go to state 132
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    IDENTIFIER      shift and go to state 124

    insidelist                     shift and go to state 205
    value                          shift and go to state 206

state 197

    (40) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 198

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 207


state 199

    (82) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (92) expression -> . operableTypes operatorExpression operableTypes
    (93) expression -> . value
    (94) expression -> . operableTypes operatorExpression operatorExpression
    (95) operableTypes -> . IDENTIFIER
    (96) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (69) number -> . FLOAT
    (70) number -> . INTEGER

    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 31
    FLOAT           shift and go to state 32
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34

    expression                     shift and go to state 208
    operableTypes                  shift and go to state 22
    value                          shift and go to state 23
    number                         shift and go to state 30

state 200

    (91) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 91 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 201

    (89) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 89 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 89 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 202

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN . LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 209


state 203

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . RPAREN SEMICOLON
    (54) opt_value -> . value
    (55) opt_value -> . empty
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (28) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 211
    INTEGER         shift and go to state 131
    FLOAT           shift and go to state 132
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    IDENTIFIER      shift and go to state 124

  ! RPAREN          [ reduce using rule 28 (empty -> .) ]

    opt_value                      shift and go to state 210
    value                          shift and go to state 212
    empty                          shift and go to state 213

state 204

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER . RPAREN SEMICOLON

    RPAREN          shift and go to state 214


state 205

    (112) semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 215


state 206

    (113) insidelist -> value .
    (114) insidelist -> value . COMMA value
    (115) insidelist -> value . COMMA insidelist

    RSQUAREBRACKET  reduce using rule 113 (insidelist -> value .)
    COMMA           shift and go to state 216


state 207

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .

    FOR             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    WHILE           reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FINAL           reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOL            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    LIST            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAP             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IF              reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VAR             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INTEGER         reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FLOAT           reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STR             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOLEAN         reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INT             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STRING          reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DOUBLE          reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DYNAMIC         reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VOID            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    $end            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)


state 208

    (82) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 217


state 209

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 218


state 210

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value . RPAREN SEMICOLON

    RPAREN          shift and go to state 219


state 211

    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 220


state 212

    (54) opt_value -> value .

    RPAREN          reduce using rule 54 (opt_value -> value .)


state 213

    (55) opt_value -> empty .

    RPAREN          reduce using rule 55 (opt_value -> empty .)


state 214

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 221


state 215

    (112) semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 222


state 216

    (114) insidelist -> value COMMA . value
    (115) insidelist -> value COMMA . insidelist
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (113) insidelist -> . value
    (114) insidelist -> . value COMMA value
    (115) insidelist -> . value COMMA insidelist

    INTEGER         shift and go to state 131
    FLOAT           shift and go to state 132
    STR             shift and go to state 33
    BOOLEAN         shift and go to state 34
    IDENTIFIER      shift and go to state 124

    value                          shift and go to state 223
    insidelist                     shift and go to state 224

state 217

    (82) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    FOR             reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    WHILE           reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FINAL           reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOL            reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    LIST            reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAP             reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IF              reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VAR             reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INTEGER         reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FLOAT           reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STR             reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOLEAN         reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INT             reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STRING          reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DOUBLE          reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DYNAMIC         reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VOID            reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    $end            reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 82 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)


state 218

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .

    FOR             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    WHILE           reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FINAL           reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    LIST            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IF              reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VAR             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INTEGER         reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FLOAT           reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STR             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOLEAN         reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STRING          reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    $end            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)


state 219

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 225


state 220

    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .

    FOR             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STR             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)


state 221

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .

    FOR             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    WHILE           reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FINAL           reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOL            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    LIST            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAP             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IF              reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VAR             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INTEGER         reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STR             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INT             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STRING          reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VOID            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    $end            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)


state 222

    (112) semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .

    FOR             reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 112 (semanticlist -> LIST LESSTHAN datatype GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)


state 223

    (114) insidelist -> value COMMA value .
    (113) insidelist -> value .
    (114) insidelist -> value . COMMA value
    (115) insidelist -> value . COMMA insidelist

  ! reduce/reduce conflict for RSQUAREBRACKET resolved using rule 113 (insidelist -> value .)
    RSQUAREBRACKET  reduce using rule 113 (insidelist -> value .)
    COMMA           shift and go to state 216

  ! RSQUAREBRACKET  [ reduce using rule 114 (insidelist -> value COMMA value .) ]


state 224

    (115) insidelist -> value COMMA insidelist .

    RSQUAREBRACKET  reduce using rule 115 (insidelist -> value COMMA insidelist .)


state 225

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .

    FOR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    WHILE           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FINAL           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOL            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    LIST            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAP             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IF              reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VAR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INT             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STRING          reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VOID            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    $end            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 15 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 24 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 203 resolved as shift
WARNING: reduce/reduce conflict in state 223 resolved using rule (insidelist -> value)
WARNING: rejected rule (insidelist -> value COMMA value) in state 223
WARNING: Rule (insidelist -> value COMMA value) is never reduced
