Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    APOSTROPHE
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CLOSE
    COMMENT
    COMMENTMULTI
    CONST
    DEFAULT
    DEFERRED
    DO
    DOLLAR
    DOUBQUOTMARK
    ENUM
    EXIT
    EXPORT
    EXTENSION
    EXTERNAL
    FACTORY
    FILE
    FUNCTION
    GET
    IMPLEMENTS
    IMPORT
    IN
    IS
    ITERABLE
    LIBRARY
    METHOD
    NOTEQUAL
    OPENWRITE
    READLINESYNC
    SET
    TRY
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> class_content_repeat
Rule 2     class -> declarationMain class_content_repeat
Rule 3     class -> class_content_repeat declarationMain
Rule 4     class -> class_content_repeat declarationMain class_content_repeat
Rule 5     class -> declarationMain
Rule 6     class_content -> map
Rule 7     class_content -> ifElseStatement
Rule 8     class_content -> function_lambda
Rule 9     class_content -> declarationExpression
Rule 10    class_content -> forStatement
Rule 11    class_content -> while
Rule 12    class_content -> stack
Rule 13    class_content -> inferedReturnFunction
Rule 14    class_content -> expression SEMICOLON
Rule 15    class_content -> print
Rule 16    class_content -> CONTINUE SEMICOLON
Rule 17    class_content_repeat -> class_content
Rule 18    class_content_repeat -> class_content_repeat class_content
Rule 19    declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 20    datatypeOpt -> datatype
Rule 21    datatypeOpt -> empty
Rule 22    class_content -> semanticbool
Rule 23    class_content -> semanticlist
Rule 24    class_content -> asign
Rule 25    class_content -> addlistInt
Rule 26    class_content -> addlistBool
Rule 27    class_content -> addlistFloat
Rule 28    class_content -> addlistStr
Rule 29    class_content -> assert
Rule 30    map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 31    map_identifier -> MAP
Rule 32    map_identifier -> MAP map_type_specified
Rule 33    map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 34    datatype -> INT
Rule 35    datatype -> STRING
Rule 36    datatype -> BOOL
Rule 37    datatype -> DOUBLE
Rule 38    datatype -> DYNAMIC
Rule 39    datatype -> VOID
Rule 40    datatype -> map_identifier
Rule 41    datatype -> VAR
Rule 42    returnType -> INT
Rule 43    returnType -> STRING
Rule 44    returnType -> BOOL
Rule 45    returnType -> DOUBLE
Rule 46    returnType -> DYNAMIC
Rule 47    returnType -> VOID
Rule 48    returnType -> map_identifier
Rule 49    print -> PRINT LPAREN value RPAREN SEMICOLON
Rule 50    empty -> <empty>
Rule 51    map_content -> map_pairs
Rule 52    map_content -> empty
Rule 53    map_pair -> map_key COLON map_value
Rule 54    map_pairs -> map_pair
Rule 55    map_pairs -> map_pair COMMA map_pairs
Rule 56    map_key -> value
Rule 57    map_value -> value
Rule 58    ifElseStatement -> ifStatement
Rule 59    ifElseStatement -> ifStatement elifStatement_repeat
Rule 60    elifStatement_repeat -> elifStatement
Rule 61    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 62    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 63    elifStatement -> ELSE ifStatement
Rule 64    elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 65    forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 66    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
Rule 67    while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 68    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
Rule 69    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 70    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
Rule 71    value -> INTEGER
Rule 72    value -> FLOAT
Rule 73    value -> STR
Rule 74    value -> BOOLEAN
Rule 75    value -> IDENTIFIER
Rule 76    value -> booleanOp
Rule 77    value -> propertiesAccess
Rule 78    opt_value -> value
Rule 79    opt_value -> empty
Rule 80    deniable_values -> IDENTIFIER
Rule 81    deniable_values -> BOOLEAN
Rule 82    deniable_values -> booleanOp
Rule 83    negation_values -> deniable_values
Rule 84    negation_values -> EXMARK deniable_values
Rule 85    condition_values -> negation_values
Rule 86    condition_values -> INTEGER
Rule 87    condition_values -> FLOAT
Rule 88    condition_values -> STR
Rule 89    condition_values -> NULL
Rule 90    condition_operator -> DOUBLEQUAL
Rule 91    condition_operator -> LESSTHAN
Rule 92    condition_operator -> GREATERTHAN
Rule 93    condition_operator -> LESSTHAN EQUAL
Rule 94    condition_operator -> GREATERTHAN EQUAL
Rule 95    condition_operator -> EXMARK EQUAL
Rule 96    number -> FLOAT
Rule 97    number -> INTEGER
Rule 98    condition -> IDENTIFIER condition_operator condition_values
Rule 99    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 100   condition -> BOOLEAN condition_operator BOOLEAN
Rule 101   condition -> number condition_operator number
Rule 102   condition -> STR condition_operator STR
Rule 103   condition -> booleanOp condition_operator booleanOp
Rule 104   condition -> negation_values
Rule 105   conditions -> condition
Rule 106   conditions -> condition condition_connector conditions
Rule 107   condition_connector -> AND
Rule 108   condition_connector -> OR
Rule 109   condition_connector -> AMPERSAND AMPERSAND
Rule 110   condition_connector -> PIPELINE PIPELINE
Rule 111   function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 112   function_argument -> datatype IDENTIFIER
Rule 113   function_argument -> empty
Rule 114   function_arguments_repeat -> function_argument
Rule 115   function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 116   optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 117   optFunction_argumentsExpression -> empty
Rule 118   optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 119   optFunction_arguments -> optFunction_argument
Rule 120   optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 121   expression -> value
Rule 122   expression -> value operatorExpression expression
Rule 123   expression -> value operatorExpression operatorExpression
Rule 124   expression -> booloperations
Rule 125   asign -> IDENTIFIER EQUAL expression SEMICOLON
Rule 126   asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON
Rule 127   assert -> ASSERT LPAREN conditions RPAREN SEMICOLON
Rule 128   operableTypes -> IDENTIFIER
Rule 129   operableTypes -> number
Rule 130   operatorExpression -> PLUS
Rule 131   operatorExpression -> MINUS
Rule 132   operatorExpression -> TIMES
Rule 133   operatorExpression -> DIVISION
Rule 134   operatorExpression -> REST
Rule 135   declarationExpression -> datatype repeatDeclaration SEMICOLON
Rule 136   repeatDeclaration -> IDENTIFIER
Rule 137   repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration
Rule 138   declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON
Rule 139   declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
Rule 140   declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON
Rule 141   semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON
Rule 142   booleanOp -> TRUE
Rule 143   booleanOp -> FALSE
Rule 144   booloperation -> booleanOp condition_connector booleanOp
Rule 145   booloperation -> IDENTIFIER condition_connector booleanOp
Rule 146   booloperation -> IDENTIFIER condition_connector IDENTIFIER
Rule 147   booloperation -> booleanOp condition_connector IDENTIFIER
Rule 148   booloperations -> booloperation
Rule 149   booloperations -> booloperation condition_connector booloperations
Rule 150   semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
Rule 151   semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
Rule 152   semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
Rule 153   semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
Rule 154   semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
Rule 155   insidelist -> value
Rule 156   insidelist -> value COMMA insidelist
Rule 157   insidelistint -> INTEGER
Rule 158   insidelistint -> INTEGER COMMA insidelistint
Rule 159   insideliststr -> STR
Rule 160   insideliststr -> STR COMMA insideliststr
Rule 161   insidelistbool -> booleanOp
Rule 162   insidelistbool -> booleanOp COMMA insidelistbool
Rule 163   insidelistdouble -> FLOAT
Rule 164   insidelistdouble -> FLOAT COMMA insidelistdouble
Rule 165   addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
Rule 166   addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
Rule 167   addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
Rule 168   addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
Rule 169   declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON
Rule 170   declarationExpression -> STRING IDENTIFIER SEMICOLON
Rule 171   expressionString -> STR
Rule 172   expressionString -> STR operatorExpressionString expressionString
Rule 173   operatorExpressionString -> PLUS
Rule 174   declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON
Rule 175   declarationExpression -> INT IDENTIFIER SEMICOLON
Rule 176   expressionInteger -> number
Rule 177   expressionInteger -> number operatorExpression expressionInteger
Rule 178   expressionInteger -> IDENTIFIER
Rule 179   expressionInteger -> IDENTIFIER operatorExpression expressionInteger
Rule 180   properties -> KEYS
Rule 181   properties -> VALUES
Rule 182   propertiesAccess -> IDENTIFIER DOT properties

Terminals, with rules where they appear

ABSTRACT             : 
ADD                  : 165 166 167 168
AMPERSAND            : 109 109
AND                  : 107
APOSTROPHE           : 
ASSERT               : 127
ASYNC                : 
AWAIT                : 
BOOL                 : 36 44 141 153
BOOLEAN              : 74 81 100 100
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
CLOSE                : 
COLON                : 53
COMMA                : 33 55 115 120 137 156 158 160 162 164
COMMENT              : 
COMMENTMULTI         : 
CONST                : 
CONTINUE             : 16
DEFAULT              : 
DEFERRED             : 
DIVISION             : 133
DO                   : 
DOLLAR               : 
DOT                  : 69 165 166 167 168 182
DOUBLE               : 37 45 154
DOUBLEQUAL           : 90
DOUBQUOTMARK         : 
DYNAMIC              : 38 46 150
ELSE                 : 63 64
ENUM                 : 
EQUAL                : 30 66 68 69 93 94 95 111 125 126 138 139 140 141 150 151 152 153 154 169 174
EXIT                 : 
EXMARK               : 84 95 99
EXPORT               : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 143
FILE                 : 
FINAL                : 66 68 69 140
FLOAT                : 72 87 96 163 164 168
FOR                  : 65
FUNCTION             : 
GET                  : 
GREATERTHAN          : 33 66 68 92 94 111 150 151 152 153 154
IDENTIFIER           : 30 66 68 69 69 70 75 80 98 99 111 112 118 125 126 128 136 137 138 139 139 140 141 145 146 146 147 150 151 152 153 154 165 166 167 168 169 170 174 175 178 179 182
IF                   : 62
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INT                  : 34 42 151 174 175
INTEGER              : 71 86 97 157 158 165
IS                   : 
ITERABLE             : 
KEYS                 : 180
LCURLYBRACKET        : 19 30 62 64 65 67 70 116
LESSTHAN             : 33 66 68 91 93 150 151 152 153 154
LIBRARY              : 
LIST                 : 150 151 152 153 154
LPAREN               : 19 49 62 65 66 67 68 69 70 111 127 139 165 166 167 168
LSQUAREBRACKET       : 150 151 152 153 154
MAIN                 : 19
MAP                  : 31 32
METHOD               : 
MINUS                : 131
NOTEQUAL             : 
NULL                 : 89
OF                   : 69
OPENWRITE            : 
OR                   : 108
PIPELINE             : 110 110
PLUS                 : 130 173
PRINT                : 49
RCURLYBRACKET        : 19 30 62 64 65 67 70 116
READLINESYNC         : 
REQUIRED             : 118
REST                 : 134
RETURN               : 70
RPAREN               : 19 49 62 65 66 67 68 69 70 111 127 139 165 166 167 168
RSQUAREBRACKET       : 150 151 152 153 154
SEMICOLON            : 14 16 30 49 65 65 66 68 69 70 111 125 126 127 135 138 139 140 141 150 151 152 153 154 165 166 167 168 169 170 174 175
SET                  : 
STACK                : 66 68 69
STR                  : 73 88 102 102 159 160 166 171 172
STRING               : 35 43 152 169 170
TIMES                : 132
TRUE                 : 142
TRY                  : 
VALUES               : 181
VAR                  : 41
VOID                 : 39 47
WHILE                : 67
WRITE                : 
error                : 

Nonterminals, with rules where they appear

addlistBool          : 26
addlistFloat         : 27
addlistInt           : 25
addlistStr           : 28
asign                : 24
assert               : 29
booleanOp            : 76 82 103 103 144 144 145 147 161 162 167
booloperation        : 148 149
booloperations       : 124 149
class                : 0
class_content        : 17 18
class_content_repeat : 1 2 3 4 4 18 19 62 64 67
condition            : 65 105 106
condition_connector  : 106 144 145 146 147 149
condition_operator   : 98 99 100 101 102 103
condition_values     : 98 99
conditions           : 62 67 106 127 141
datatype             : 20 33 33 66 68 111 112 118 135 138 139 139
datatypeOpt          : 19
declarationExpression : 9 65
declarationMain      : 2 3 4 5
deniable_values      : 83 84
elifStatement        : 60 61
elifStatement_repeat : 59 61
empty                : 21 52 79 113 117
expression           : 14 65 70 111 122 125 126 138 140
expressionInteger    : 174 177 179
expressionString     : 169 172
forStatement         : 10
function_argument    : 114 115
function_arguments_repeat : 70 111 115
function_lambda      : 8
ifElseStatement      : 7
ifStatement          : 58 59 63
inferedReturnFunction : 13
insidelist           : 150 156
insidelistbool       : 153 162
insidelistdouble     : 154 164
insidelistint        : 151 158
insideliststr        : 152 160
map                  : 6
map_content          : 30
map_identifier       : 30 40 48
map_key              : 53
map_pair             : 54 55
map_pairs            : 51 55
map_type_specified   : 32
map_value            : 53
negation_values      : 85 104
number               : 101 101 129 176 177
operableTypes        : 
operatorExpression   : 122 123 123 126 177 179
operatorExpressionString : 172
optFunction_argument : 119 120
optFunction_arguments : 116 120
optFunction_argumentsExpression : 111
opt_value            : 66
print                : 15
properties           : 182
propertiesAccess     : 77
repeatDeclaration    : 135 137
returnType           : 
semanticbool         : 22
semanticlist         : 23
stack                : 12
value                : 49 56 57 78 121 122 123 155 156
while                : 11

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . class_content_repeat
    (2) class -> . declarationMain class_content_repeat
    (3) class -> . class_content_repeat declarationMain
    (4) class -> . class_content_repeat declarationMain class_content_repeat
    (5) class -> . declarationMain
    (17) class_content_repeat -> . class_content
    (18) class_content_repeat -> . class_content_repeat class_content
    (19) declarationMain -> . datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (20) datatypeOpt -> . datatype
    (21) datatypeOpt -> . empty
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (50) empty -> .
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    MAIN            reduce using rule 50 (empty -> .)
    MAP             shift and go to state 49
    IF              shift and go to state 50
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class                          shift and go to state 1
    class_content_repeat           shift and go to state 2
    declarationMain                shift and go to state 3
    class_content                  shift and go to state 4
    datatypeOpt                    shift and go to state 5
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    datatype                       shift and go to state 25
    empty                          shift and go to state 26
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 1

    (0) S' -> class .



state 2

    (1) class -> class_content_repeat .
    (3) class -> class_content_repeat . declarationMain
    (4) class -> class_content_repeat . declarationMain class_content_repeat
    (18) class_content_repeat -> class_content_repeat . class_content
    (19) declarationMain -> . datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (20) datatypeOpt -> . datatype
    (21) datatypeOpt -> . empty
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (50) empty -> .
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    $end            reduce using rule 1 (class -> class_content_repeat .)
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    MAIN            reduce using rule 50 (empty -> .)
    MAP             shift and go to state 49
    IF              shift and go to state 50
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    declarationMain                shift and go to state 56
    class_content                  shift and go to state 57
    datatypeOpt                    shift and go to state 5
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    datatype                       shift and go to state 25
    empty                          shift and go to state 26
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 3

    (2) class -> declarationMain . class_content_repeat
    (5) class -> declarationMain .
    (17) class_content_repeat -> . class_content
    (18) class_content_repeat -> . class_content_repeat class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    $end            reduce using rule 5 (class -> declarationMain .)
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content_repeat           shift and go to state 58
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 4

    (17) class_content_repeat -> class_content .

    CONTINUE        reduce using rule 17 (class_content_repeat -> class_content .)
    FINAL           reduce using rule 17 (class_content_repeat -> class_content .)
    STRING          reduce using rule 17 (class_content_repeat -> class_content .)
    INT             reduce using rule 17 (class_content_repeat -> class_content .)
    FOR             reduce using rule 17 (class_content_repeat -> class_content .)
    WHILE           reduce using rule 17 (class_content_repeat -> class_content .)
    IDENTIFIER      reduce using rule 17 (class_content_repeat -> class_content .)
    PRINT           reduce using rule 17 (class_content_repeat -> class_content .)
    BOOL            reduce using rule 17 (class_content_repeat -> class_content .)
    LIST            reduce using rule 17 (class_content_repeat -> class_content .)
    ASSERT          reduce using rule 17 (class_content_repeat -> class_content .)
    DOUBLE          reduce using rule 17 (class_content_repeat -> class_content .)
    DYNAMIC         reduce using rule 17 (class_content_repeat -> class_content .)
    VOID            reduce using rule 17 (class_content_repeat -> class_content .)
    VAR             reduce using rule 17 (class_content_repeat -> class_content .)
    MAP             reduce using rule 17 (class_content_repeat -> class_content .)
    IF              reduce using rule 17 (class_content_repeat -> class_content .)
    INTEGER         reduce using rule 17 (class_content_repeat -> class_content .)
    FLOAT           reduce using rule 17 (class_content_repeat -> class_content .)
    STR             reduce using rule 17 (class_content_repeat -> class_content .)
    BOOLEAN         reduce using rule 17 (class_content_repeat -> class_content .)
    TRUE            reduce using rule 17 (class_content_repeat -> class_content .)
    FALSE           reduce using rule 17 (class_content_repeat -> class_content .)
    MAIN            reduce using rule 17 (class_content_repeat -> class_content .)
    $end            reduce using rule 17 (class_content_repeat -> class_content .)
    RCURLYBRACKET   reduce using rule 17 (class_content_repeat -> class_content .)


state 5

    (19) declarationMain -> datatypeOpt . MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    MAIN            shift and go to state 60


state 6

    (6) class_content -> map .

    CONTINUE        reduce using rule 6 (class_content -> map .)
    FINAL           reduce using rule 6 (class_content -> map .)
    STRING          reduce using rule 6 (class_content -> map .)
    INT             reduce using rule 6 (class_content -> map .)
    FOR             reduce using rule 6 (class_content -> map .)
    WHILE           reduce using rule 6 (class_content -> map .)
    IDENTIFIER      reduce using rule 6 (class_content -> map .)
    PRINT           reduce using rule 6 (class_content -> map .)
    BOOL            reduce using rule 6 (class_content -> map .)
    LIST            reduce using rule 6 (class_content -> map .)
    ASSERT          reduce using rule 6 (class_content -> map .)
    DOUBLE          reduce using rule 6 (class_content -> map .)
    DYNAMIC         reduce using rule 6 (class_content -> map .)
    VOID            reduce using rule 6 (class_content -> map .)
    VAR             reduce using rule 6 (class_content -> map .)
    MAP             reduce using rule 6 (class_content -> map .)
    IF              reduce using rule 6 (class_content -> map .)
    INTEGER         reduce using rule 6 (class_content -> map .)
    FLOAT           reduce using rule 6 (class_content -> map .)
    STR             reduce using rule 6 (class_content -> map .)
    BOOLEAN         reduce using rule 6 (class_content -> map .)
    TRUE            reduce using rule 6 (class_content -> map .)
    FALSE           reduce using rule 6 (class_content -> map .)
    MAIN            reduce using rule 6 (class_content -> map .)
    $end            reduce using rule 6 (class_content -> map .)
    RCURLYBRACKET   reduce using rule 6 (class_content -> map .)


state 7

    (7) class_content -> ifElseStatement .

    CONTINUE        reduce using rule 7 (class_content -> ifElseStatement .)
    FINAL           reduce using rule 7 (class_content -> ifElseStatement .)
    STRING          reduce using rule 7 (class_content -> ifElseStatement .)
    INT             reduce using rule 7 (class_content -> ifElseStatement .)
    FOR             reduce using rule 7 (class_content -> ifElseStatement .)
    WHILE           reduce using rule 7 (class_content -> ifElseStatement .)
    IDENTIFIER      reduce using rule 7 (class_content -> ifElseStatement .)
    PRINT           reduce using rule 7 (class_content -> ifElseStatement .)
    BOOL            reduce using rule 7 (class_content -> ifElseStatement .)
    LIST            reduce using rule 7 (class_content -> ifElseStatement .)
    ASSERT          reduce using rule 7 (class_content -> ifElseStatement .)
    DOUBLE          reduce using rule 7 (class_content -> ifElseStatement .)
    DYNAMIC         reduce using rule 7 (class_content -> ifElseStatement .)
    VOID            reduce using rule 7 (class_content -> ifElseStatement .)
    VAR             reduce using rule 7 (class_content -> ifElseStatement .)
    MAP             reduce using rule 7 (class_content -> ifElseStatement .)
    IF              reduce using rule 7 (class_content -> ifElseStatement .)
    INTEGER         reduce using rule 7 (class_content -> ifElseStatement .)
    FLOAT           reduce using rule 7 (class_content -> ifElseStatement .)
    STR             reduce using rule 7 (class_content -> ifElseStatement .)
    BOOLEAN         reduce using rule 7 (class_content -> ifElseStatement .)
    TRUE            reduce using rule 7 (class_content -> ifElseStatement .)
    FALSE           reduce using rule 7 (class_content -> ifElseStatement .)
    MAIN            reduce using rule 7 (class_content -> ifElseStatement .)
    $end            reduce using rule 7 (class_content -> ifElseStatement .)
    RCURLYBRACKET   reduce using rule 7 (class_content -> ifElseStatement .)


state 8

    (8) class_content -> function_lambda .

    CONTINUE        reduce using rule 8 (class_content -> function_lambda .)
    FINAL           reduce using rule 8 (class_content -> function_lambda .)
    STRING          reduce using rule 8 (class_content -> function_lambda .)
    INT             reduce using rule 8 (class_content -> function_lambda .)
    FOR             reduce using rule 8 (class_content -> function_lambda .)
    WHILE           reduce using rule 8 (class_content -> function_lambda .)
    IDENTIFIER      reduce using rule 8 (class_content -> function_lambda .)
    PRINT           reduce using rule 8 (class_content -> function_lambda .)
    BOOL            reduce using rule 8 (class_content -> function_lambda .)
    LIST            reduce using rule 8 (class_content -> function_lambda .)
    ASSERT          reduce using rule 8 (class_content -> function_lambda .)
    DOUBLE          reduce using rule 8 (class_content -> function_lambda .)
    DYNAMIC         reduce using rule 8 (class_content -> function_lambda .)
    VOID            reduce using rule 8 (class_content -> function_lambda .)
    VAR             reduce using rule 8 (class_content -> function_lambda .)
    MAP             reduce using rule 8 (class_content -> function_lambda .)
    IF              reduce using rule 8 (class_content -> function_lambda .)
    INTEGER         reduce using rule 8 (class_content -> function_lambda .)
    FLOAT           reduce using rule 8 (class_content -> function_lambda .)
    STR             reduce using rule 8 (class_content -> function_lambda .)
    BOOLEAN         reduce using rule 8 (class_content -> function_lambda .)
    TRUE            reduce using rule 8 (class_content -> function_lambda .)
    FALSE           reduce using rule 8 (class_content -> function_lambda .)
    MAIN            reduce using rule 8 (class_content -> function_lambda .)
    $end            reduce using rule 8 (class_content -> function_lambda .)
    RCURLYBRACKET   reduce using rule 8 (class_content -> function_lambda .)


state 9

    (9) class_content -> declarationExpression .

    CONTINUE        reduce using rule 9 (class_content -> declarationExpression .)
    FINAL           reduce using rule 9 (class_content -> declarationExpression .)
    STRING          reduce using rule 9 (class_content -> declarationExpression .)
    INT             reduce using rule 9 (class_content -> declarationExpression .)
    FOR             reduce using rule 9 (class_content -> declarationExpression .)
    WHILE           reduce using rule 9 (class_content -> declarationExpression .)
    IDENTIFIER      reduce using rule 9 (class_content -> declarationExpression .)
    PRINT           reduce using rule 9 (class_content -> declarationExpression .)
    BOOL            reduce using rule 9 (class_content -> declarationExpression .)
    LIST            reduce using rule 9 (class_content -> declarationExpression .)
    ASSERT          reduce using rule 9 (class_content -> declarationExpression .)
    DOUBLE          reduce using rule 9 (class_content -> declarationExpression .)
    DYNAMIC         reduce using rule 9 (class_content -> declarationExpression .)
    VOID            reduce using rule 9 (class_content -> declarationExpression .)
    VAR             reduce using rule 9 (class_content -> declarationExpression .)
    MAP             reduce using rule 9 (class_content -> declarationExpression .)
    IF              reduce using rule 9 (class_content -> declarationExpression .)
    INTEGER         reduce using rule 9 (class_content -> declarationExpression .)
    FLOAT           reduce using rule 9 (class_content -> declarationExpression .)
    STR             reduce using rule 9 (class_content -> declarationExpression .)
    BOOLEAN         reduce using rule 9 (class_content -> declarationExpression .)
    TRUE            reduce using rule 9 (class_content -> declarationExpression .)
    FALSE           reduce using rule 9 (class_content -> declarationExpression .)
    MAIN            reduce using rule 9 (class_content -> declarationExpression .)
    $end            reduce using rule 9 (class_content -> declarationExpression .)
    RCURLYBRACKET   reduce using rule 9 (class_content -> declarationExpression .)


state 10

    (10) class_content -> forStatement .

    CONTINUE        reduce using rule 10 (class_content -> forStatement .)
    FINAL           reduce using rule 10 (class_content -> forStatement .)
    STRING          reduce using rule 10 (class_content -> forStatement .)
    INT             reduce using rule 10 (class_content -> forStatement .)
    FOR             reduce using rule 10 (class_content -> forStatement .)
    WHILE           reduce using rule 10 (class_content -> forStatement .)
    IDENTIFIER      reduce using rule 10 (class_content -> forStatement .)
    PRINT           reduce using rule 10 (class_content -> forStatement .)
    BOOL            reduce using rule 10 (class_content -> forStatement .)
    LIST            reduce using rule 10 (class_content -> forStatement .)
    ASSERT          reduce using rule 10 (class_content -> forStatement .)
    DOUBLE          reduce using rule 10 (class_content -> forStatement .)
    DYNAMIC         reduce using rule 10 (class_content -> forStatement .)
    VOID            reduce using rule 10 (class_content -> forStatement .)
    VAR             reduce using rule 10 (class_content -> forStatement .)
    MAP             reduce using rule 10 (class_content -> forStatement .)
    IF              reduce using rule 10 (class_content -> forStatement .)
    INTEGER         reduce using rule 10 (class_content -> forStatement .)
    FLOAT           reduce using rule 10 (class_content -> forStatement .)
    STR             reduce using rule 10 (class_content -> forStatement .)
    BOOLEAN         reduce using rule 10 (class_content -> forStatement .)
    TRUE            reduce using rule 10 (class_content -> forStatement .)
    FALSE           reduce using rule 10 (class_content -> forStatement .)
    MAIN            reduce using rule 10 (class_content -> forStatement .)
    $end            reduce using rule 10 (class_content -> forStatement .)
    RCURLYBRACKET   reduce using rule 10 (class_content -> forStatement .)


state 11

    (11) class_content -> while .

    CONTINUE        reduce using rule 11 (class_content -> while .)
    FINAL           reduce using rule 11 (class_content -> while .)
    STRING          reduce using rule 11 (class_content -> while .)
    INT             reduce using rule 11 (class_content -> while .)
    FOR             reduce using rule 11 (class_content -> while .)
    WHILE           reduce using rule 11 (class_content -> while .)
    IDENTIFIER      reduce using rule 11 (class_content -> while .)
    PRINT           reduce using rule 11 (class_content -> while .)
    BOOL            reduce using rule 11 (class_content -> while .)
    LIST            reduce using rule 11 (class_content -> while .)
    ASSERT          reduce using rule 11 (class_content -> while .)
    DOUBLE          reduce using rule 11 (class_content -> while .)
    DYNAMIC         reduce using rule 11 (class_content -> while .)
    VOID            reduce using rule 11 (class_content -> while .)
    VAR             reduce using rule 11 (class_content -> while .)
    MAP             reduce using rule 11 (class_content -> while .)
    IF              reduce using rule 11 (class_content -> while .)
    INTEGER         reduce using rule 11 (class_content -> while .)
    FLOAT           reduce using rule 11 (class_content -> while .)
    STR             reduce using rule 11 (class_content -> while .)
    BOOLEAN         reduce using rule 11 (class_content -> while .)
    TRUE            reduce using rule 11 (class_content -> while .)
    FALSE           reduce using rule 11 (class_content -> while .)
    MAIN            reduce using rule 11 (class_content -> while .)
    $end            reduce using rule 11 (class_content -> while .)
    RCURLYBRACKET   reduce using rule 11 (class_content -> while .)


state 12

    (12) class_content -> stack .

    CONTINUE        reduce using rule 12 (class_content -> stack .)
    FINAL           reduce using rule 12 (class_content -> stack .)
    STRING          reduce using rule 12 (class_content -> stack .)
    INT             reduce using rule 12 (class_content -> stack .)
    FOR             reduce using rule 12 (class_content -> stack .)
    WHILE           reduce using rule 12 (class_content -> stack .)
    IDENTIFIER      reduce using rule 12 (class_content -> stack .)
    PRINT           reduce using rule 12 (class_content -> stack .)
    BOOL            reduce using rule 12 (class_content -> stack .)
    LIST            reduce using rule 12 (class_content -> stack .)
    ASSERT          reduce using rule 12 (class_content -> stack .)
    DOUBLE          reduce using rule 12 (class_content -> stack .)
    DYNAMIC         reduce using rule 12 (class_content -> stack .)
    VOID            reduce using rule 12 (class_content -> stack .)
    VAR             reduce using rule 12 (class_content -> stack .)
    MAP             reduce using rule 12 (class_content -> stack .)
    IF              reduce using rule 12 (class_content -> stack .)
    INTEGER         reduce using rule 12 (class_content -> stack .)
    FLOAT           reduce using rule 12 (class_content -> stack .)
    STR             reduce using rule 12 (class_content -> stack .)
    BOOLEAN         reduce using rule 12 (class_content -> stack .)
    TRUE            reduce using rule 12 (class_content -> stack .)
    FALSE           reduce using rule 12 (class_content -> stack .)
    MAIN            reduce using rule 12 (class_content -> stack .)
    $end            reduce using rule 12 (class_content -> stack .)
    RCURLYBRACKET   reduce using rule 12 (class_content -> stack .)


state 13

    (13) class_content -> inferedReturnFunction .

    CONTINUE        reduce using rule 13 (class_content -> inferedReturnFunction .)
    FINAL           reduce using rule 13 (class_content -> inferedReturnFunction .)
    STRING          reduce using rule 13 (class_content -> inferedReturnFunction .)
    INT             reduce using rule 13 (class_content -> inferedReturnFunction .)
    FOR             reduce using rule 13 (class_content -> inferedReturnFunction .)
    WHILE           reduce using rule 13 (class_content -> inferedReturnFunction .)
    IDENTIFIER      reduce using rule 13 (class_content -> inferedReturnFunction .)
    PRINT           reduce using rule 13 (class_content -> inferedReturnFunction .)
    BOOL            reduce using rule 13 (class_content -> inferedReturnFunction .)
    LIST            reduce using rule 13 (class_content -> inferedReturnFunction .)
    ASSERT          reduce using rule 13 (class_content -> inferedReturnFunction .)
    DOUBLE          reduce using rule 13 (class_content -> inferedReturnFunction .)
    DYNAMIC         reduce using rule 13 (class_content -> inferedReturnFunction .)
    VOID            reduce using rule 13 (class_content -> inferedReturnFunction .)
    VAR             reduce using rule 13 (class_content -> inferedReturnFunction .)
    MAP             reduce using rule 13 (class_content -> inferedReturnFunction .)
    IF              reduce using rule 13 (class_content -> inferedReturnFunction .)
    INTEGER         reduce using rule 13 (class_content -> inferedReturnFunction .)
    FLOAT           reduce using rule 13 (class_content -> inferedReturnFunction .)
    STR             reduce using rule 13 (class_content -> inferedReturnFunction .)
    BOOLEAN         reduce using rule 13 (class_content -> inferedReturnFunction .)
    TRUE            reduce using rule 13 (class_content -> inferedReturnFunction .)
    FALSE           reduce using rule 13 (class_content -> inferedReturnFunction .)
    MAIN            reduce using rule 13 (class_content -> inferedReturnFunction .)
    $end            reduce using rule 13 (class_content -> inferedReturnFunction .)
    RCURLYBRACKET   reduce using rule 13 (class_content -> inferedReturnFunction .)


state 14

    (14) class_content -> expression . SEMICOLON

    SEMICOLON       shift and go to state 61


state 15

    (15) class_content -> print .

    CONTINUE        reduce using rule 15 (class_content -> print .)
    FINAL           reduce using rule 15 (class_content -> print .)
    STRING          reduce using rule 15 (class_content -> print .)
    INT             reduce using rule 15 (class_content -> print .)
    FOR             reduce using rule 15 (class_content -> print .)
    WHILE           reduce using rule 15 (class_content -> print .)
    IDENTIFIER      reduce using rule 15 (class_content -> print .)
    PRINT           reduce using rule 15 (class_content -> print .)
    BOOL            reduce using rule 15 (class_content -> print .)
    LIST            reduce using rule 15 (class_content -> print .)
    ASSERT          reduce using rule 15 (class_content -> print .)
    DOUBLE          reduce using rule 15 (class_content -> print .)
    DYNAMIC         reduce using rule 15 (class_content -> print .)
    VOID            reduce using rule 15 (class_content -> print .)
    VAR             reduce using rule 15 (class_content -> print .)
    MAP             reduce using rule 15 (class_content -> print .)
    IF              reduce using rule 15 (class_content -> print .)
    INTEGER         reduce using rule 15 (class_content -> print .)
    FLOAT           reduce using rule 15 (class_content -> print .)
    STR             reduce using rule 15 (class_content -> print .)
    BOOLEAN         reduce using rule 15 (class_content -> print .)
    TRUE            reduce using rule 15 (class_content -> print .)
    FALSE           reduce using rule 15 (class_content -> print .)
    MAIN            reduce using rule 15 (class_content -> print .)
    $end            reduce using rule 15 (class_content -> print .)
    RCURLYBRACKET   reduce using rule 15 (class_content -> print .)


state 16

    (16) class_content -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 62


state 17

    (22) class_content -> semanticbool .

    CONTINUE        reduce using rule 22 (class_content -> semanticbool .)
    FINAL           reduce using rule 22 (class_content -> semanticbool .)
    STRING          reduce using rule 22 (class_content -> semanticbool .)
    INT             reduce using rule 22 (class_content -> semanticbool .)
    FOR             reduce using rule 22 (class_content -> semanticbool .)
    WHILE           reduce using rule 22 (class_content -> semanticbool .)
    IDENTIFIER      reduce using rule 22 (class_content -> semanticbool .)
    PRINT           reduce using rule 22 (class_content -> semanticbool .)
    BOOL            reduce using rule 22 (class_content -> semanticbool .)
    LIST            reduce using rule 22 (class_content -> semanticbool .)
    ASSERT          reduce using rule 22 (class_content -> semanticbool .)
    DOUBLE          reduce using rule 22 (class_content -> semanticbool .)
    DYNAMIC         reduce using rule 22 (class_content -> semanticbool .)
    VOID            reduce using rule 22 (class_content -> semanticbool .)
    VAR             reduce using rule 22 (class_content -> semanticbool .)
    MAP             reduce using rule 22 (class_content -> semanticbool .)
    IF              reduce using rule 22 (class_content -> semanticbool .)
    INTEGER         reduce using rule 22 (class_content -> semanticbool .)
    FLOAT           reduce using rule 22 (class_content -> semanticbool .)
    STR             reduce using rule 22 (class_content -> semanticbool .)
    BOOLEAN         reduce using rule 22 (class_content -> semanticbool .)
    TRUE            reduce using rule 22 (class_content -> semanticbool .)
    FALSE           reduce using rule 22 (class_content -> semanticbool .)
    MAIN            reduce using rule 22 (class_content -> semanticbool .)
    $end            reduce using rule 22 (class_content -> semanticbool .)
    RCURLYBRACKET   reduce using rule 22 (class_content -> semanticbool .)


state 18

    (23) class_content -> semanticlist .

    CONTINUE        reduce using rule 23 (class_content -> semanticlist .)
    FINAL           reduce using rule 23 (class_content -> semanticlist .)
    STRING          reduce using rule 23 (class_content -> semanticlist .)
    INT             reduce using rule 23 (class_content -> semanticlist .)
    FOR             reduce using rule 23 (class_content -> semanticlist .)
    WHILE           reduce using rule 23 (class_content -> semanticlist .)
    IDENTIFIER      reduce using rule 23 (class_content -> semanticlist .)
    PRINT           reduce using rule 23 (class_content -> semanticlist .)
    BOOL            reduce using rule 23 (class_content -> semanticlist .)
    LIST            reduce using rule 23 (class_content -> semanticlist .)
    ASSERT          reduce using rule 23 (class_content -> semanticlist .)
    DOUBLE          reduce using rule 23 (class_content -> semanticlist .)
    DYNAMIC         reduce using rule 23 (class_content -> semanticlist .)
    VOID            reduce using rule 23 (class_content -> semanticlist .)
    VAR             reduce using rule 23 (class_content -> semanticlist .)
    MAP             reduce using rule 23 (class_content -> semanticlist .)
    IF              reduce using rule 23 (class_content -> semanticlist .)
    INTEGER         reduce using rule 23 (class_content -> semanticlist .)
    FLOAT           reduce using rule 23 (class_content -> semanticlist .)
    STR             reduce using rule 23 (class_content -> semanticlist .)
    BOOLEAN         reduce using rule 23 (class_content -> semanticlist .)
    TRUE            reduce using rule 23 (class_content -> semanticlist .)
    FALSE           reduce using rule 23 (class_content -> semanticlist .)
    MAIN            reduce using rule 23 (class_content -> semanticlist .)
    $end            reduce using rule 23 (class_content -> semanticlist .)
    RCURLYBRACKET   reduce using rule 23 (class_content -> semanticlist .)


state 19

    (24) class_content -> asign .

    CONTINUE        reduce using rule 24 (class_content -> asign .)
    FINAL           reduce using rule 24 (class_content -> asign .)
    STRING          reduce using rule 24 (class_content -> asign .)
    INT             reduce using rule 24 (class_content -> asign .)
    FOR             reduce using rule 24 (class_content -> asign .)
    WHILE           reduce using rule 24 (class_content -> asign .)
    IDENTIFIER      reduce using rule 24 (class_content -> asign .)
    PRINT           reduce using rule 24 (class_content -> asign .)
    BOOL            reduce using rule 24 (class_content -> asign .)
    LIST            reduce using rule 24 (class_content -> asign .)
    ASSERT          reduce using rule 24 (class_content -> asign .)
    DOUBLE          reduce using rule 24 (class_content -> asign .)
    DYNAMIC         reduce using rule 24 (class_content -> asign .)
    VOID            reduce using rule 24 (class_content -> asign .)
    VAR             reduce using rule 24 (class_content -> asign .)
    MAP             reduce using rule 24 (class_content -> asign .)
    IF              reduce using rule 24 (class_content -> asign .)
    INTEGER         reduce using rule 24 (class_content -> asign .)
    FLOAT           reduce using rule 24 (class_content -> asign .)
    STR             reduce using rule 24 (class_content -> asign .)
    BOOLEAN         reduce using rule 24 (class_content -> asign .)
    TRUE            reduce using rule 24 (class_content -> asign .)
    FALSE           reduce using rule 24 (class_content -> asign .)
    MAIN            reduce using rule 24 (class_content -> asign .)
    $end            reduce using rule 24 (class_content -> asign .)
    RCURLYBRACKET   reduce using rule 24 (class_content -> asign .)


state 20

    (25) class_content -> addlistInt .

    CONTINUE        reduce using rule 25 (class_content -> addlistInt .)
    FINAL           reduce using rule 25 (class_content -> addlistInt .)
    STRING          reduce using rule 25 (class_content -> addlistInt .)
    INT             reduce using rule 25 (class_content -> addlistInt .)
    FOR             reduce using rule 25 (class_content -> addlistInt .)
    WHILE           reduce using rule 25 (class_content -> addlistInt .)
    IDENTIFIER      reduce using rule 25 (class_content -> addlistInt .)
    PRINT           reduce using rule 25 (class_content -> addlistInt .)
    BOOL            reduce using rule 25 (class_content -> addlistInt .)
    LIST            reduce using rule 25 (class_content -> addlistInt .)
    ASSERT          reduce using rule 25 (class_content -> addlistInt .)
    DOUBLE          reduce using rule 25 (class_content -> addlistInt .)
    DYNAMIC         reduce using rule 25 (class_content -> addlistInt .)
    VOID            reduce using rule 25 (class_content -> addlistInt .)
    VAR             reduce using rule 25 (class_content -> addlistInt .)
    MAP             reduce using rule 25 (class_content -> addlistInt .)
    IF              reduce using rule 25 (class_content -> addlistInt .)
    INTEGER         reduce using rule 25 (class_content -> addlistInt .)
    FLOAT           reduce using rule 25 (class_content -> addlistInt .)
    STR             reduce using rule 25 (class_content -> addlistInt .)
    BOOLEAN         reduce using rule 25 (class_content -> addlistInt .)
    TRUE            reduce using rule 25 (class_content -> addlistInt .)
    FALSE           reduce using rule 25 (class_content -> addlistInt .)
    MAIN            reduce using rule 25 (class_content -> addlistInt .)
    $end            reduce using rule 25 (class_content -> addlistInt .)
    RCURLYBRACKET   reduce using rule 25 (class_content -> addlistInt .)


state 21

    (26) class_content -> addlistBool .

    CONTINUE        reduce using rule 26 (class_content -> addlistBool .)
    FINAL           reduce using rule 26 (class_content -> addlistBool .)
    STRING          reduce using rule 26 (class_content -> addlistBool .)
    INT             reduce using rule 26 (class_content -> addlistBool .)
    FOR             reduce using rule 26 (class_content -> addlistBool .)
    WHILE           reduce using rule 26 (class_content -> addlistBool .)
    IDENTIFIER      reduce using rule 26 (class_content -> addlistBool .)
    PRINT           reduce using rule 26 (class_content -> addlistBool .)
    BOOL            reduce using rule 26 (class_content -> addlistBool .)
    LIST            reduce using rule 26 (class_content -> addlistBool .)
    ASSERT          reduce using rule 26 (class_content -> addlistBool .)
    DOUBLE          reduce using rule 26 (class_content -> addlistBool .)
    DYNAMIC         reduce using rule 26 (class_content -> addlistBool .)
    VOID            reduce using rule 26 (class_content -> addlistBool .)
    VAR             reduce using rule 26 (class_content -> addlistBool .)
    MAP             reduce using rule 26 (class_content -> addlistBool .)
    IF              reduce using rule 26 (class_content -> addlistBool .)
    INTEGER         reduce using rule 26 (class_content -> addlistBool .)
    FLOAT           reduce using rule 26 (class_content -> addlistBool .)
    STR             reduce using rule 26 (class_content -> addlistBool .)
    BOOLEAN         reduce using rule 26 (class_content -> addlistBool .)
    TRUE            reduce using rule 26 (class_content -> addlistBool .)
    FALSE           reduce using rule 26 (class_content -> addlistBool .)
    MAIN            reduce using rule 26 (class_content -> addlistBool .)
    $end            reduce using rule 26 (class_content -> addlistBool .)
    RCURLYBRACKET   reduce using rule 26 (class_content -> addlistBool .)


state 22

    (27) class_content -> addlistFloat .

    CONTINUE        reduce using rule 27 (class_content -> addlistFloat .)
    FINAL           reduce using rule 27 (class_content -> addlistFloat .)
    STRING          reduce using rule 27 (class_content -> addlistFloat .)
    INT             reduce using rule 27 (class_content -> addlistFloat .)
    FOR             reduce using rule 27 (class_content -> addlistFloat .)
    WHILE           reduce using rule 27 (class_content -> addlistFloat .)
    IDENTIFIER      reduce using rule 27 (class_content -> addlistFloat .)
    PRINT           reduce using rule 27 (class_content -> addlistFloat .)
    BOOL            reduce using rule 27 (class_content -> addlistFloat .)
    LIST            reduce using rule 27 (class_content -> addlistFloat .)
    ASSERT          reduce using rule 27 (class_content -> addlistFloat .)
    DOUBLE          reduce using rule 27 (class_content -> addlistFloat .)
    DYNAMIC         reduce using rule 27 (class_content -> addlistFloat .)
    VOID            reduce using rule 27 (class_content -> addlistFloat .)
    VAR             reduce using rule 27 (class_content -> addlistFloat .)
    MAP             reduce using rule 27 (class_content -> addlistFloat .)
    IF              reduce using rule 27 (class_content -> addlistFloat .)
    INTEGER         reduce using rule 27 (class_content -> addlistFloat .)
    FLOAT           reduce using rule 27 (class_content -> addlistFloat .)
    STR             reduce using rule 27 (class_content -> addlistFloat .)
    BOOLEAN         reduce using rule 27 (class_content -> addlistFloat .)
    TRUE            reduce using rule 27 (class_content -> addlistFloat .)
    FALSE           reduce using rule 27 (class_content -> addlistFloat .)
    MAIN            reduce using rule 27 (class_content -> addlistFloat .)
    $end            reduce using rule 27 (class_content -> addlistFloat .)
    RCURLYBRACKET   reduce using rule 27 (class_content -> addlistFloat .)


state 23

    (28) class_content -> addlistStr .

    CONTINUE        reduce using rule 28 (class_content -> addlistStr .)
    FINAL           reduce using rule 28 (class_content -> addlistStr .)
    STRING          reduce using rule 28 (class_content -> addlistStr .)
    INT             reduce using rule 28 (class_content -> addlistStr .)
    FOR             reduce using rule 28 (class_content -> addlistStr .)
    WHILE           reduce using rule 28 (class_content -> addlistStr .)
    IDENTIFIER      reduce using rule 28 (class_content -> addlistStr .)
    PRINT           reduce using rule 28 (class_content -> addlistStr .)
    BOOL            reduce using rule 28 (class_content -> addlistStr .)
    LIST            reduce using rule 28 (class_content -> addlistStr .)
    ASSERT          reduce using rule 28 (class_content -> addlistStr .)
    DOUBLE          reduce using rule 28 (class_content -> addlistStr .)
    DYNAMIC         reduce using rule 28 (class_content -> addlistStr .)
    VOID            reduce using rule 28 (class_content -> addlistStr .)
    VAR             reduce using rule 28 (class_content -> addlistStr .)
    MAP             reduce using rule 28 (class_content -> addlistStr .)
    IF              reduce using rule 28 (class_content -> addlistStr .)
    INTEGER         reduce using rule 28 (class_content -> addlistStr .)
    FLOAT           reduce using rule 28 (class_content -> addlistStr .)
    STR             reduce using rule 28 (class_content -> addlistStr .)
    BOOLEAN         reduce using rule 28 (class_content -> addlistStr .)
    TRUE            reduce using rule 28 (class_content -> addlistStr .)
    FALSE           reduce using rule 28 (class_content -> addlistStr .)
    MAIN            reduce using rule 28 (class_content -> addlistStr .)
    $end            reduce using rule 28 (class_content -> addlistStr .)
    RCURLYBRACKET   reduce using rule 28 (class_content -> addlistStr .)


state 24

    (29) class_content -> assert .

    CONTINUE        reduce using rule 29 (class_content -> assert .)
    FINAL           reduce using rule 29 (class_content -> assert .)
    STRING          reduce using rule 29 (class_content -> assert .)
    INT             reduce using rule 29 (class_content -> assert .)
    FOR             reduce using rule 29 (class_content -> assert .)
    WHILE           reduce using rule 29 (class_content -> assert .)
    IDENTIFIER      reduce using rule 29 (class_content -> assert .)
    PRINT           reduce using rule 29 (class_content -> assert .)
    BOOL            reduce using rule 29 (class_content -> assert .)
    LIST            reduce using rule 29 (class_content -> assert .)
    ASSERT          reduce using rule 29 (class_content -> assert .)
    DOUBLE          reduce using rule 29 (class_content -> assert .)
    DYNAMIC         reduce using rule 29 (class_content -> assert .)
    VOID            reduce using rule 29 (class_content -> assert .)
    VAR             reduce using rule 29 (class_content -> assert .)
    MAP             reduce using rule 29 (class_content -> assert .)
    IF              reduce using rule 29 (class_content -> assert .)
    INTEGER         reduce using rule 29 (class_content -> assert .)
    FLOAT           reduce using rule 29 (class_content -> assert .)
    STR             reduce using rule 29 (class_content -> assert .)
    BOOLEAN         reduce using rule 29 (class_content -> assert .)
    TRUE            reduce using rule 29 (class_content -> assert .)
    FALSE           reduce using rule 29 (class_content -> assert .)
    MAIN            reduce using rule 29 (class_content -> assert .)
    $end            reduce using rule 29 (class_content -> assert .)
    RCURLYBRACKET   reduce using rule 29 (class_content -> assert .)


state 25

    (20) datatypeOpt -> datatype .
    (111) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (138) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> datatype . IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (136) repeatDeclaration -> . IDENTIFIER
    (137) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    MAIN            reduce using rule 20 (datatypeOpt -> datatype .)
    IDENTIFIER      shift and go to state 63

    repeatDeclaration              shift and go to state 64

state 26

    (21) datatypeOpt -> empty .

    MAIN            reduce using rule 21 (datatypeOpt -> empty .)


state 27

    (30) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (40) datatype -> map_identifier .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 65
    MAIN            reduce using rule 40 (datatype -> map_identifier .)

  ! IDENTIFIER      [ reduce using rule 40 (datatype -> map_identifier .) ]


state 28

    (70) inferedReturnFunction -> IDENTIFIER . LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (125) asign -> IDENTIFIER . EQUAL expression SEMICOLON
    (126) asign -> IDENTIFIER . operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> IDENTIFIER . DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> IDENTIFIER . DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> IDENTIFIER . DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> IDENTIFIER . DOT ADD LPAREN STR RPAREN SEMICOLON
    (75) value -> IDENTIFIER .
    (182) propertiesAccess -> IDENTIFIER . DOT properties
    (145) booloperation -> IDENTIFIER . condition_connector booleanOp
    (146) booloperation -> IDENTIFIER . condition_connector IDENTIFIER
    (130) operatorExpression -> . PLUS
    (131) operatorExpression -> . MINUS
    (132) operatorExpression -> . TIMES
    (133) operatorExpression -> . DIVISION
    (134) operatorExpression -> . REST
    (107) condition_connector -> . AND
    (108) condition_connector -> . OR
    (109) condition_connector -> . AMPERSAND AMPERSAND
    (110) condition_connector -> . PIPELINE PIPELINE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for REST resolved as shift
    LPAREN          shift and go to state 66
    EQUAL           shift and go to state 67
    DOT             shift and go to state 69
    SEMICOLON       reduce using rule 75 (value -> IDENTIFIER .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVISION        shift and go to state 74
    REST            shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    AMPERSAND       shift and go to state 78
    PIPELINE        shift and go to state 79

  ! PLUS            [ reduce using rule 75 (value -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 75 (value -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 75 (value -> IDENTIFIER .) ]
  ! DIVISION        [ reduce using rule 75 (value -> IDENTIFIER .) ]
  ! REST            [ reduce using rule 75 (value -> IDENTIFIER .) ]

    operatorExpression             shift and go to state 68
    condition_connector            shift and go to state 70

state 29

    (58) ifElseStatement -> ifStatement .
    (59) ifElseStatement -> ifStatement . elifStatement_repeat
    (60) elifStatement_repeat -> . elifStatement
    (61) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (63) elifStatement -> . ELSE ifStatement
    (64) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    CONTINUE        reduce using rule 58 (ifElseStatement -> ifStatement .)
    FINAL           reduce using rule 58 (ifElseStatement -> ifStatement .)
    STRING          reduce using rule 58 (ifElseStatement -> ifStatement .)
    INT             reduce using rule 58 (ifElseStatement -> ifStatement .)
    FOR             reduce using rule 58 (ifElseStatement -> ifStatement .)
    WHILE           reduce using rule 58 (ifElseStatement -> ifStatement .)
    IDENTIFIER      reduce using rule 58 (ifElseStatement -> ifStatement .)
    PRINT           reduce using rule 58 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 58 (ifElseStatement -> ifStatement .)
    LIST            reduce using rule 58 (ifElseStatement -> ifStatement .)
    ASSERT          reduce using rule 58 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 58 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 58 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 58 (ifElseStatement -> ifStatement .)
    VAR             reduce using rule 58 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 58 (ifElseStatement -> ifStatement .)
    IF              reduce using rule 58 (ifElseStatement -> ifStatement .)
    INTEGER         reduce using rule 58 (ifElseStatement -> ifStatement .)
    FLOAT           reduce using rule 58 (ifElseStatement -> ifStatement .)
    STR             reduce using rule 58 (ifElseStatement -> ifStatement .)
    BOOLEAN         reduce using rule 58 (ifElseStatement -> ifStatement .)
    TRUE            reduce using rule 58 (ifElseStatement -> ifStatement .)
    FALSE           reduce using rule 58 (ifElseStatement -> ifStatement .)
    MAIN            reduce using rule 58 (ifElseStatement -> ifStatement .)
    $end            reduce using rule 58 (ifElseStatement -> ifStatement .)
    RCURLYBRACKET   reduce using rule 58 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 82

    elifStatement_repeat           shift and go to state 80
    elifStatement                  shift and go to state 81

state 30

    (140) declarationExpression -> FINAL . IDENTIFIER EQUAL expression SEMICOLON
    (66) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> FINAL . IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 83


state 31

    (169) declarationExpression -> STRING . IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> STRING . IDENTIFIER SEMICOLON
    (35) datatype -> STRING .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 84
    MAIN            reduce using rule 35 (datatype -> STRING .)

  ! IDENTIFIER      [ reduce using rule 35 (datatype -> STRING .) ]


state 32

    (174) declarationExpression -> INT . IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> INT . IDENTIFIER SEMICOLON
    (34) datatype -> INT .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 85
    MAIN            reduce using rule 34 (datatype -> INT .)

  ! IDENTIFIER      [ reduce using rule 34 (datatype -> INT .) ]


state 33

    (65) forStatement -> FOR . LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    LPAREN          shift and go to state 86


state 34

    (67) while -> WHILE . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 87


state 35

    (121) expression -> value .
    (122) expression -> value . operatorExpression expression
    (123) expression -> value . operatorExpression operatorExpression
    (130) operatorExpression -> . PLUS
    (131) operatorExpression -> . MINUS
    (132) operatorExpression -> . TIMES
    (133) operatorExpression -> . DIVISION
    (134) operatorExpression -> . REST

    SEMICOLON       reduce using rule 121 (expression -> value .)
    RPAREN          reduce using rule 121 (expression -> value .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVISION        shift and go to state 74
    REST            shift and go to state 75

    operatorExpression             shift and go to state 88

state 36

    (124) expression -> booloperations .

    SEMICOLON       reduce using rule 124 (expression -> booloperations .)
    RPAREN          reduce using rule 124 (expression -> booloperations .)


state 37

    (49) print -> PRINT . LPAREN value RPAREN SEMICOLON

    LPAREN          shift and go to state 89


state 38

    (141) semanticbool -> BOOL . IDENTIFIER EQUAL conditions SEMICOLON
    (36) datatype -> BOOL .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 90
    MAIN            reduce using rule 36 (datatype -> BOOL .)

  ! IDENTIFIER      [ reduce using rule 36 (datatype -> BOOL .) ]


state 39

    (150) semanticlist -> LIST . LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> LIST . LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> LIST . LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> LIST . LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> LIST . LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    LESSTHAN        shift and go to state 91


state 40

    (38) datatype -> DYNAMIC .

    IDENTIFIER      reduce using rule 38 (datatype -> DYNAMIC .)
    MAIN            reduce using rule 38 (datatype -> DYNAMIC .)
    COMMA           reduce using rule 38 (datatype -> DYNAMIC .)
    RPAREN          reduce using rule 38 (datatype -> DYNAMIC .)
    GREATERTHAN     reduce using rule 38 (datatype -> DYNAMIC .)


state 41

    (37) datatype -> DOUBLE .

    IDENTIFIER      reduce using rule 37 (datatype -> DOUBLE .)
    MAIN            reduce using rule 37 (datatype -> DOUBLE .)
    COMMA           reduce using rule 37 (datatype -> DOUBLE .)
    RPAREN          reduce using rule 37 (datatype -> DOUBLE .)
    GREATERTHAN     reduce using rule 37 (datatype -> DOUBLE .)


state 42

    (71) value -> INTEGER .

    PLUS            reduce using rule 71 (value -> INTEGER .)
    MINUS           reduce using rule 71 (value -> INTEGER .)
    TIMES           reduce using rule 71 (value -> INTEGER .)
    DIVISION        reduce using rule 71 (value -> INTEGER .)
    REST            reduce using rule 71 (value -> INTEGER .)
    SEMICOLON       reduce using rule 71 (value -> INTEGER .)
    RPAREN          reduce using rule 71 (value -> INTEGER .)
    COLON           reduce using rule 71 (value -> INTEGER .)
    COMMA           reduce using rule 71 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 71 (value -> INTEGER .)
    RSQUAREBRACKET  reduce using rule 71 (value -> INTEGER .)


state 43

    (76) value -> booleanOp .
    (144) booloperation -> booleanOp . condition_connector booleanOp
    (147) booloperation -> booleanOp . condition_connector IDENTIFIER
    (107) condition_connector -> . AND
    (108) condition_connector -> . OR
    (109) condition_connector -> . AMPERSAND AMPERSAND
    (110) condition_connector -> . PIPELINE PIPELINE

    PLUS            reduce using rule 76 (value -> booleanOp .)
    MINUS           reduce using rule 76 (value -> booleanOp .)
    TIMES           reduce using rule 76 (value -> booleanOp .)
    DIVISION        reduce using rule 76 (value -> booleanOp .)
    REST            reduce using rule 76 (value -> booleanOp .)
    SEMICOLON       reduce using rule 76 (value -> booleanOp .)
    RPAREN          reduce using rule 76 (value -> booleanOp .)
    AND             shift and go to state 76
    OR              shift and go to state 77
    AMPERSAND       shift and go to state 78
    PIPELINE        shift and go to state 79

    condition_connector            shift and go to state 92

state 44

    (72) value -> FLOAT .

    PLUS            reduce using rule 72 (value -> FLOAT .)
    MINUS           reduce using rule 72 (value -> FLOAT .)
    TIMES           reduce using rule 72 (value -> FLOAT .)
    DIVISION        reduce using rule 72 (value -> FLOAT .)
    REST            reduce using rule 72 (value -> FLOAT .)
    SEMICOLON       reduce using rule 72 (value -> FLOAT .)
    RPAREN          reduce using rule 72 (value -> FLOAT .)
    COLON           reduce using rule 72 (value -> FLOAT .)
    COMMA           reduce using rule 72 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 72 (value -> FLOAT .)
    RSQUAREBRACKET  reduce using rule 72 (value -> FLOAT .)


state 45

    (73) value -> STR .

    PLUS            reduce using rule 73 (value -> STR .)
    MINUS           reduce using rule 73 (value -> STR .)
    TIMES           reduce using rule 73 (value -> STR .)
    DIVISION        reduce using rule 73 (value -> STR .)
    REST            reduce using rule 73 (value -> STR .)
    SEMICOLON       reduce using rule 73 (value -> STR .)
    RPAREN          reduce using rule 73 (value -> STR .)
    COLON           reduce using rule 73 (value -> STR .)
    COMMA           reduce using rule 73 (value -> STR .)
    RCURLYBRACKET   reduce using rule 73 (value -> STR .)
    RSQUAREBRACKET  reduce using rule 73 (value -> STR .)


state 46

    (127) assert -> ASSERT . LPAREN conditions RPAREN SEMICOLON

    LPAREN          shift and go to state 93


state 47

    (39) datatype -> VOID .

    IDENTIFIER      reduce using rule 39 (datatype -> VOID .)
    MAIN            reduce using rule 39 (datatype -> VOID .)
    COMMA           reduce using rule 39 (datatype -> VOID .)
    RPAREN          reduce using rule 39 (datatype -> VOID .)
    GREATERTHAN     reduce using rule 39 (datatype -> VOID .)


state 48

    (41) datatype -> VAR .

    IDENTIFIER      reduce using rule 41 (datatype -> VAR .)
    MAIN            reduce using rule 41 (datatype -> VAR .)
    COMMA           reduce using rule 41 (datatype -> VAR .)
    RPAREN          reduce using rule 41 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 41 (datatype -> VAR .)


state 49

    (31) map_identifier -> MAP .
    (32) map_identifier -> MAP . map_type_specified
    (33) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 31 (map_identifier -> MAP .)
    MAIN            reduce using rule 31 (map_identifier -> MAP .)
    COMMA           reduce using rule 31 (map_identifier -> MAP .)
    RPAREN          reduce using rule 31 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 31 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 95

    map_type_specified             shift and go to state 94

state 50

    (62) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 96


state 51

    (74) value -> BOOLEAN .

    PLUS            reduce using rule 74 (value -> BOOLEAN .)
    MINUS           reduce using rule 74 (value -> BOOLEAN .)
    TIMES           reduce using rule 74 (value -> BOOLEAN .)
    DIVISION        reduce using rule 74 (value -> BOOLEAN .)
    REST            reduce using rule 74 (value -> BOOLEAN .)
    SEMICOLON       reduce using rule 74 (value -> BOOLEAN .)
    RPAREN          reduce using rule 74 (value -> BOOLEAN .)
    COLON           reduce using rule 74 (value -> BOOLEAN .)
    COMMA           reduce using rule 74 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 74 (value -> BOOLEAN .)
    RSQUAREBRACKET  reduce using rule 74 (value -> BOOLEAN .)


state 52

    (77) value -> propertiesAccess .

    PLUS            reduce using rule 77 (value -> propertiesAccess .)
    MINUS           reduce using rule 77 (value -> propertiesAccess .)
    TIMES           reduce using rule 77 (value -> propertiesAccess .)
    DIVISION        reduce using rule 77 (value -> propertiesAccess .)
    REST            reduce using rule 77 (value -> propertiesAccess .)
    SEMICOLON       reduce using rule 77 (value -> propertiesAccess .)
    RPAREN          reduce using rule 77 (value -> propertiesAccess .)
    COLON           reduce using rule 77 (value -> propertiesAccess .)
    COMMA           reduce using rule 77 (value -> propertiesAccess .)
    RCURLYBRACKET   reduce using rule 77 (value -> propertiesAccess .)
    RSQUAREBRACKET  reduce using rule 77 (value -> propertiesAccess .)


state 53

    (148) booloperations -> booloperation .
    (149) booloperations -> booloperation . condition_connector booloperations
    (107) condition_connector -> . AND
    (108) condition_connector -> . OR
    (109) condition_connector -> . AMPERSAND AMPERSAND
    (110) condition_connector -> . PIPELINE PIPELINE

    SEMICOLON       reduce using rule 148 (booloperations -> booloperation .)
    RPAREN          reduce using rule 148 (booloperations -> booloperation .)
    AND             shift and go to state 76
    OR              shift and go to state 77
    AMPERSAND       shift and go to state 78
    PIPELINE        shift and go to state 79

    condition_connector            shift and go to state 97

state 54

    (142) booleanOp -> TRUE .

    AND             reduce using rule 142 (booleanOp -> TRUE .)
    OR              reduce using rule 142 (booleanOp -> TRUE .)
    AMPERSAND       reduce using rule 142 (booleanOp -> TRUE .)
    PIPELINE        reduce using rule 142 (booleanOp -> TRUE .)
    PLUS            reduce using rule 142 (booleanOp -> TRUE .)
    MINUS           reduce using rule 142 (booleanOp -> TRUE .)
    TIMES           reduce using rule 142 (booleanOp -> TRUE .)
    DIVISION        reduce using rule 142 (booleanOp -> TRUE .)
    REST            reduce using rule 142 (booleanOp -> TRUE .)
    SEMICOLON       reduce using rule 142 (booleanOp -> TRUE .)
    RPAREN          reduce using rule 142 (booleanOp -> TRUE .)
    DOUBLEQUAL      reduce using rule 142 (booleanOp -> TRUE .)
    LESSTHAN        reduce using rule 142 (booleanOp -> TRUE .)
    GREATERTHAN     reduce using rule 142 (booleanOp -> TRUE .)
    EXMARK          reduce using rule 142 (booleanOp -> TRUE .)
    COLON           reduce using rule 142 (booleanOp -> TRUE .)
    COMMA           reduce using rule 142 (booleanOp -> TRUE .)
    RCURLYBRACKET   reduce using rule 142 (booleanOp -> TRUE .)
    RSQUAREBRACKET  reduce using rule 142 (booleanOp -> TRUE .)


state 55

    (143) booleanOp -> FALSE .

    AND             reduce using rule 143 (booleanOp -> FALSE .)
    OR              reduce using rule 143 (booleanOp -> FALSE .)
    AMPERSAND       reduce using rule 143 (booleanOp -> FALSE .)
    PIPELINE        reduce using rule 143 (booleanOp -> FALSE .)
    PLUS            reduce using rule 143 (booleanOp -> FALSE .)
    MINUS           reduce using rule 143 (booleanOp -> FALSE .)
    TIMES           reduce using rule 143 (booleanOp -> FALSE .)
    DIVISION        reduce using rule 143 (booleanOp -> FALSE .)
    REST            reduce using rule 143 (booleanOp -> FALSE .)
    SEMICOLON       reduce using rule 143 (booleanOp -> FALSE .)
    RPAREN          reduce using rule 143 (booleanOp -> FALSE .)
    DOUBLEQUAL      reduce using rule 143 (booleanOp -> FALSE .)
    LESSTHAN        reduce using rule 143 (booleanOp -> FALSE .)
    GREATERTHAN     reduce using rule 143 (booleanOp -> FALSE .)
    EXMARK          reduce using rule 143 (booleanOp -> FALSE .)
    COLON           reduce using rule 143 (booleanOp -> FALSE .)
    COMMA           reduce using rule 143 (booleanOp -> FALSE .)
    RCURLYBRACKET   reduce using rule 143 (booleanOp -> FALSE .)
    RSQUAREBRACKET  reduce using rule 143 (booleanOp -> FALSE .)


state 56

    (3) class -> class_content_repeat declarationMain .
    (4) class -> class_content_repeat declarationMain . class_content_repeat
    (17) class_content_repeat -> . class_content
    (18) class_content_repeat -> . class_content_repeat class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    $end            reduce using rule 3 (class -> class_content_repeat declarationMain .)
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content_repeat           shift and go to state 98
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 57

    (18) class_content_repeat -> class_content_repeat class_content .

    CONTINUE        reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    FINAL           reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    STRING          reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    INT             reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    FOR             reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    WHILE           reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    IDENTIFIER      reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    PRINT           reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    BOOL            reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    LIST            reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    ASSERT          reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    DOUBLE          reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    DYNAMIC         reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    VOID            reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    VAR             reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    MAP             reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    IF              reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    INTEGER         reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    FLOAT           reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    STR             reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    BOOLEAN         reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    TRUE            reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    FALSE           reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    MAIN            reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    $end            reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)
    RCURLYBRACKET   reduce using rule 18 (class_content_repeat -> class_content_repeat class_content .)


state 58

    (2) class -> declarationMain class_content_repeat .
    (18) class_content_repeat -> class_content_repeat . class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    $end            reduce using rule 2 (class -> declarationMain class_content_repeat .)
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content                  shift and go to state 57
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 59

    (111) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (138) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> datatype . IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (136) repeatDeclaration -> . IDENTIFIER
    (137) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 63

    repeatDeclaration              shift and go to state 64

state 60

    (19) declarationMain -> datatypeOpt MAIN . LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 99


state 61

    (14) class_content -> expression SEMICOLON .

    CONTINUE        reduce using rule 14 (class_content -> expression SEMICOLON .)
    FINAL           reduce using rule 14 (class_content -> expression SEMICOLON .)
    STRING          reduce using rule 14 (class_content -> expression SEMICOLON .)
    INT             reduce using rule 14 (class_content -> expression SEMICOLON .)
    FOR             reduce using rule 14 (class_content -> expression SEMICOLON .)
    WHILE           reduce using rule 14 (class_content -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (class_content -> expression SEMICOLON .)
    PRINT           reduce using rule 14 (class_content -> expression SEMICOLON .)
    BOOL            reduce using rule 14 (class_content -> expression SEMICOLON .)
    LIST            reduce using rule 14 (class_content -> expression SEMICOLON .)
    ASSERT          reduce using rule 14 (class_content -> expression SEMICOLON .)
    DOUBLE          reduce using rule 14 (class_content -> expression SEMICOLON .)
    DYNAMIC         reduce using rule 14 (class_content -> expression SEMICOLON .)
    VOID            reduce using rule 14 (class_content -> expression SEMICOLON .)
    VAR             reduce using rule 14 (class_content -> expression SEMICOLON .)
    MAP             reduce using rule 14 (class_content -> expression SEMICOLON .)
    IF              reduce using rule 14 (class_content -> expression SEMICOLON .)
    INTEGER         reduce using rule 14 (class_content -> expression SEMICOLON .)
    FLOAT           reduce using rule 14 (class_content -> expression SEMICOLON .)
    STR             reduce using rule 14 (class_content -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 14 (class_content -> expression SEMICOLON .)
    TRUE            reduce using rule 14 (class_content -> expression SEMICOLON .)
    FALSE           reduce using rule 14 (class_content -> expression SEMICOLON .)
    MAIN            reduce using rule 14 (class_content -> expression SEMICOLON .)
    $end            reduce using rule 14 (class_content -> expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 14 (class_content -> expression SEMICOLON .)


state 62

    (16) class_content -> CONTINUE SEMICOLON .

    CONTINUE        reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    FINAL           reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    INT             reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    PRINT           reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    LIST            reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    ASSERT          reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    DOUBLE          reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    DYNAMIC         reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    VAR             reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    MAP             reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    IF              reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    STR             reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    MAIN            reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    $end            reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)
    RCURLYBRACKET   reduce using rule 16 (class_content -> CONTINUE SEMICOLON .)


state 63

    (111) function_lambda -> datatype IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (138) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON
    (139) declarationExpression -> datatype IDENTIFIER . EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (136) repeatDeclaration -> IDENTIFIER .
    (137) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    LPAREN          shift and go to state 100
    EQUAL           shift and go to state 101
    SEMICOLON       reduce using rule 136 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 102


state 64

    (135) declarationExpression -> datatype repeatDeclaration . SEMICOLON

    SEMICOLON       shift and go to state 103


state 65

    (30) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 104


state 66

    (70) inferedReturnFunction -> IDENTIFIER LPAREN . function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (114) function_arguments_repeat -> . function_argument
    (115) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (112) function_argument -> . datatype IDENTIFIER
    (113) function_argument -> . empty
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (50) empty -> .
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 109
    STRING          shift and go to state 110
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    COMMA           reduce using rule 50 (empty -> .)
    RPAREN          reduce using rule 50 (empty -> .)
    MAP             shift and go to state 49

    function_arguments_repeat      shift and go to state 105
    function_argument              shift and go to state 106
    datatype                       shift and go to state 107
    empty                          shift and go to state 108
    map_identifier                 shift and go to state 112

state 67

    (125) asign -> IDENTIFIER EQUAL . expression SEMICOLON
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    expression                     shift and go to state 114
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 68

    (126) asign -> IDENTIFIER operatorExpression . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 115


state 69

    (165) addlistInt -> IDENTIFIER DOT . ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> IDENTIFIER DOT . ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> IDENTIFIER DOT . ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> IDENTIFIER DOT . ADD LPAREN STR RPAREN SEMICOLON
    (182) propertiesAccess -> IDENTIFIER DOT . properties
    (180) properties -> . KEYS
    (181) properties -> . VALUES

    ADD             shift and go to state 116
    KEYS            shift and go to state 118
    VALUES          shift and go to state 119

    properties                     shift and go to state 117

state 70

    (145) booloperation -> IDENTIFIER condition_connector . booleanOp
    (146) booloperation -> IDENTIFIER condition_connector . IDENTIFIER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 120
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    booleanOp                      shift and go to state 121

state 71

    (130) operatorExpression -> PLUS .

    EQUAL           reduce using rule 130 (operatorExpression -> PLUS .)
    PLUS            reduce using rule 130 (operatorExpression -> PLUS .)
    MINUS           reduce using rule 130 (operatorExpression -> PLUS .)
    TIMES           reduce using rule 130 (operatorExpression -> PLUS .)
    DIVISION        reduce using rule 130 (operatorExpression -> PLUS .)
    REST            reduce using rule 130 (operatorExpression -> PLUS .)
    INTEGER         reduce using rule 130 (operatorExpression -> PLUS .)
    FLOAT           reduce using rule 130 (operatorExpression -> PLUS .)
    STR             reduce using rule 130 (operatorExpression -> PLUS .)
    BOOLEAN         reduce using rule 130 (operatorExpression -> PLUS .)
    IDENTIFIER      reduce using rule 130 (operatorExpression -> PLUS .)
    TRUE            reduce using rule 130 (operatorExpression -> PLUS .)
    FALSE           reduce using rule 130 (operatorExpression -> PLUS .)
    SEMICOLON       reduce using rule 130 (operatorExpression -> PLUS .)
    RPAREN          reduce using rule 130 (operatorExpression -> PLUS .)


state 72

    (131) operatorExpression -> MINUS .

    EQUAL           reduce using rule 131 (operatorExpression -> MINUS .)
    PLUS            reduce using rule 131 (operatorExpression -> MINUS .)
    MINUS           reduce using rule 131 (operatorExpression -> MINUS .)
    TIMES           reduce using rule 131 (operatorExpression -> MINUS .)
    DIVISION        reduce using rule 131 (operatorExpression -> MINUS .)
    REST            reduce using rule 131 (operatorExpression -> MINUS .)
    INTEGER         reduce using rule 131 (operatorExpression -> MINUS .)
    FLOAT           reduce using rule 131 (operatorExpression -> MINUS .)
    STR             reduce using rule 131 (operatorExpression -> MINUS .)
    BOOLEAN         reduce using rule 131 (operatorExpression -> MINUS .)
    IDENTIFIER      reduce using rule 131 (operatorExpression -> MINUS .)
    TRUE            reduce using rule 131 (operatorExpression -> MINUS .)
    FALSE           reduce using rule 131 (operatorExpression -> MINUS .)
    SEMICOLON       reduce using rule 131 (operatorExpression -> MINUS .)
    RPAREN          reduce using rule 131 (operatorExpression -> MINUS .)


state 73

    (132) operatorExpression -> TIMES .

    EQUAL           reduce using rule 132 (operatorExpression -> TIMES .)
    PLUS            reduce using rule 132 (operatorExpression -> TIMES .)
    MINUS           reduce using rule 132 (operatorExpression -> TIMES .)
    TIMES           reduce using rule 132 (operatorExpression -> TIMES .)
    DIVISION        reduce using rule 132 (operatorExpression -> TIMES .)
    REST            reduce using rule 132 (operatorExpression -> TIMES .)
    INTEGER         reduce using rule 132 (operatorExpression -> TIMES .)
    FLOAT           reduce using rule 132 (operatorExpression -> TIMES .)
    STR             reduce using rule 132 (operatorExpression -> TIMES .)
    BOOLEAN         reduce using rule 132 (operatorExpression -> TIMES .)
    IDENTIFIER      reduce using rule 132 (operatorExpression -> TIMES .)
    TRUE            reduce using rule 132 (operatorExpression -> TIMES .)
    FALSE           reduce using rule 132 (operatorExpression -> TIMES .)
    SEMICOLON       reduce using rule 132 (operatorExpression -> TIMES .)
    RPAREN          reduce using rule 132 (operatorExpression -> TIMES .)


state 74

    (133) operatorExpression -> DIVISION .

    EQUAL           reduce using rule 133 (operatorExpression -> DIVISION .)
    PLUS            reduce using rule 133 (operatorExpression -> DIVISION .)
    MINUS           reduce using rule 133 (operatorExpression -> DIVISION .)
    TIMES           reduce using rule 133 (operatorExpression -> DIVISION .)
    DIVISION        reduce using rule 133 (operatorExpression -> DIVISION .)
    REST            reduce using rule 133 (operatorExpression -> DIVISION .)
    INTEGER         reduce using rule 133 (operatorExpression -> DIVISION .)
    FLOAT           reduce using rule 133 (operatorExpression -> DIVISION .)
    STR             reduce using rule 133 (operatorExpression -> DIVISION .)
    BOOLEAN         reduce using rule 133 (operatorExpression -> DIVISION .)
    IDENTIFIER      reduce using rule 133 (operatorExpression -> DIVISION .)
    TRUE            reduce using rule 133 (operatorExpression -> DIVISION .)
    FALSE           reduce using rule 133 (operatorExpression -> DIVISION .)
    SEMICOLON       reduce using rule 133 (operatorExpression -> DIVISION .)
    RPAREN          reduce using rule 133 (operatorExpression -> DIVISION .)


state 75

    (134) operatorExpression -> REST .

    EQUAL           reduce using rule 134 (operatorExpression -> REST .)
    PLUS            reduce using rule 134 (operatorExpression -> REST .)
    MINUS           reduce using rule 134 (operatorExpression -> REST .)
    TIMES           reduce using rule 134 (operatorExpression -> REST .)
    DIVISION        reduce using rule 134 (operatorExpression -> REST .)
    REST            reduce using rule 134 (operatorExpression -> REST .)
    INTEGER         reduce using rule 134 (operatorExpression -> REST .)
    FLOAT           reduce using rule 134 (operatorExpression -> REST .)
    STR             reduce using rule 134 (operatorExpression -> REST .)
    BOOLEAN         reduce using rule 134 (operatorExpression -> REST .)
    IDENTIFIER      reduce using rule 134 (operatorExpression -> REST .)
    TRUE            reduce using rule 134 (operatorExpression -> REST .)
    FALSE           reduce using rule 134 (operatorExpression -> REST .)
    SEMICOLON       reduce using rule 134 (operatorExpression -> REST .)
    RPAREN          reduce using rule 134 (operatorExpression -> REST .)


state 76

    (107) condition_connector -> AND .

    IDENTIFIER      reduce using rule 107 (condition_connector -> AND .)
    TRUE            reduce using rule 107 (condition_connector -> AND .)
    FALSE           reduce using rule 107 (condition_connector -> AND .)
    EXMARK          reduce using rule 107 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 107 (condition_connector -> AND .)
    STR             reduce using rule 107 (condition_connector -> AND .)
    FLOAT           reduce using rule 107 (condition_connector -> AND .)
    INTEGER         reduce using rule 107 (condition_connector -> AND .)


state 77

    (108) condition_connector -> OR .

    IDENTIFIER      reduce using rule 108 (condition_connector -> OR .)
    TRUE            reduce using rule 108 (condition_connector -> OR .)
    FALSE           reduce using rule 108 (condition_connector -> OR .)
    EXMARK          reduce using rule 108 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 108 (condition_connector -> OR .)
    STR             reduce using rule 108 (condition_connector -> OR .)
    FLOAT           reduce using rule 108 (condition_connector -> OR .)
    INTEGER         reduce using rule 108 (condition_connector -> OR .)


state 78

    (109) condition_connector -> AMPERSAND . AMPERSAND

    AMPERSAND       shift and go to state 122


state 79

    (110) condition_connector -> PIPELINE . PIPELINE

    PIPELINE        shift and go to state 123


state 80

    (59) ifElseStatement -> ifStatement elifStatement_repeat .

    CONTINUE        reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FINAL           reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STRING          reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INT             reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FOR             reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    WHILE           reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    PRINT           reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    LIST            reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    ASSERT          reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VAR             reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IF              reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STR             reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    TRUE            reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FALSE           reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAIN            reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    $end            reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 59 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 81

    (60) elifStatement_repeat -> elifStatement .
    (61) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (60) elifStatement_repeat -> . elifStatement
    (61) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (63) elifStatement -> . ELSE ifStatement
    (64) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    CONTINUE        reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    FINAL           reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    STRING          reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    INT             reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    FOR             reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    WHILE           reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    IDENTIFIER      reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    PRINT           reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    LIST            reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    ASSERT          reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    VAR             reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    IF              reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    INTEGER         reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    FLOAT           reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    STR             reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    BOOLEAN         reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    TRUE            reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    FALSE           reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    MAIN            reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    $end            reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    RCURLYBRACKET   reduce using rule 60 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 82

    elifStatement                  shift and go to state 81
    elifStatement_repeat           shift and go to state 124

state 82

    (63) elifStatement -> ELSE . ifStatement
    (64) elifStatement -> ELSE . LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 126
    IF              shift and go to state 50

    ifStatement                    shift and go to state 125

state 83

    (140) declarationExpression -> FINAL IDENTIFIER . EQUAL expression SEMICOLON
    (66) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> FINAL IDENTIFIER . EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    EQUAL           shift and go to state 127


state 84

    (169) declarationExpression -> STRING IDENTIFIER . EQUAL expressionString SEMICOLON
    (170) declarationExpression -> STRING IDENTIFIER . SEMICOLON

    EQUAL           shift and go to state 128
    SEMICOLON       shift and go to state 129


state 85

    (174) declarationExpression -> INT IDENTIFIER . EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> INT IDENTIFIER . SEMICOLON

    EQUAL           shift and go to state 130
    SEMICOLON       shift and go to state 131


state 86

    (65) forStatement -> FOR LPAREN . declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    FINAL           shift and go to state 134
    STRING          shift and go to state 31
    INT             shift and go to state 32
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    MAP             shift and go to state 49

    declarationExpression          shift and go to state 132
    datatype                       shift and go to state 133
    map_identifier                 shift and go to state 112

state 87

    (67) while -> WHILE LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (105) conditions -> . condition
    (106) conditions -> . condition condition_connector conditions
    (98) condition -> . IDENTIFIER condition_operator condition_values
    (99) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (100) condition -> . BOOLEAN condition_operator BOOLEAN
    (101) condition -> . number condition_operator number
    (102) condition -> . STR condition_operator STR
    (103) condition -> . booleanOp condition_operator booleanOp
    (104) condition -> . negation_values
    (96) number -> . FLOAT
    (97) number -> . INTEGER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (83) negation_values -> . deniable_values
    (84) negation_values -> . EXMARK deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 137
    EXMARK          shift and go to state 138
    BOOLEAN         shift and go to state 139
    STR             shift and go to state 141
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    conditions                     shift and go to state 135
    condition                      shift and go to state 136
    number                         shift and go to state 140
    booleanOp                      shift and go to state 142
    negation_values                shift and go to state 143
    deniable_values                shift and go to state 146

state 88

    (122) expression -> value operatorExpression . expression
    (123) expression -> value operatorExpression . operatorExpression
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (130) operatorExpression -> . PLUS
    (131) operatorExpression -> . MINUS
    (132) operatorExpression -> . TIMES
    (133) operatorExpression -> . DIVISION
    (134) operatorExpression -> . REST
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVISION        shift and go to state 74
    REST            shift and go to state 75
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 35
    operatorExpression             shift and go to state 147
    expression                     shift and go to state 148
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 89

    (49) print -> PRINT LPAREN . value RPAREN SEMICOLON
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 150
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 149
    booleanOp                      shift and go to state 151
    propertiesAccess               shift and go to state 52

state 90

    (141) semanticbool -> BOOL IDENTIFIER . EQUAL conditions SEMICOLON

    EQUAL           shift and go to state 152


state 91

    (150) semanticlist -> LIST LESSTHAN . DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> LIST LESSTHAN . INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> LIST LESSTHAN . STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> LIST LESSTHAN . BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> LIST LESSTHAN . DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    DYNAMIC         shift and go to state 153
    INT             shift and go to state 154
    STRING          shift and go to state 155
    BOOL            shift and go to state 156
    DOUBLE          shift and go to state 157


state 92

    (144) booloperation -> booleanOp condition_connector . booleanOp
    (147) booloperation -> booleanOp condition_connector . IDENTIFIER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 159
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    booleanOp                      shift and go to state 158

state 93

    (127) assert -> ASSERT LPAREN . conditions RPAREN SEMICOLON
    (105) conditions -> . condition
    (106) conditions -> . condition condition_connector conditions
    (98) condition -> . IDENTIFIER condition_operator condition_values
    (99) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (100) condition -> . BOOLEAN condition_operator BOOLEAN
    (101) condition -> . number condition_operator number
    (102) condition -> . STR condition_operator STR
    (103) condition -> . booleanOp condition_operator booleanOp
    (104) condition -> . negation_values
    (96) number -> . FLOAT
    (97) number -> . INTEGER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (83) negation_values -> . deniable_values
    (84) negation_values -> . EXMARK deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 137
    EXMARK          shift and go to state 138
    BOOLEAN         shift and go to state 139
    STR             shift and go to state 141
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    conditions                     shift and go to state 160
    condition                      shift and go to state 136
    number                         shift and go to state 140
    booleanOp                      shift and go to state 142
    negation_values                shift and go to state 143
    deniable_values                shift and go to state 146

state 94

    (32) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 32 (map_identifier -> MAP map_type_specified .)
    MAIN            reduce using rule 32 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 32 (map_identifier -> MAP map_type_specified .)
    RPAREN          reduce using rule 32 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 32 (map_identifier -> MAP map_type_specified .)


state 95

    (33) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 109
    STRING          shift and go to state 110
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    MAP             shift and go to state 49

    datatype                       shift and go to state 161
    map_identifier                 shift and go to state 112

state 96

    (62) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (105) conditions -> . condition
    (106) conditions -> . condition condition_connector conditions
    (98) condition -> . IDENTIFIER condition_operator condition_values
    (99) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (100) condition -> . BOOLEAN condition_operator BOOLEAN
    (101) condition -> . number condition_operator number
    (102) condition -> . STR condition_operator STR
    (103) condition -> . booleanOp condition_operator booleanOp
    (104) condition -> . negation_values
    (96) number -> . FLOAT
    (97) number -> . INTEGER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (83) negation_values -> . deniable_values
    (84) negation_values -> . EXMARK deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 137
    EXMARK          shift and go to state 138
    BOOLEAN         shift and go to state 139
    STR             shift and go to state 141
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    conditions                     shift and go to state 162
    condition                      shift and go to state 136
    number                         shift and go to state 140
    booleanOp                      shift and go to state 142
    negation_values                shift and go to state 143
    deniable_values                shift and go to state 146

state 97

    (149) booloperations -> booloperation condition_connector . booloperations
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 165
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    booloperation                  shift and go to state 53
    booloperations                 shift and go to state 163
    booleanOp                      shift and go to state 164

state 98

    (4) class -> class_content_repeat declarationMain class_content_repeat .
    (18) class_content_repeat -> class_content_repeat . class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    $end            reduce using rule 4 (class -> class_content_repeat declarationMain class_content_repeat .)
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content                  shift and go to state 57
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 99

    (19) declarationMain -> datatypeOpt MAIN LPAREN . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 166


state 100

    (111) function_lambda -> datatype IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (114) function_arguments_repeat -> . function_argument
    (115) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (112) function_argument -> . datatype IDENTIFIER
    (113) function_argument -> . empty
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (50) empty -> .
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 109
    STRING          shift and go to state 110
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    COMMA           reduce using rule 50 (empty -> .)
    LCURLYBRACKET   reduce using rule 50 (empty -> .)
    RPAREN          reduce using rule 50 (empty -> .)
    MAP             shift and go to state 49

    datatype                       shift and go to state 107
    function_arguments_repeat      shift and go to state 167
    function_argument              shift and go to state 106
    empty                          shift and go to state 108
    map_identifier                 shift and go to state 112

state 101

    (138) declarationExpression -> datatype IDENTIFIER EQUAL . expression SEMICOLON
    (139) declarationExpression -> datatype IDENTIFIER EQUAL . LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    LPAREN          shift and go to state 169
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    expression                     shift and go to state 168
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 102

    (137) repeatDeclaration -> IDENTIFIER COMMA . repeatDeclaration
    (136) repeatDeclaration -> . IDENTIFIER
    (137) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 170

    repeatDeclaration              shift and go to state 171

state 103

    (135) declarationExpression -> datatype repeatDeclaration SEMICOLON .

    CONTINUE        reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FINAL           reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    STRING          reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    INT             reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FOR             reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    WHILE           reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    IDENTIFIER      reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    PRINT           reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    BOOL            reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    LIST            reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    ASSERT          reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    DOUBLE          reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    DYNAMIC         reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    VOID            reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    VAR             reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    MAP             reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    IF              reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    INTEGER         reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FLOAT           reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    STR             reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    BOOLEAN         reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    TRUE            reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FALSE           reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    MAIN            reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    $end            reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    SEMICOLON       reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    RCURLYBRACKET   reduce using rule 135 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)


state 104

    (30) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 172


state 105

    (70) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat . RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    RPAREN          shift and go to state 173


state 106

    (114) function_arguments_repeat -> function_argument .
    (115) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    RPAREN          reduce using rule 114 (function_arguments_repeat -> function_argument .)
    LCURLYBRACKET   reduce using rule 114 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 174


state 107

    (112) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 175


state 108

    (113) function_argument -> empty .

    COMMA           reduce using rule 113 (function_argument -> empty .)
    RPAREN          reduce using rule 113 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 113 (function_argument -> empty .)


state 109

    (34) datatype -> INT .

    IDENTIFIER      reduce using rule 34 (datatype -> INT .)
    COMMA           reduce using rule 34 (datatype -> INT .)
    RPAREN          reduce using rule 34 (datatype -> INT .)
    GREATERTHAN     reduce using rule 34 (datatype -> INT .)


state 110

    (35) datatype -> STRING .

    IDENTIFIER      reduce using rule 35 (datatype -> STRING .)
    COMMA           reduce using rule 35 (datatype -> STRING .)
    RPAREN          reduce using rule 35 (datatype -> STRING .)
    GREATERTHAN     reduce using rule 35 (datatype -> STRING .)


state 111

    (36) datatype -> BOOL .

    IDENTIFIER      reduce using rule 36 (datatype -> BOOL .)
    COMMA           reduce using rule 36 (datatype -> BOOL .)
    RPAREN          reduce using rule 36 (datatype -> BOOL .)
    GREATERTHAN     reduce using rule 36 (datatype -> BOOL .)


state 112

    (40) datatype -> map_identifier .

    IDENTIFIER      reduce using rule 40 (datatype -> map_identifier .)
    COMMA           reduce using rule 40 (datatype -> map_identifier .)
    RPAREN          reduce using rule 40 (datatype -> map_identifier .)
    GREATERTHAN     reduce using rule 40 (datatype -> map_identifier .)


state 113

    (75) value -> IDENTIFIER .
    (182) propertiesAccess -> IDENTIFIER . DOT properties
    (145) booloperation -> IDENTIFIER . condition_connector booleanOp
    (146) booloperation -> IDENTIFIER . condition_connector IDENTIFIER
    (107) condition_connector -> . AND
    (108) condition_connector -> . OR
    (109) condition_connector -> . AMPERSAND AMPERSAND
    (110) condition_connector -> . PIPELINE PIPELINE

    PLUS            reduce using rule 75 (value -> IDENTIFIER .)
    MINUS           reduce using rule 75 (value -> IDENTIFIER .)
    TIMES           reduce using rule 75 (value -> IDENTIFIER .)
    DIVISION        reduce using rule 75 (value -> IDENTIFIER .)
    REST            reduce using rule 75 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 75 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 75 (value -> IDENTIFIER .)
    DOT             shift and go to state 176
    AND             shift and go to state 76
    OR              shift and go to state 77
    AMPERSAND       shift and go to state 78
    PIPELINE        shift and go to state 79

    condition_connector            shift and go to state 70

state 114

    (125) asign -> IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 177


state 115

    (126) asign -> IDENTIFIER operatorExpression EQUAL . expression SEMICOLON
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    expression                     shift and go to state 178
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 116

    (165) addlistInt -> IDENTIFIER DOT ADD . LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> IDENTIFIER DOT ADD . LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> IDENTIFIER DOT ADD . LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> IDENTIFIER DOT ADD . LPAREN STR RPAREN SEMICOLON

    LPAREN          shift and go to state 179


state 117

    (182) propertiesAccess -> IDENTIFIER DOT properties .

    PLUS            reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    MINUS           reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    TIMES           reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    DIVISION        reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    REST            reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    SEMICOLON       reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    RPAREN          reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    COLON           reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    COMMA           reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    RCURLYBRACKET   reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)
    RSQUAREBRACKET  reduce using rule 182 (propertiesAccess -> IDENTIFIER DOT properties .)


state 118

    (180) properties -> KEYS .

    PLUS            reduce using rule 180 (properties -> KEYS .)
    MINUS           reduce using rule 180 (properties -> KEYS .)
    TIMES           reduce using rule 180 (properties -> KEYS .)
    DIVISION        reduce using rule 180 (properties -> KEYS .)
    REST            reduce using rule 180 (properties -> KEYS .)
    SEMICOLON       reduce using rule 180 (properties -> KEYS .)
    RPAREN          reduce using rule 180 (properties -> KEYS .)
    COLON           reduce using rule 180 (properties -> KEYS .)
    COMMA           reduce using rule 180 (properties -> KEYS .)
    RCURLYBRACKET   reduce using rule 180 (properties -> KEYS .)
    RSQUAREBRACKET  reduce using rule 180 (properties -> KEYS .)


state 119

    (181) properties -> VALUES .

    PLUS            reduce using rule 181 (properties -> VALUES .)
    MINUS           reduce using rule 181 (properties -> VALUES .)
    TIMES           reduce using rule 181 (properties -> VALUES .)
    DIVISION        reduce using rule 181 (properties -> VALUES .)
    REST            reduce using rule 181 (properties -> VALUES .)
    SEMICOLON       reduce using rule 181 (properties -> VALUES .)
    RPAREN          reduce using rule 181 (properties -> VALUES .)
    COLON           reduce using rule 181 (properties -> VALUES .)
    COMMA           reduce using rule 181 (properties -> VALUES .)
    RCURLYBRACKET   reduce using rule 181 (properties -> VALUES .)
    RSQUAREBRACKET  reduce using rule 181 (properties -> VALUES .)


state 120

    (146) booloperation -> IDENTIFIER condition_connector IDENTIFIER .

    AND             reduce using rule 146 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    OR              reduce using rule 146 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    AMPERSAND       reduce using rule 146 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    PIPELINE        reduce using rule 146 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    SEMICOLON       reduce using rule 146 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    RPAREN          reduce using rule 146 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)


state 121

    (145) booloperation -> IDENTIFIER condition_connector booleanOp .

    AND             reduce using rule 145 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    OR              reduce using rule 145 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    AMPERSAND       reduce using rule 145 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    PIPELINE        reduce using rule 145 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    SEMICOLON       reduce using rule 145 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    RPAREN          reduce using rule 145 (booloperation -> IDENTIFIER condition_connector booleanOp .)


state 122

    (109) condition_connector -> AMPERSAND AMPERSAND .

    IDENTIFIER      reduce using rule 109 (condition_connector -> AMPERSAND AMPERSAND .)
    TRUE            reduce using rule 109 (condition_connector -> AMPERSAND AMPERSAND .)
    FALSE           reduce using rule 109 (condition_connector -> AMPERSAND AMPERSAND .)
    EXMARK          reduce using rule 109 (condition_connector -> AMPERSAND AMPERSAND .)
    BOOLEAN         reduce using rule 109 (condition_connector -> AMPERSAND AMPERSAND .)
    STR             reduce using rule 109 (condition_connector -> AMPERSAND AMPERSAND .)
    FLOAT           reduce using rule 109 (condition_connector -> AMPERSAND AMPERSAND .)
    INTEGER         reduce using rule 109 (condition_connector -> AMPERSAND AMPERSAND .)


state 123

    (110) condition_connector -> PIPELINE PIPELINE .

    IDENTIFIER      reduce using rule 110 (condition_connector -> PIPELINE PIPELINE .)
    TRUE            reduce using rule 110 (condition_connector -> PIPELINE PIPELINE .)
    FALSE           reduce using rule 110 (condition_connector -> PIPELINE PIPELINE .)
    EXMARK          reduce using rule 110 (condition_connector -> PIPELINE PIPELINE .)
    BOOLEAN         reduce using rule 110 (condition_connector -> PIPELINE PIPELINE .)
    STR             reduce using rule 110 (condition_connector -> PIPELINE PIPELINE .)
    FLOAT           reduce using rule 110 (condition_connector -> PIPELINE PIPELINE .)
    INTEGER         reduce using rule 110 (condition_connector -> PIPELINE PIPELINE .)


state 124

    (61) elifStatement_repeat -> elifStatement elifStatement_repeat .

    CONTINUE        reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FINAL           reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STRING          reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INT             reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FOR             reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    WHILE           reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    PRINT           reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    LIST            reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    ASSERT          reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VAR             reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IF              reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STR             reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    TRUE            reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FALSE           reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAIN            reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    $end            reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 61 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 125

    (63) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    CONTINUE        reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    FINAL           reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    FOR             reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    WHILE           reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    IDENTIFIER      reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    PRINT           reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    LIST            reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    ASSERT          reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    VAR             reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    IF              reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    INTEGER         reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    FLOAT           reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    STR             reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    BOOLEAN         reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    TRUE            reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    FALSE           reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    MAIN            reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    $end            reduce using rule 63 (elifStatement -> ELSE ifStatement .)
    RCURLYBRACKET   reduce using rule 63 (elifStatement -> ELSE ifStatement .)


state 126

    (64) elifStatement -> ELSE LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (17) class_content_repeat -> . class_content
    (18) class_content_repeat -> . class_content_repeat class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content_repeat           shift and go to state 180
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 127

    (140) declarationExpression -> FINAL IDENTIFIER EQUAL . expression SEMICOLON
    (66) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> FINAL IDENTIFIER EQUAL . STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    STACK           shift and go to state 182
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    expression                     shift and go to state 181
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 128

    (169) declarationExpression -> STRING IDENTIFIER EQUAL . expressionString SEMICOLON
    (171) expressionString -> . STR
    (172) expressionString -> . STR operatorExpressionString expressionString

    STR             shift and go to state 184

    expressionString               shift and go to state 183

state 129

    (170) declarationExpression -> STRING IDENTIFIER SEMICOLON .

    CONTINUE        reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FINAL           reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    INT             reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    ASSERT          reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    IF              reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    STR             reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    MAIN            reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    $end            reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 170 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)


state 130

    (174) declarationExpression -> INT IDENTIFIER EQUAL . expressionInteger SEMICOLON
    (176) expressionInteger -> . number
    (177) expressionInteger -> . number operatorExpression expressionInteger
    (178) expressionInteger -> . IDENTIFIER
    (179) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (96) number -> . FLOAT
    (97) number -> . INTEGER

    IDENTIFIER      shift and go to state 185
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145

    expressionInteger              shift and go to state 186
    number                         shift and go to state 187

state 131

    (175) declarationExpression -> INT IDENTIFIER SEMICOLON .

    CONTINUE        reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FINAL           reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    INT             reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    ASSERT          reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    IF              reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    STR             reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    MAIN            reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    $end            reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 175 (declarationExpression -> INT IDENTIFIER SEMICOLON .)


state 132

    (65) forStatement -> FOR LPAREN declarationExpression . SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 188


state 133

    (135) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (138) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> datatype . IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (136) repeatDeclaration -> . IDENTIFIER
    (137) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 189

    repeatDeclaration              shift and go to state 64

state 134

    (140) declarationExpression -> FINAL . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 190


state 135

    (67) while -> WHILE LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 191


state 136

    (105) conditions -> condition .
    (106) conditions -> condition . condition_connector conditions
    (107) condition_connector -> . AND
    (108) condition_connector -> . OR
    (109) condition_connector -> . AMPERSAND AMPERSAND
    (110) condition_connector -> . PIPELINE PIPELINE

    RPAREN          reduce using rule 105 (conditions -> condition .)
    SEMICOLON       reduce using rule 105 (conditions -> condition .)
    AND             shift and go to state 76
    OR              shift and go to state 77
    AMPERSAND       shift and go to state 78
    PIPELINE        shift and go to state 79

    condition_connector            shift and go to state 192

state 137

    (98) condition -> IDENTIFIER . condition_operator condition_values
    (80) deniable_values -> IDENTIFIER .
    (90) condition_operator -> . DOUBLEQUAL
    (91) condition_operator -> . LESSTHAN
    (92) condition_operator -> . GREATERTHAN
    (93) condition_operator -> . LESSTHAN EQUAL
    (94) condition_operator -> . GREATERTHAN EQUAL
    (95) condition_operator -> . EXMARK EQUAL

    AND             reduce using rule 80 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 80 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 80 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 80 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 80 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 80 (deniable_values -> IDENTIFIER .)
    DOUBLEQUAL      shift and go to state 194
    LESSTHAN        shift and go to state 195
    GREATERTHAN     shift and go to state 196
    EXMARK          shift and go to state 197

    condition_operator             shift and go to state 193

state 138

    (99) condition -> EXMARK . IDENTIFIER condition_operator condition_values
    (84) negation_values -> EXMARK . deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 198
    BOOLEAN         shift and go to state 200
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    deniable_values                shift and go to state 199
    booleanOp                      shift and go to state 201

state 139

    (100) condition -> BOOLEAN . condition_operator BOOLEAN
    (81) deniable_values -> BOOLEAN .
    (90) condition_operator -> . DOUBLEQUAL
    (91) condition_operator -> . LESSTHAN
    (92) condition_operator -> . GREATERTHAN
    (93) condition_operator -> . LESSTHAN EQUAL
    (94) condition_operator -> . GREATERTHAN EQUAL
    (95) condition_operator -> . EXMARK EQUAL

    AND             reduce using rule 81 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 81 (deniable_values -> BOOLEAN .)
    AMPERSAND       reduce using rule 81 (deniable_values -> BOOLEAN .)
    PIPELINE        reduce using rule 81 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 81 (deniable_values -> BOOLEAN .)
    SEMICOLON       reduce using rule 81 (deniable_values -> BOOLEAN .)
    DOUBLEQUAL      shift and go to state 194
    LESSTHAN        shift and go to state 195
    GREATERTHAN     shift and go to state 196
    EXMARK          shift and go to state 197

    condition_operator             shift and go to state 202

state 140

    (101) condition -> number . condition_operator number
    (90) condition_operator -> . DOUBLEQUAL
    (91) condition_operator -> . LESSTHAN
    (92) condition_operator -> . GREATERTHAN
    (93) condition_operator -> . LESSTHAN EQUAL
    (94) condition_operator -> . GREATERTHAN EQUAL
    (95) condition_operator -> . EXMARK EQUAL

    DOUBLEQUAL      shift and go to state 194
    LESSTHAN        shift and go to state 195
    GREATERTHAN     shift and go to state 196
    EXMARK          shift and go to state 197

    condition_operator             shift and go to state 203

state 141

    (102) condition -> STR . condition_operator STR
    (90) condition_operator -> . DOUBLEQUAL
    (91) condition_operator -> . LESSTHAN
    (92) condition_operator -> . GREATERTHAN
    (93) condition_operator -> . LESSTHAN EQUAL
    (94) condition_operator -> . GREATERTHAN EQUAL
    (95) condition_operator -> . EXMARK EQUAL

    DOUBLEQUAL      shift and go to state 194
    LESSTHAN        shift and go to state 195
    GREATERTHAN     shift and go to state 196
    EXMARK          shift and go to state 197

    condition_operator             shift and go to state 204

state 142

    (103) condition -> booleanOp . condition_operator booleanOp
    (82) deniable_values -> booleanOp .
    (90) condition_operator -> . DOUBLEQUAL
    (91) condition_operator -> . LESSTHAN
    (92) condition_operator -> . GREATERTHAN
    (93) condition_operator -> . LESSTHAN EQUAL
    (94) condition_operator -> . GREATERTHAN EQUAL
    (95) condition_operator -> . EXMARK EQUAL

    AND             reduce using rule 82 (deniable_values -> booleanOp .)
    OR              reduce using rule 82 (deniable_values -> booleanOp .)
    AMPERSAND       reduce using rule 82 (deniable_values -> booleanOp .)
    PIPELINE        reduce using rule 82 (deniable_values -> booleanOp .)
    RPAREN          reduce using rule 82 (deniable_values -> booleanOp .)
    SEMICOLON       reduce using rule 82 (deniable_values -> booleanOp .)
    DOUBLEQUAL      shift and go to state 194
    LESSTHAN        shift and go to state 195
    GREATERTHAN     shift and go to state 196
    EXMARK          shift and go to state 197

    condition_operator             shift and go to state 205

state 143

    (104) condition -> negation_values .

    AND             reduce using rule 104 (condition -> negation_values .)
    OR              reduce using rule 104 (condition -> negation_values .)
    AMPERSAND       reduce using rule 104 (condition -> negation_values .)
    PIPELINE        reduce using rule 104 (condition -> negation_values .)
    RPAREN          reduce using rule 104 (condition -> negation_values .)
    SEMICOLON       reduce using rule 104 (condition -> negation_values .)


state 144

    (96) number -> FLOAT .

    DOUBLEQUAL      reduce using rule 96 (number -> FLOAT .)
    LESSTHAN        reduce using rule 96 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 96 (number -> FLOAT .)
    EXMARK          reduce using rule 96 (number -> FLOAT .)
    PLUS            reduce using rule 96 (number -> FLOAT .)
    MINUS           reduce using rule 96 (number -> FLOAT .)
    TIMES           reduce using rule 96 (number -> FLOAT .)
    DIVISION        reduce using rule 96 (number -> FLOAT .)
    REST            reduce using rule 96 (number -> FLOAT .)
    SEMICOLON       reduce using rule 96 (number -> FLOAT .)
    AND             reduce using rule 96 (number -> FLOAT .)
    OR              reduce using rule 96 (number -> FLOAT .)
    AMPERSAND       reduce using rule 96 (number -> FLOAT .)
    PIPELINE        reduce using rule 96 (number -> FLOAT .)
    RPAREN          reduce using rule 96 (number -> FLOAT .)


state 145

    (97) number -> INTEGER .

    DOUBLEQUAL      reduce using rule 97 (number -> INTEGER .)
    LESSTHAN        reduce using rule 97 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 97 (number -> INTEGER .)
    EXMARK          reduce using rule 97 (number -> INTEGER .)
    PLUS            reduce using rule 97 (number -> INTEGER .)
    MINUS           reduce using rule 97 (number -> INTEGER .)
    TIMES           reduce using rule 97 (number -> INTEGER .)
    DIVISION        reduce using rule 97 (number -> INTEGER .)
    REST            reduce using rule 97 (number -> INTEGER .)
    SEMICOLON       reduce using rule 97 (number -> INTEGER .)
    AND             reduce using rule 97 (number -> INTEGER .)
    OR              reduce using rule 97 (number -> INTEGER .)
    AMPERSAND       reduce using rule 97 (number -> INTEGER .)
    PIPELINE        reduce using rule 97 (number -> INTEGER .)
    RPAREN          reduce using rule 97 (number -> INTEGER .)


state 146

    (83) negation_values -> deniable_values .

    AND             reduce using rule 83 (negation_values -> deniable_values .)
    OR              reduce using rule 83 (negation_values -> deniable_values .)
    AMPERSAND       reduce using rule 83 (negation_values -> deniable_values .)
    PIPELINE        reduce using rule 83 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 83 (negation_values -> deniable_values .)
    SEMICOLON       reduce using rule 83 (negation_values -> deniable_values .)


state 147

    (123) expression -> value operatorExpression operatorExpression .

    SEMICOLON       reduce using rule 123 (expression -> value operatorExpression operatorExpression .)
    RPAREN          reduce using rule 123 (expression -> value operatorExpression operatorExpression .)


state 148

    (122) expression -> value operatorExpression expression .

    SEMICOLON       reduce using rule 122 (expression -> value operatorExpression expression .)
    RPAREN          reduce using rule 122 (expression -> value operatorExpression expression .)


state 149

    (49) print -> PRINT LPAREN value . RPAREN SEMICOLON

    RPAREN          shift and go to state 206


state 150

    (75) value -> IDENTIFIER .
    (182) propertiesAccess -> IDENTIFIER . DOT properties

    RPAREN          reduce using rule 75 (value -> IDENTIFIER .)
    COLON           reduce using rule 75 (value -> IDENTIFIER .)
    COMMA           reduce using rule 75 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 75 (value -> IDENTIFIER .)
    RSQUAREBRACKET  reduce using rule 75 (value -> IDENTIFIER .)
    DOT             shift and go to state 176


state 151

    (76) value -> booleanOp .

    RPAREN          reduce using rule 76 (value -> booleanOp .)
    COLON           reduce using rule 76 (value -> booleanOp .)
    COMMA           reduce using rule 76 (value -> booleanOp .)
    RCURLYBRACKET   reduce using rule 76 (value -> booleanOp .)
    RSQUAREBRACKET  reduce using rule 76 (value -> booleanOp .)


state 152

    (141) semanticbool -> BOOL IDENTIFIER EQUAL . conditions SEMICOLON
    (105) conditions -> . condition
    (106) conditions -> . condition condition_connector conditions
    (98) condition -> . IDENTIFIER condition_operator condition_values
    (99) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (100) condition -> . BOOLEAN condition_operator BOOLEAN
    (101) condition -> . number condition_operator number
    (102) condition -> . STR condition_operator STR
    (103) condition -> . booleanOp condition_operator booleanOp
    (104) condition -> . negation_values
    (96) number -> . FLOAT
    (97) number -> . INTEGER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (83) negation_values -> . deniable_values
    (84) negation_values -> . EXMARK deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 137
    EXMARK          shift and go to state 138
    BOOLEAN         shift and go to state 139
    STR             shift and go to state 141
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    conditions                     shift and go to state 207
    condition                      shift and go to state 136
    number                         shift and go to state 140
    booleanOp                      shift and go to state 142
    negation_values                shift and go to state 143
    deniable_values                shift and go to state 146

state 153

    (150) semanticlist -> LIST LESSTHAN DYNAMIC . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 208


state 154

    (151) semanticlist -> LIST LESSTHAN INT . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 209


state 155

    (152) semanticlist -> LIST LESSTHAN STRING . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 210


state 156

    (153) semanticlist -> LIST LESSTHAN BOOL . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 211


state 157

    (154) semanticlist -> LIST LESSTHAN DOUBLE . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 212


state 158

    (144) booloperation -> booleanOp condition_connector booleanOp .

    AND             reduce using rule 144 (booloperation -> booleanOp condition_connector booleanOp .)
    OR              reduce using rule 144 (booloperation -> booleanOp condition_connector booleanOp .)
    AMPERSAND       reduce using rule 144 (booloperation -> booleanOp condition_connector booleanOp .)
    PIPELINE        reduce using rule 144 (booloperation -> booleanOp condition_connector booleanOp .)
    SEMICOLON       reduce using rule 144 (booloperation -> booleanOp condition_connector booleanOp .)
    RPAREN          reduce using rule 144 (booloperation -> booleanOp condition_connector booleanOp .)


state 159

    (147) booloperation -> booleanOp condition_connector IDENTIFIER .

    AND             reduce using rule 147 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    OR              reduce using rule 147 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    AMPERSAND       reduce using rule 147 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    PIPELINE        reduce using rule 147 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    SEMICOLON       reduce using rule 147 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    RPAREN          reduce using rule 147 (booloperation -> booleanOp condition_connector IDENTIFIER .)


state 160

    (127) assert -> ASSERT LPAREN conditions . RPAREN SEMICOLON

    RPAREN          shift and go to state 213


state 161

    (33) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 214


state 162

    (62) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 215


state 163

    (149) booloperations -> booloperation condition_connector booloperations .

    SEMICOLON       reduce using rule 149 (booloperations -> booloperation condition_connector booloperations .)
    RPAREN          reduce using rule 149 (booloperations -> booloperation condition_connector booloperations .)


state 164

    (144) booloperation -> booleanOp . condition_connector booleanOp
    (147) booloperation -> booleanOp . condition_connector IDENTIFIER
    (107) condition_connector -> . AND
    (108) condition_connector -> . OR
    (109) condition_connector -> . AMPERSAND AMPERSAND
    (110) condition_connector -> . PIPELINE PIPELINE

    AND             shift and go to state 76
    OR              shift and go to state 77
    AMPERSAND       shift and go to state 78
    PIPELINE        shift and go to state 79

    condition_connector            shift and go to state 92

state 165

    (145) booloperation -> IDENTIFIER . condition_connector booleanOp
    (146) booloperation -> IDENTIFIER . condition_connector IDENTIFIER
    (107) condition_connector -> . AND
    (108) condition_connector -> . OR
    (109) condition_connector -> . AMPERSAND AMPERSAND
    (110) condition_connector -> . PIPELINE PIPELINE

    AND             shift and go to state 76
    OR              shift and go to state 77
    AMPERSAND       shift and go to state 78
    PIPELINE        shift and go to state 79

    condition_connector            shift and go to state 70

state 166

    (19) declarationMain -> datatypeOpt MAIN LPAREN RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 216


state 167

    (111) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (116) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (117) optFunction_argumentsExpression -> . empty
    (50) empty -> .

    LCURLYBRACKET   shift and go to state 218
    RPAREN          reduce using rule 50 (empty -> .)

    optFunction_argumentsExpression shift and go to state 217
    empty                          shift and go to state 219

state 168

    (138) declarationExpression -> datatype IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 220


state 169

    (139) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN . datatype RPAREN IDENTIFIER SEMICOLON
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 109
    STRING          shift and go to state 110
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    MAP             shift and go to state 49

    datatype                       shift and go to state 221
    map_identifier                 shift and go to state 112

state 170

    (136) repeatDeclaration -> IDENTIFIER .
    (137) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    SEMICOLON       reduce using rule 136 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 102


state 171

    (137) repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration .

    SEMICOLON       reduce using rule 137 (repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration .)


state 172

    (30) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (51) map_content -> . map_pairs
    (52) map_content -> . empty
    (54) map_pairs -> . map_pair
    (55) map_pairs -> . map_pair COMMA map_pairs
    (50) empty -> .
    (53) map_pair -> . map_key COLON map_value
    (56) map_key -> . value
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   reduce using rule 50 (empty -> .)
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 150
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    map_content                    shift and go to state 222
    map_pairs                      shift and go to state 223
    empty                          shift and go to state 224
    map_pair                       shift and go to state 225
    map_key                        shift and go to state 226
    value                          shift and go to state 227
    booleanOp                      shift and go to state 151
    propertiesAccess               shift and go to state 52

state 173

    (70) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN . LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 228


state 174

    (115) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (114) function_arguments_repeat -> . function_argument
    (115) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (112) function_argument -> . datatype IDENTIFIER
    (113) function_argument -> . empty
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (50) empty -> .
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 109
    STRING          shift and go to state 110
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    COMMA           reduce using rule 50 (empty -> .)
    RPAREN          reduce using rule 50 (empty -> .)
    LCURLYBRACKET   reduce using rule 50 (empty -> .)
    MAP             shift and go to state 49

    function_argument              shift and go to state 106
    function_arguments_repeat      shift and go to state 229
    datatype                       shift and go to state 107
    empty                          shift and go to state 108
    map_identifier                 shift and go to state 112

state 175

    (112) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 112 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 112 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 112 (function_argument -> datatype IDENTIFIER .)


state 176

    (182) propertiesAccess -> IDENTIFIER DOT . properties
    (180) properties -> . KEYS
    (181) properties -> . VALUES

    KEYS            shift and go to state 118
    VALUES          shift and go to state 119

    properties                     shift and go to state 117

state 177

    (125) asign -> IDENTIFIER EQUAL expression SEMICOLON .

    CONTINUE        reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    ASSERT          reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 125 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)


state 178

    (126) asign -> IDENTIFIER operatorExpression EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 230


state 179

    (165) addlistInt -> IDENTIFIER DOT ADD LPAREN . INTEGER RPAREN SEMICOLON
    (167) addlistBool -> IDENTIFIER DOT ADD LPAREN . booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> IDENTIFIER DOT ADD LPAREN . FLOAT RPAREN SEMICOLON
    (166) addlistStr -> IDENTIFIER DOT ADD LPAREN . STR RPAREN SEMICOLON
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    INTEGER         shift and go to state 231
    FLOAT           shift and go to state 233
    STR             shift and go to state 234
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    booleanOp                      shift and go to state 232

state 180

    (64) elifStatement -> ELSE LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (18) class_content_repeat -> class_content_repeat . class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    RCURLYBRACKET   shift and go to state 235
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content                  shift and go to state 57
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 181

    (140) declarationExpression -> FINAL IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 236


state 182

    (66) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> FINAL IDENTIFIER EQUAL STACK . DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    LESSTHAN        shift and go to state 237
    DOT             shift and go to state 238


state 183

    (169) declarationExpression -> STRING IDENTIFIER EQUAL expressionString . SEMICOLON

    SEMICOLON       shift and go to state 239


state 184

    (171) expressionString -> STR .
    (172) expressionString -> STR . operatorExpressionString expressionString
    (173) operatorExpressionString -> . PLUS

    SEMICOLON       reduce using rule 171 (expressionString -> STR .)
    PLUS            shift and go to state 241

    operatorExpressionString       shift and go to state 240

state 185

    (178) expressionInteger -> IDENTIFIER .
    (179) expressionInteger -> IDENTIFIER . operatorExpression expressionInteger
    (130) operatorExpression -> . PLUS
    (131) operatorExpression -> . MINUS
    (132) operatorExpression -> . TIMES
    (133) operatorExpression -> . DIVISION
    (134) operatorExpression -> . REST

    SEMICOLON       reduce using rule 178 (expressionInteger -> IDENTIFIER .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVISION        shift and go to state 74
    REST            shift and go to state 75

    operatorExpression             shift and go to state 242

state 186

    (174) declarationExpression -> INT IDENTIFIER EQUAL expressionInteger . SEMICOLON

    SEMICOLON       shift and go to state 243


state 187

    (176) expressionInteger -> number .
    (177) expressionInteger -> number . operatorExpression expressionInteger
    (130) operatorExpression -> . PLUS
    (131) operatorExpression -> . MINUS
    (132) operatorExpression -> . TIMES
    (133) operatorExpression -> . DIVISION
    (134) operatorExpression -> . REST

    SEMICOLON       reduce using rule 176 (expressionInteger -> number .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVISION        shift and go to state 74
    REST            shift and go to state 75

    operatorExpression             shift and go to state 244

state 188

    (65) forStatement -> FOR LPAREN declarationExpression SEMICOLON . condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (98) condition -> . IDENTIFIER condition_operator condition_values
    (99) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (100) condition -> . BOOLEAN condition_operator BOOLEAN
    (101) condition -> . number condition_operator number
    (102) condition -> . STR condition_operator STR
    (103) condition -> . booleanOp condition_operator booleanOp
    (104) condition -> . negation_values
    (96) number -> . FLOAT
    (97) number -> . INTEGER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (83) negation_values -> . deniable_values
    (84) negation_values -> . EXMARK deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 137
    EXMARK          shift and go to state 138
    BOOLEAN         shift and go to state 139
    STR             shift and go to state 141
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    condition                      shift and go to state 245
    number                         shift and go to state 140
    booleanOp                      shift and go to state 142
    negation_values                shift and go to state 143
    deniable_values                shift and go to state 146

state 189

    (138) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON
    (139) declarationExpression -> datatype IDENTIFIER . EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (136) repeatDeclaration -> IDENTIFIER .
    (137) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    EQUAL           shift and go to state 101
    SEMICOLON       reduce using rule 136 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 102


state 190

    (140) declarationExpression -> FINAL IDENTIFIER . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 246


state 191

    (67) while -> WHILE LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 247


state 192

    (106) conditions -> condition condition_connector . conditions
    (105) conditions -> . condition
    (106) conditions -> . condition condition_connector conditions
    (98) condition -> . IDENTIFIER condition_operator condition_values
    (99) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (100) condition -> . BOOLEAN condition_operator BOOLEAN
    (101) condition -> . number condition_operator number
    (102) condition -> . STR condition_operator STR
    (103) condition -> . booleanOp condition_operator booleanOp
    (104) condition -> . negation_values
    (96) number -> . FLOAT
    (97) number -> . INTEGER
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (83) negation_values -> . deniable_values
    (84) negation_values -> . EXMARK deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 137
    EXMARK          shift and go to state 138
    BOOLEAN         shift and go to state 139
    STR             shift and go to state 141
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    condition                      shift and go to state 136
    conditions                     shift and go to state 248
    number                         shift and go to state 140
    booleanOp                      shift and go to state 142
    negation_values                shift and go to state 143
    deniable_values                shift and go to state 146

state 193

    (98) condition -> IDENTIFIER condition_operator . condition_values
    (85) condition_values -> . negation_values
    (86) condition_values -> . INTEGER
    (87) condition_values -> . FLOAT
    (88) condition_values -> . STR
    (89) condition_values -> . NULL
    (83) negation_values -> . deniable_values
    (84) negation_values -> . EXMARK deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    INTEGER         shift and go to state 252
    FLOAT           shift and go to state 253
    STR             shift and go to state 254
    NULL            shift and go to state 255
    EXMARK          shift and go to state 256
    IDENTIFIER      shift and go to state 249
    BOOLEAN         shift and go to state 200
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    condition_values               shift and go to state 250
    negation_values                shift and go to state 251
    deniable_values                shift and go to state 146
    booleanOp                      shift and go to state 201

state 194

    (90) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 90 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 90 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 90 (condition_operator -> DOUBLEQUAL .)
    NULL            reduce using rule 90 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 90 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 90 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 90 (condition_operator -> DOUBLEQUAL .)
    TRUE            reduce using rule 90 (condition_operator -> DOUBLEQUAL .)
    FALSE           reduce using rule 90 (condition_operator -> DOUBLEQUAL .)


state 195

    (91) condition_operator -> LESSTHAN .
    (93) condition_operator -> LESSTHAN . EQUAL

    INTEGER         reduce using rule 91 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 91 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 91 (condition_operator -> LESSTHAN .)
    NULL            reduce using rule 91 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 91 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 91 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 91 (condition_operator -> LESSTHAN .)
    TRUE            reduce using rule 91 (condition_operator -> LESSTHAN .)
    FALSE           reduce using rule 91 (condition_operator -> LESSTHAN .)
    EQUAL           shift and go to state 257


state 196

    (92) condition_operator -> GREATERTHAN .
    (94) condition_operator -> GREATERTHAN . EQUAL

    INTEGER         reduce using rule 92 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 92 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 92 (condition_operator -> GREATERTHAN .)
    NULL            reduce using rule 92 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 92 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 92 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 92 (condition_operator -> GREATERTHAN .)
    TRUE            reduce using rule 92 (condition_operator -> GREATERTHAN .)
    FALSE           reduce using rule 92 (condition_operator -> GREATERTHAN .)
    EQUAL           shift and go to state 258


state 197

    (95) condition_operator -> EXMARK . EQUAL

    EQUAL           shift and go to state 259


state 198

    (99) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (80) deniable_values -> IDENTIFIER .
    (90) condition_operator -> . DOUBLEQUAL
    (91) condition_operator -> . LESSTHAN
    (92) condition_operator -> . GREATERTHAN
    (93) condition_operator -> . LESSTHAN EQUAL
    (94) condition_operator -> . GREATERTHAN EQUAL
    (95) condition_operator -> . EXMARK EQUAL

    AND             reduce using rule 80 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 80 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 80 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 80 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 80 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 80 (deniable_values -> IDENTIFIER .)
    DOUBLEQUAL      shift and go to state 194
    LESSTHAN        shift and go to state 195
    GREATERTHAN     shift and go to state 196
    EXMARK          shift and go to state 197

    condition_operator             shift and go to state 260

state 199

    (84) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 84 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 84 (negation_values -> EXMARK deniable_values .)
    AMPERSAND       reduce using rule 84 (negation_values -> EXMARK deniable_values .)
    PIPELINE        reduce using rule 84 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 84 (negation_values -> EXMARK deniable_values .)
    SEMICOLON       reduce using rule 84 (negation_values -> EXMARK deniable_values .)


state 200

    (81) deniable_values -> BOOLEAN .

    AND             reduce using rule 81 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 81 (deniable_values -> BOOLEAN .)
    AMPERSAND       reduce using rule 81 (deniable_values -> BOOLEAN .)
    PIPELINE        reduce using rule 81 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 81 (deniable_values -> BOOLEAN .)
    SEMICOLON       reduce using rule 81 (deniable_values -> BOOLEAN .)


state 201

    (82) deniable_values -> booleanOp .

    AND             reduce using rule 82 (deniable_values -> booleanOp .)
    OR              reduce using rule 82 (deniable_values -> booleanOp .)
    AMPERSAND       reduce using rule 82 (deniable_values -> booleanOp .)
    PIPELINE        reduce using rule 82 (deniable_values -> booleanOp .)
    RPAREN          reduce using rule 82 (deniable_values -> booleanOp .)
    SEMICOLON       reduce using rule 82 (deniable_values -> booleanOp .)


state 202

    (100) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 261


state 203

    (101) condition -> number condition_operator . number
    (96) number -> . FLOAT
    (97) number -> . INTEGER

    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145

    number                         shift and go to state 262

state 204

    (102) condition -> STR condition_operator . STR

    STR             shift and go to state 263


state 205

    (103) condition -> booleanOp condition_operator . booleanOp
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    booleanOp                      shift and go to state 264

state 206

    (49) print -> PRINT LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 265


state 207

    (141) semanticbool -> BOOL IDENTIFIER EQUAL conditions . SEMICOLON

    SEMICOLON       shift and go to state 266


state 208

    (150) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 267


state 209

    (151) semanticlist -> LIST LESSTHAN INT GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 268


state 210

    (152) semanticlist -> LIST LESSTHAN STRING GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 269


state 211

    (153) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 270


state 212

    (154) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 271


state 213

    (127) assert -> ASSERT LPAREN conditions RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 272


state 214

    (33) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 109
    STRING          shift and go to state 110
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    MAP             shift and go to state 49

    datatype                       shift and go to state 273
    map_identifier                 shift and go to state 112

state 215

    (62) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 274


state 216

    (19) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (17) class_content_repeat -> . class_content
    (18) class_content_repeat -> . class_content_repeat class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content_repeat           shift and go to state 275
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 217

    (111) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 276


state 218

    (116) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (119) optFunction_arguments -> . optFunction_argument
    (120) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (118) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 279

    optFunction_arguments          shift and go to state 277
    optFunction_argument           shift and go to state 278

state 219

    (117) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 117 (optFunction_argumentsExpression -> empty .)


state 220

    (138) declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .

    CONTINUE        reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    ASSERT          reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 138 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)


state 221

    (139) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype . RPAREN IDENTIFIER SEMICOLON

    RPAREN          shift and go to state 280


state 222

    (30) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 281


state 223

    (51) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 51 (map_content -> map_pairs .)


state 224

    (52) map_content -> empty .

    RCURLYBRACKET   reduce using rule 52 (map_content -> empty .)


state 225

    (54) map_pairs -> map_pair .
    (55) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 54 (map_pairs -> map_pair .)
    COMMA           shift and go to state 282


state 226

    (53) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 283


state 227

    (56) map_key -> value .

    COLON           reduce using rule 56 (map_key -> value .)


state 228

    (70) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET . RETURN expression SEMICOLON RCURLYBRACKET

    RETURN          shift and go to state 284


state 229

    (115) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    RPAREN          reduce using rule 115 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    LCURLYBRACKET   reduce using rule 115 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 230

    (126) asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .

    CONTINUE        reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    STRING          reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    INT             reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    FOR             reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    LIST            reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    ASSERT          reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    VOID            reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    VAR             reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    MAP             reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    IF              reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    STR             reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    $end            reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 126 (asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON .)


state 231

    (165) addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER . RPAREN SEMICOLON

    RPAREN          shift and go to state 285


state 232

    (167) addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp . RPAREN SEMICOLON

    RPAREN          shift and go to state 286


state 233

    (168) addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT . RPAREN SEMICOLON

    RPAREN          shift and go to state 287


state 234

    (166) addlistStr -> IDENTIFIER DOT ADD LPAREN STR . RPAREN SEMICOLON

    RPAREN          shift and go to state 288


state 235

    (64) elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    CONTINUE        reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    PRINT           reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    ASSERT          reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 64 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 236

    (140) declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .

    CONTINUE        reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    ASSERT          reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 140 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)


state 237

    (66) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 109
    STRING          shift and go to state 110
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    MAP             shift and go to state 49

    datatype                       shift and go to state 289
    map_identifier                 shift and go to state 112

state 238

    (69) stack -> FINAL IDENTIFIER EQUAL STACK DOT . OF LPAREN IDENTIFIER RPAREN SEMICOLON

    OF              shift and go to state 290


state 239

    (169) declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .

    CONTINUE        reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FINAL           reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    STRING          reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    INT             reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FOR             reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    WHILE           reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    IDENTIFIER      reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    PRINT           reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    BOOL            reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    LIST            reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    ASSERT          reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    DOUBLE          reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    DYNAMIC         reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    VOID            reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    VAR             reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    MAP             reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    IF              reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    INTEGER         reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FLOAT           reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    STR             reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    BOOLEAN         reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    TRUE            reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FALSE           reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    MAIN            reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    $end            reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    SEMICOLON       reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    RCURLYBRACKET   reduce using rule 169 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)


state 240

    (172) expressionString -> STR operatorExpressionString . expressionString
    (171) expressionString -> . STR
    (172) expressionString -> . STR operatorExpressionString expressionString

    STR             shift and go to state 184

    expressionString               shift and go to state 291

state 241

    (173) operatorExpressionString -> PLUS .

    STR             reduce using rule 173 (operatorExpressionString -> PLUS .)


state 242

    (179) expressionInteger -> IDENTIFIER operatorExpression . expressionInteger
    (176) expressionInteger -> . number
    (177) expressionInteger -> . number operatorExpression expressionInteger
    (178) expressionInteger -> . IDENTIFIER
    (179) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (96) number -> . FLOAT
    (97) number -> . INTEGER

    IDENTIFIER      shift and go to state 185
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145

    expressionInteger              shift and go to state 292
    number                         shift and go to state 187

state 243

    (174) declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .

    CONTINUE        reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FINAL           reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    STRING          reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    INT             reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FOR             reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    WHILE           reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    IDENTIFIER      reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    PRINT           reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    BOOL            reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    LIST            reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    ASSERT          reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    DOUBLE          reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    DYNAMIC         reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    VOID            reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    VAR             reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    MAP             reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    IF              reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    INTEGER         reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FLOAT           reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    STR             reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    BOOLEAN         reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    TRUE            reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FALSE           reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    MAIN            reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    $end            reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    SEMICOLON       reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    RCURLYBRACKET   reduce using rule 174 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)


state 244

    (177) expressionInteger -> number operatorExpression . expressionInteger
    (176) expressionInteger -> . number
    (177) expressionInteger -> . number operatorExpression expressionInteger
    (178) expressionInteger -> . IDENTIFIER
    (179) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (96) number -> . FLOAT
    (97) number -> . INTEGER

    IDENTIFIER      shift and go to state 185
    FLOAT           shift and go to state 144
    INTEGER         shift and go to state 145

    number                         shift and go to state 187
    expressionInteger              shift and go to state 293

state 245

    (65) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition . SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 294


state 246

    (140) declarationExpression -> FINAL IDENTIFIER EQUAL . expression SEMICOLON
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    expression                     shift and go to state 181
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 247

    (67) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (17) class_content_repeat -> . class_content
    (18) class_content_repeat -> . class_content_repeat class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content_repeat           shift and go to state 295
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 248

    (106) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 106 (conditions -> condition condition_connector conditions .)
    SEMICOLON       reduce using rule 106 (conditions -> condition condition_connector conditions .)


state 249

    (80) deniable_values -> IDENTIFIER .

    AND             reduce using rule 80 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 80 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 80 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 80 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 80 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 80 (deniable_values -> IDENTIFIER .)


state 250

    (98) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 98 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 98 (condition -> IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 98 (condition -> IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 98 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 98 (condition -> IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 98 (condition -> IDENTIFIER condition_operator condition_values .)


state 251

    (85) condition_values -> negation_values .

    AND             reduce using rule 85 (condition_values -> negation_values .)
    OR              reduce using rule 85 (condition_values -> negation_values .)
    AMPERSAND       reduce using rule 85 (condition_values -> negation_values .)
    PIPELINE        reduce using rule 85 (condition_values -> negation_values .)
    RPAREN          reduce using rule 85 (condition_values -> negation_values .)
    SEMICOLON       reduce using rule 85 (condition_values -> negation_values .)


state 252

    (86) condition_values -> INTEGER .

    AND             reduce using rule 86 (condition_values -> INTEGER .)
    OR              reduce using rule 86 (condition_values -> INTEGER .)
    AMPERSAND       reduce using rule 86 (condition_values -> INTEGER .)
    PIPELINE        reduce using rule 86 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 86 (condition_values -> INTEGER .)
    SEMICOLON       reduce using rule 86 (condition_values -> INTEGER .)


state 253

    (87) condition_values -> FLOAT .

    AND             reduce using rule 87 (condition_values -> FLOAT .)
    OR              reduce using rule 87 (condition_values -> FLOAT .)
    AMPERSAND       reduce using rule 87 (condition_values -> FLOAT .)
    PIPELINE        reduce using rule 87 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 87 (condition_values -> FLOAT .)
    SEMICOLON       reduce using rule 87 (condition_values -> FLOAT .)


state 254

    (88) condition_values -> STR .

    AND             reduce using rule 88 (condition_values -> STR .)
    OR              reduce using rule 88 (condition_values -> STR .)
    AMPERSAND       reduce using rule 88 (condition_values -> STR .)
    PIPELINE        reduce using rule 88 (condition_values -> STR .)
    RPAREN          reduce using rule 88 (condition_values -> STR .)
    SEMICOLON       reduce using rule 88 (condition_values -> STR .)


state 255

    (89) condition_values -> NULL .

    AND             reduce using rule 89 (condition_values -> NULL .)
    OR              reduce using rule 89 (condition_values -> NULL .)
    AMPERSAND       reduce using rule 89 (condition_values -> NULL .)
    PIPELINE        reduce using rule 89 (condition_values -> NULL .)
    RPAREN          reduce using rule 89 (condition_values -> NULL .)
    SEMICOLON       reduce using rule 89 (condition_values -> NULL .)


state 256

    (84) negation_values -> EXMARK . deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 249
    BOOLEAN         shift and go to state 200
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    deniable_values                shift and go to state 199
    booleanOp                      shift and go to state 201

state 257

    (93) condition_operator -> LESSTHAN EQUAL .

    INTEGER         reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)
    FLOAT           reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)
    STR             reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)
    NULL            reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)
    EXMARK          reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)
    IDENTIFIER      reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)
    BOOLEAN         reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)
    TRUE            reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)
    FALSE           reduce using rule 93 (condition_operator -> LESSTHAN EQUAL .)


state 258

    (94) condition_operator -> GREATERTHAN EQUAL .

    INTEGER         reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)
    FLOAT           reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)
    STR             reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)
    NULL            reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)
    EXMARK          reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)
    IDENTIFIER      reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)
    BOOLEAN         reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)
    TRUE            reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)
    FALSE           reduce using rule 94 (condition_operator -> GREATERTHAN EQUAL .)


state 259

    (95) condition_operator -> EXMARK EQUAL .

    INTEGER         reduce using rule 95 (condition_operator -> EXMARK EQUAL .)
    FLOAT           reduce using rule 95 (condition_operator -> EXMARK EQUAL .)
    STR             reduce using rule 95 (condition_operator -> EXMARK EQUAL .)
    NULL            reduce using rule 95 (condition_operator -> EXMARK EQUAL .)
    EXMARK          reduce using rule 95 (condition_operator -> EXMARK EQUAL .)
    IDENTIFIER      reduce using rule 95 (condition_operator -> EXMARK EQUAL .)
    BOOLEAN         reduce using rule 95 (condition_operator -> EXMARK EQUAL .)
    TRUE            reduce using rule 95 (condition_operator -> EXMARK EQUAL .)
    FALSE           reduce using rule 95 (condition_operator -> EXMARK EQUAL .)


state 260

    (99) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (85) condition_values -> . negation_values
    (86) condition_values -> . INTEGER
    (87) condition_values -> . FLOAT
    (88) condition_values -> . STR
    (89) condition_values -> . NULL
    (83) negation_values -> . deniable_values
    (84) negation_values -> . EXMARK deniable_values
    (80) deniable_values -> . IDENTIFIER
    (81) deniable_values -> . BOOLEAN
    (82) deniable_values -> . booleanOp
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    INTEGER         shift and go to state 252
    FLOAT           shift and go to state 253
    STR             shift and go to state 254
    NULL            shift and go to state 255
    EXMARK          shift and go to state 256
    IDENTIFIER      shift and go to state 249
    BOOLEAN         shift and go to state 200
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    condition_values               shift and go to state 296
    negation_values                shift and go to state 251
    deniable_values                shift and go to state 146
    booleanOp                      shift and go to state 201

state 261

    (100) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 100 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 100 (condition -> BOOLEAN condition_operator BOOLEAN .)
    AMPERSAND       reduce using rule 100 (condition -> BOOLEAN condition_operator BOOLEAN .)
    PIPELINE        reduce using rule 100 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 100 (condition -> BOOLEAN condition_operator BOOLEAN .)
    SEMICOLON       reduce using rule 100 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 262

    (101) condition -> number condition_operator number .

    AND             reduce using rule 101 (condition -> number condition_operator number .)
    OR              reduce using rule 101 (condition -> number condition_operator number .)
    AMPERSAND       reduce using rule 101 (condition -> number condition_operator number .)
    PIPELINE        reduce using rule 101 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 101 (condition -> number condition_operator number .)
    SEMICOLON       reduce using rule 101 (condition -> number condition_operator number .)


state 263

    (102) condition -> STR condition_operator STR .

    AND             reduce using rule 102 (condition -> STR condition_operator STR .)
    OR              reduce using rule 102 (condition -> STR condition_operator STR .)
    AMPERSAND       reduce using rule 102 (condition -> STR condition_operator STR .)
    PIPELINE        reduce using rule 102 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 102 (condition -> STR condition_operator STR .)
    SEMICOLON       reduce using rule 102 (condition -> STR condition_operator STR .)


state 264

    (103) condition -> booleanOp condition_operator booleanOp .

    AND             reduce using rule 103 (condition -> booleanOp condition_operator booleanOp .)
    OR              reduce using rule 103 (condition -> booleanOp condition_operator booleanOp .)
    AMPERSAND       reduce using rule 103 (condition -> booleanOp condition_operator booleanOp .)
    PIPELINE        reduce using rule 103 (condition -> booleanOp condition_operator booleanOp .)
    RPAREN          reduce using rule 103 (condition -> booleanOp condition_operator booleanOp .)
    SEMICOLON       reduce using rule 103 (condition -> booleanOp condition_operator booleanOp .)


state 265

    (49) print -> PRINT LPAREN value RPAREN SEMICOLON .

    CONTINUE        reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FINAL           reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    INT             reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    WHILE           reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    LIST            reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    ASSERT          reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VOID            reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    MAP             reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    STR             reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    TRUE            reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FALSE           reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    MAIN            reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 49 (print -> PRINT LPAREN value RPAREN SEMICOLON .)


state 266

    (141) semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .

    CONTINUE        reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    FINAL           reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    STRING          reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    INT             reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    FOR             reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    WHILE           reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    IDENTIFIER      reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    PRINT           reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    BOOL            reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    LIST            reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    ASSERT          reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    DOUBLE          reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    DYNAMIC         reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    VOID            reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    VAR             reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    MAP             reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    IF              reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    INTEGER         reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    FLOAT           reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    STR             reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    BOOLEAN         reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    TRUE            reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    FALSE           reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    MAIN            reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    $end            reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    RCURLYBRACKET   reduce using rule 141 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)


state 267

    (150) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 297


state 268

    (151) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 298


state 269

    (152) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 299


state 270

    (153) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 300


state 271

    (154) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 301


state 272

    (127) assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .

    CONTINUE        reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    FINAL           reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    STRING          reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    INT             reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    FOR             reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    WHILE           reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    PRINT           reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    BOOL            reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    LIST            reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    ASSERT          reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    VOID            reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    VAR             reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    MAP             reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    IF              reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    INTEGER         reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    FLOAT           reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    STR             reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    TRUE            reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    FALSE           reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    MAIN            reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    $end            reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 127 (assert -> ASSERT LPAREN conditions RPAREN SEMICOLON .)


state 273

    (33) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 302


state 274

    (62) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (17) class_content_repeat -> . class_content
    (18) class_content_repeat -> . class_content_repeat class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content_repeat           shift and go to state 303
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 275

    (19) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (18) class_content_repeat -> class_content_repeat . class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    RCURLYBRACKET   shift and go to state 304
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content                  shift and go to state 57
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 276

    (111) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 305


state 277

    (116) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 306


state 278

    (119) optFunction_arguments -> optFunction_argument .
    (120) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 119 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 307


state 279

    (118) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 109
    STRING          shift and go to state 110
    BOOL            shift and go to state 111
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    MAP             shift and go to state 49

    datatype                       shift and go to state 308
    map_identifier                 shift and go to state 112

state 280

    (139) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 309


state 281

    (30) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 310


state 282

    (55) map_pairs -> map_pair COMMA . map_pairs
    (54) map_pairs -> . map_pair
    (55) map_pairs -> . map_pair COMMA map_pairs
    (53) map_pair -> . map_key COLON map_value
    (56) map_key -> . value
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 150
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    map_pair                       shift and go to state 225
    map_pairs                      shift and go to state 311
    map_key                        shift and go to state 226
    value                          shift and go to state 227
    booleanOp                      shift and go to state 151
    propertiesAccess               shift and go to state 52

state 283

    (53) map_pair -> map_key COLON . map_value
    (57) map_value -> . value
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 150
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    map_value                      shift and go to state 312
    value                          shift and go to state 313
    booleanOp                      shift and go to state 151
    propertiesAccess               shift and go to state 52

state 284

    (70) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN . expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    expression                     shift and go to state 314
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 285

    (165) addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 315


state 286

    (167) addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 316


state 287

    (168) addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 317


state 288

    (166) addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 318


state 289

    (66) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN RPAREN SEMICOLON

    GREATERTHAN     shift and go to state 319


state 290

    (69) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF . LPAREN IDENTIFIER RPAREN SEMICOLON

    LPAREN          shift and go to state 320


state 291

    (172) expressionString -> STR operatorExpressionString expressionString .

    SEMICOLON       reduce using rule 172 (expressionString -> STR operatorExpressionString expressionString .)


state 292

    (179) expressionInteger -> IDENTIFIER operatorExpression expressionInteger .

    SEMICOLON       reduce using rule 179 (expressionInteger -> IDENTIFIER operatorExpression expressionInteger .)


state 293

    (177) expressionInteger -> number operatorExpression expressionInteger .

    SEMICOLON       reduce using rule 177 (expressionInteger -> number operatorExpression expressionInteger .)


state 294

    (65) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON . expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    expression                     shift and go to state 321
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 295

    (67) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (18) class_content_repeat -> class_content_repeat . class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    RCURLYBRACKET   shift and go to state 322
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content                  shift and go to state 57
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 296

    (99) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 99 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 99 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 99 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 99 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 99 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 99 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 297

    (150) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 323


state 298

    (151) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 324


state 299

    (152) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 325


state 300

    (153) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 326


state 301

    (154) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 327


state 302

    (33) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 33 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    MAIN            reduce using rule 33 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 33 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    RPAREN          reduce using rule 33 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 33 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 303

    (62) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (18) class_content_repeat -> class_content_repeat . class_content
    (6) class_content -> . map
    (7) class_content -> . ifElseStatement
    (8) class_content -> . function_lambda
    (9) class_content -> . declarationExpression
    (10) class_content -> . forStatement
    (11) class_content -> . while
    (12) class_content -> . stack
    (13) class_content -> . inferedReturnFunction
    (14) class_content -> . expression SEMICOLON
    (15) class_content -> . print
    (16) class_content -> . CONTINUE SEMICOLON
    (22) class_content -> . semanticbool
    (23) class_content -> . semanticlist
    (24) class_content -> . asign
    (25) class_content -> . addlistInt
    (26) class_content -> . addlistBool
    (27) class_content -> . addlistFloat
    (28) class_content -> . addlistStr
    (29) class_content -> . assert
    (30) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (58) ifElseStatement -> . ifStatement
    (59) ifElseStatement -> . ifStatement elifStatement_repeat
    (111) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (135) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (138) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (139) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (140) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (169) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (170) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (174) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (175) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (65) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (67) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (66) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (69) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (70) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (49) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (141) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (150) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (151) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (152) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (153) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (154) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (125) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (126) asign -> . IDENTIFIER operatorExpression EQUAL expression SEMICOLON
    (165) addlistInt -> . IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
    (167) addlistBool -> . IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
    (168) addlistFloat -> . IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
    (166) addlistStr -> . IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
    (127) assert -> . ASSERT LPAREN conditions RPAREN SEMICOLON
    (31) map_identifier -> . MAP
    (32) map_identifier -> . MAP map_type_specified
    (62) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) datatype -> . INT
    (35) datatype -> . STRING
    (36) datatype -> . BOOL
    (37) datatype -> . DOUBLE
    (38) datatype -> . DYNAMIC
    (39) datatype -> . VOID
    (40) datatype -> . map_identifier
    (41) datatype -> . VAR
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    RCURLYBRACKET   shift and go to state 328
    CONTINUE        shift and go to state 16
    FINAL           shift and go to state 30
    STRING          shift and go to state 31
    INT             shift and go to state 32
    FOR             shift and go to state 33
    WHILE           shift and go to state 34
    IDENTIFIER      shift and go to state 28
    PRINT           shift and go to state 37
    BOOL            shift and go to state 38
    LIST            shift and go to state 39
    ASSERT          shift and go to state 46
    MAP             shift and go to state 49
    IF              shift and go to state 50
    DOUBLE          shift and go to state 41
    DYNAMIC         shift and go to state 40
    VOID            shift and go to state 47
    VAR             shift and go to state 48
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    class_content                  shift and go to state 57
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 17
    semanticlist                   shift and go to state 18
    asign                          shift and go to state 19
    addlistInt                     shift and go to state 20
    addlistBool                    shift and go to state 21
    addlistFloat                   shift and go to state 22
    addlistStr                     shift and go to state 23
    assert                         shift and go to state 24
    map_identifier                 shift and go to state 27
    ifStatement                    shift and go to state 29
    datatype                       shift and go to state 59
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 304

    (19) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    CONTINUE        reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    PRINT           reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    ASSERT          reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 19 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 305

    (111) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 329


state 306

    (116) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 116 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 307

    (120) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (119) optFunction_arguments -> . optFunction_argument
    (120) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (118) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 279

    optFunction_argument           shift and go to state 278
    optFunction_arguments          shift and go to state 330

state 308

    (118) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 331


state 309

    (139) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 332


state 310

    (30) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    CONTINUE        reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FINAL           reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STRING          reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INT             reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FOR             reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    WHILE           reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    PRINT           reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOL            reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    LIST            reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    ASSERT          reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VOID            reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VAR             reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAP             reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IF              reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INTEGER         reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FLOAT           reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STR             reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    TRUE            reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FALSE           reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAIN            reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    $end            reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 30 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 311

    (55) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 55 (map_pairs -> map_pair COMMA map_pairs .)


state 312

    (53) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 53 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 53 (map_pair -> map_key COLON map_value .)


state 313

    (57) map_value -> value .

    COMMA           reduce using rule 57 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 57 (map_value -> value .)


state 314

    (70) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression . SEMICOLON RCURLYBRACKET

    SEMICOLON       shift and go to state 333


state 315

    (165) addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .

    CONTINUE        reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    FINAL           reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    STRING          reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    INT             reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    FOR             reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    WHILE           reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    PRINT           reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    BOOL            reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    LIST            reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    ASSERT          reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    VOID            reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    VAR             reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    MAP             reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    IF              reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    INTEGER         reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    STR             reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    TRUE            reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    FALSE           reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    MAIN            reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    $end            reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 165 (addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON .)


state 316

    (167) addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .

    CONTINUE        reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    FINAL           reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    STRING          reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    INT             reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    FOR             reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    WHILE           reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    PRINT           reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    BOOL            reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    LIST            reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    ASSERT          reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    VOID            reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    VAR             reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    MAP             reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    IF              reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    INTEGER         reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    FLOAT           reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    STR             reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    TRUE            reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    FALSE           reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    MAIN            reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    $end            reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 167 (addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON .)


state 317

    (168) addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .

    CONTINUE        reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    FINAL           reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    STRING          reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    INT             reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    FOR             reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    WHILE           reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    PRINT           reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    BOOL            reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    LIST            reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    ASSERT          reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    VOID            reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    VAR             reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    MAP             reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    IF              reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    INTEGER         reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    FLOAT           reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    STR             reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    TRUE            reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    FALSE           reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    MAIN            reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    $end            reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 168 (addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON .)


state 318

    (166) addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .

    CONTINUE        reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    FINAL           reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    STRING          reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    INT             reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    FOR             reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    WHILE           reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    PRINT           reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    BOOL            reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    LIST            reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    ASSERT          reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    VOID            reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    VAR             reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    MAP             reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    IF              reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    INTEGER         reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    FLOAT           reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    STR             reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    TRUE            reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    FALSE           reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    MAIN            reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    $end            reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 166 (addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON .)


state 319

    (66) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN opt_value RPAREN SEMICOLON
    (68) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 334


state 320

    (69) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN . IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 335


state 321

    (65) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression . RPAREN LCURLYBRACKET RCURLYBRACKET

    RPAREN          shift and go to state 336


state 322

    (67) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    CONTINUE        reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    PRINT           reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    ASSERT          reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 67 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 323

    (150) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelist RSQUAREBRACKET SEMICOLON
    (155) insidelist -> . value
    (156) insidelist -> . value COMMA insidelist
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 150
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    insidelist                     shift and go to state 337
    value                          shift and go to state 338
    booleanOp                      shift and go to state 151
    propertiesAccess               shift and go to state 52

state 324

    (151) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistint RSQUAREBRACKET SEMICOLON
    (157) insidelistint -> . INTEGER
    (158) insidelistint -> . INTEGER COMMA insidelistint

    INTEGER         shift and go to state 340

    insidelistint                  shift and go to state 339

state 325

    (152) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insideliststr RSQUAREBRACKET SEMICOLON
    (159) insideliststr -> . STR
    (160) insideliststr -> . STR COMMA insideliststr

    STR             shift and go to state 342

    insideliststr                  shift and go to state 341

state 326

    (153) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistbool RSQUAREBRACKET SEMICOLON
    (161) insidelistbool -> . booleanOp
    (162) insidelistbool -> . booleanOp COMMA insidelistbool
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    insidelistbool                 shift and go to state 343
    booleanOp                      shift and go to state 344

state 327

    (154) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistdouble RSQUAREBRACKET SEMICOLON
    (163) insidelistdouble -> . FLOAT
    (164) insidelistdouble -> . FLOAT COMMA insidelistdouble

    FLOAT           shift and go to state 346

    insidelistdouble               shift and go to state 345

state 328

    (62) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    CONTINUE        reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    PRINT           reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    ASSERT          reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 62 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 329

    (111) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (121) expression -> . value
    (122) expression -> . value operatorExpression expression
    (123) expression -> . value operatorExpression operatorExpression
    (124) expression -> . booloperations
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (148) booloperations -> . booloperation
    (149) booloperations -> . booloperation condition_connector booloperations
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties
    (144) booloperation -> . booleanOp condition_connector booleanOp
    (145) booloperation -> . IDENTIFIER condition_connector booleanOp
    (146) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (147) booloperation -> . booleanOp condition_connector IDENTIFIER

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 113
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    expression                     shift and go to state 347
    value                          shift and go to state 35
    booloperations                 shift and go to state 36
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 52
    booloperation                  shift and go to state 53

state 330

    (120) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 120 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 331

    (118) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 118 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 118 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 332

    (139) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .

    CONTINUE        reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    FINAL           reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    INT             reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    ASSERT          reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    STR             reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    MAIN            reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    $end            reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 139 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)


state 333

    (70) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 348


state 334

    (66) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . opt_value RPAREN SEMICOLON
    (68) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . RPAREN SEMICOLON
    (78) opt_value -> . value
    (79) opt_value -> . empty
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (50) empty -> .
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 350
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 150
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

  ! RPAREN          [ reduce using rule 50 (empty -> .) ]

    opt_value                      shift and go to state 349
    value                          shift and go to state 351
    empty                          shift and go to state 352
    booleanOp                      shift and go to state 151
    propertiesAccess               shift and go to state 52

state 335

    (69) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER . RPAREN SEMICOLON

    RPAREN          shift and go to state 353


state 336

    (65) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN . LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 354


state 337

    (150) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 355


state 338

    (155) insidelist -> value .
    (156) insidelist -> value . COMMA insidelist

    RSQUAREBRACKET  reduce using rule 155 (insidelist -> value .)
    COMMA           shift and go to state 356


state 339

    (151) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 357


state 340

    (157) insidelistint -> INTEGER .
    (158) insidelistint -> INTEGER . COMMA insidelistint

    RSQUAREBRACKET  reduce using rule 157 (insidelistint -> INTEGER .)
    COMMA           shift and go to state 358


state 341

    (152) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 359


state 342

    (159) insideliststr -> STR .
    (160) insideliststr -> STR . COMMA insideliststr

    RSQUAREBRACKET  reduce using rule 159 (insideliststr -> STR .)
    COMMA           shift and go to state 360


state 343

    (153) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 361


state 344

    (161) insidelistbool -> booleanOp .
    (162) insidelistbool -> booleanOp . COMMA insidelistbool

    RSQUAREBRACKET  reduce using rule 161 (insidelistbool -> booleanOp .)
    COMMA           shift and go to state 362


state 345

    (154) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 363


state 346

    (163) insidelistdouble -> FLOAT .
    (164) insidelistdouble -> FLOAT . COMMA insidelistdouble

    RSQUAREBRACKET  reduce using rule 163 (insidelistdouble -> FLOAT .)
    COMMA           shift and go to state 364


state 347

    (111) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 365


state 348

    (70) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .

    CONTINUE        reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FINAL           reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STRING          reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INT             reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FOR             reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    WHILE           reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    PRINT           reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOL            reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    LIST            reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    ASSERT          reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DOUBLE          reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DYNAMIC         reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VOID            reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VAR             reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAP             reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IF              reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INTEGER         reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FLOAT           reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STR             reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOLEAN         reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    TRUE            reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FALSE           reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAIN            reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    $end            reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 70 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)


state 349

    (66) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value . RPAREN SEMICOLON

    RPAREN          shift and go to state 366


state 350

    (68) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 367


state 351

    (78) opt_value -> value .

    RPAREN          reduce using rule 78 (opt_value -> value .)


state 352

    (79) opt_value -> empty .

    RPAREN          reduce using rule 79 (opt_value -> empty .)


state 353

    (69) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 368


state 354

    (65) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 369


state 355

    (150) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 370


state 356

    (156) insidelist -> value COMMA . insidelist
    (155) insidelist -> . value
    (156) insidelist -> . value COMMA insidelist
    (71) value -> . INTEGER
    (72) value -> . FLOAT
    (73) value -> . STR
    (74) value -> . BOOLEAN
    (75) value -> . IDENTIFIER
    (76) value -> . booleanOp
    (77) value -> . propertiesAccess
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE
    (182) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 44
    STR             shift and go to state 45
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 150
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 338
    insidelist                     shift and go to state 371
    booleanOp                      shift and go to state 151
    propertiesAccess               shift and go to state 52

state 357

    (151) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 372


state 358

    (158) insidelistint -> INTEGER COMMA . insidelistint
    (157) insidelistint -> . INTEGER
    (158) insidelistint -> . INTEGER COMMA insidelistint

    INTEGER         shift and go to state 340

    insidelistint                  shift and go to state 373

state 359

    (152) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 374


state 360

    (160) insideliststr -> STR COMMA . insideliststr
    (159) insideliststr -> . STR
    (160) insideliststr -> . STR COMMA insideliststr

    STR             shift and go to state 342

    insideliststr                  shift and go to state 375

state 361

    (153) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 376


state 362

    (162) insidelistbool -> booleanOp COMMA . insidelistbool
    (161) insidelistbool -> . booleanOp
    (162) insidelistbool -> . booleanOp COMMA insidelistbool
    (142) booleanOp -> . TRUE
    (143) booleanOp -> . FALSE

    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    booleanOp                      shift and go to state 344
    insidelistbool                 shift and go to state 377

state 363

    (154) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 378


state 364

    (164) insidelistdouble -> FLOAT COMMA . insidelistdouble
    (163) insidelistdouble -> . FLOAT
    (164) insidelistdouble -> . FLOAT COMMA insidelistdouble

    FLOAT           shift and go to state 346

    insidelistdouble               shift and go to state 379

state 365

    (111) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    CONTINUE        reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FINAL           reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STRING          reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INT             reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FOR             reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    WHILE           reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    PRINT           reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOL            reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    LIST            reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    ASSERT          reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DOUBLE          reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DYNAMIC         reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VOID            reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VAR             reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAP             reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IF              reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INTEGER         reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FLOAT           reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STR             reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOLEAN         reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    TRUE            reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FALSE           reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAIN            reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    $end            reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 111 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)


state 366

    (66) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 380


state 367

    (68) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .

    CONTINUE        reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    ASSERT          reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STR             reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAIN            reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 68 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)


state 368

    (69) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .

    CONTINUE        reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FINAL           reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STRING          reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INT             reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FOR             reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    WHILE           reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    PRINT           reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOL            reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    LIST            reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    ASSERT          reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VOID            reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VAR             reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAP             reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IF              reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INTEGER         reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STR             reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    TRUE            reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FALSE           reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAIN            reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    $end            reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 69 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)


state 369

    (65) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .

    CONTINUE        reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FINAL           reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STRING          reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FOR             reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    WHILE           reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    PRINT           reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    LIST            reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    ASSERT          reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VAR             reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IF              reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INTEGER         reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FLOAT           reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STR             reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOLEAN         reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    TRUE            reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FALSE           reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAIN            reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    $end            reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 65 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)


state 370

    (150) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .

    CONTINUE        reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    ASSERT          reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 150 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)


state 371

    (156) insidelist -> value COMMA insidelist .

    RSQUAREBRACKET  reduce using rule 156 (insidelist -> value COMMA insidelist .)


state 372

    (151) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .

    CONTINUE        reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    ASSERT          reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 151 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)


state 373

    (158) insidelistint -> INTEGER COMMA insidelistint .

    RSQUAREBRACKET  reduce using rule 158 (insidelistint -> INTEGER COMMA insidelistint .)


state 374

    (152) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .

    CONTINUE        reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    ASSERT          reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 152 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)


state 375

    (160) insideliststr -> STR COMMA insideliststr .

    RSQUAREBRACKET  reduce using rule 160 (insideliststr -> STR COMMA insideliststr .)


state 376

    (153) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .

    CONTINUE        reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    ASSERT          reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 153 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)


state 377

    (162) insidelistbool -> booleanOp COMMA insidelistbool .

    RSQUAREBRACKET  reduce using rule 162 (insidelistbool -> booleanOp COMMA insidelistbool .)


state 378

    (154) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .

    CONTINUE        reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    ASSERT          reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 154 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)


state 379

    (164) insidelistdouble -> FLOAT COMMA insidelistdouble .

    RSQUAREBRACKET  reduce using rule 164 (insidelistdouble -> FLOAT COMMA insidelistdouble .)


state 380

    (66) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .

    CONTINUE        reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FINAL           reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STRING          reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INT             reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FOR             reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    WHILE           reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    PRINT           reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOL            reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    LIST            reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    ASSERT          reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VOID            reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VAR             reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAP             reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IF              reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STR             reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    TRUE            reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FALSE           reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAIN            reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    $end            reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 66 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 27 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 28 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 28 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 28 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 28 resolved as shift
WARNING: shift/reduce conflict for REST in state 28 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 31 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 32 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 38 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 334 resolved as shift
