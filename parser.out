Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    APOSTROPHE
    ASYNC
    AWAIT
    CATCH
    CLOSE
    COMMENT
    DIVISION
    DOLLAR
    DOUBQUOTMARK
    EXIT
    FILE
    IMPORT
    IN
    IS
    ITERABLE
    LIST
    LSQUAREBRACKET
    MAIN
    METHOD
    NOTEQUAL
    OPENWRITE
    PRINT
    READLINESYNC
    RSQUAREBRACKET
    SET
    TIMES
    TRY
    WHILE
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> map ifElseStatement function_lambda declarationExpression
Rule 2     map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 3     map_identifier -> MAP
Rule 4     map_identifier -> MAP map_type_specified
Rule 5     map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 6     datatype -> INT
Rule 7     datatype -> STRING
Rule 8     datatype -> BOOL
Rule 9     datatype -> DOUBLE
Rule 10    datatype -> DYNAMIC
Rule 11    datatype -> VAR
Rule 12    datatype -> VOID
Rule 13    datatype -> map_identifier
Rule 14    returnType -> INT
Rule 15    returnType -> STRING
Rule 16    returnType -> BOOL
Rule 17    returnType -> DOUBLE
Rule 18    returnType -> DYNAMIC
Rule 19    returnType -> VOID
Rule 20    returnType -> map_identifier
Rule 21    empty -> <empty>
Rule 22    map_content -> map_pairs
Rule 23    map_content -> empty
Rule 24    map_pair -> map_key COLON map_value
Rule 25    map_pairs -> map_pair
Rule 26    map_pairs -> map_pair COMMA map_pairs
Rule 27    map_key -> value
Rule 28    map_value -> value
Rule 29    ifElseStatement -> ifStatement
Rule 30    ifElseStatement -> ifStatement elifStatement_repeat
Rule 31    elifStatement_repeat -> elifStatement
Rule 32    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 33    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 34    elifStatement -> ELSE ifStatement
Rule 35    elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET
Rule 36    for -> FOR LPAREN declarationExpression SEMICOLON conditions SEMICOLON task RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 37    task -> IDENTIFIER PLUS PLUS
Rule 38    task -> IDENTIFIER MINUS MINUS
Rule 39    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN SEMICOLON
Rule 40    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 41    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN RCURLYBRACKET
Rule 42    value -> INTEGER
Rule 43    value -> FLOAT
Rule 44    value -> STR
Rule 45    value -> BOOLEAN
Rule 46    value -> IDENTIFIER
Rule 47    deniable_values -> IDENTIFIER
Rule 48    deniable_values -> BOOLEAN
Rule 49    negation_values -> deniable_values
Rule 50    negation_values -> EXMARK deniable_values
Rule 51    condition_values -> negation_values
Rule 52    condition_values -> INTEGER
Rule 53    condition_values -> FLOAT
Rule 54    condition_values -> STR
Rule 55    condition_operator -> DOUBLEQUAL
Rule 56    condition_operator -> LESSTHAN
Rule 57    condition_operator -> GREATERTHAN
Rule 58    number -> FLOAT
Rule 59    number -> INTEGER
Rule 60    condition -> IDENTIFIER condition_operator condition_values
Rule 61    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 62    condition -> BOOLEAN condition_operator BOOLEAN
Rule 63    condition -> number condition_operator number
Rule 64    condition -> STR condition_operator STR
Rule 65    conditions -> condition
Rule 66    conditions -> condition condition_connector conditions
Rule 67    condition_connector -> AND
Rule 68    condition_connector -> OR
Rule 69    function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 70    function_argument -> datatype IDENTIFIER
Rule 71    function_argument -> empty
Rule 72    function_arguments_repeat -> function_argument
Rule 73    function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 74    optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 75    optFunction_argumentsExpression -> empty
Rule 76    optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 77    optFunction_arguments -> optFunction_argument
Rule 78    optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 79    expression -> IDENTIFIER PLUS IDENTIFIER
Rule 80    expression -> IDENTIFIER MINUS IDENTIFIER
Rule 81    expression -> IDENTIFIER
Rule 82    declarationExpression -> datatype IDENTIFIER SEMICOLON
Rule 83    declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 67
APOSTROPHE           : 
ASYNC                : 
AWAIT                : 
BOOL                 : 8 16
BOOLEAN              : 45 48 62 62
CATCH                : 
CLOSE                : 
COLON                : 24
COMMA                : 5 26 73 78
COMMENT              : 
DIVISION             : 
DOLLAR               : 
DOT                  : 40
DOUBLE               : 9 17
DOUBLEQUAL           : 55
DOUBQUOTMARK         : 
DYNAMIC              : 10 18
ELSE                 : 34 35
EQUAL                : 2 39 40 69 83
EXIT                 : 
EXMARK               : 50 61
FILE                 : 
FINAL                : 39 40
FLOAT                : 43 53 58
FOR                  : 36
GREATERTHAN          : 5 39 57 69
IDENTIFIER           : 2 37 38 39 40 40 41 46 47 60 61 69 70 76 79 79 80 80 81 82 83
IF                   : 33
IMPORT               : 
IN                   : 
INT                  : 6 14
INTEGER              : 42 52 59
IS                   : 
ITERABLE             : 
LCURLYBRACKET        : 2 33 35 36 41 74
LESSTHAN             : 5 39 56
LIST                 : 
LPAREN               : 33 36 40 41 69
LSQUAREBRACKET       : 
MAIN                 : 
MAP                  : 3 4
METHOD               : 
MINUS                : 38 38 80
NOTEQUAL             : 
OF                   : 40
OPENWRITE            : 
OR                   : 68
PLUS                 : 37 37 79
PRINT                : 
RCURLYBRACKET        : 2 33 35 36 41 74
READLINESYNC         : 
REQUIRED             : 76
RETURN               : 41
RPAREN               : 33 36 40 41 69
RSQUAREBRACKET       : 
SEMICOLON            : 2 36 36 39 40 69 82 83
SET                  : 
STACK                : 39 40
STR                  : 44 54 64 64
STRING               : 7 15
TIMES                : 
TRY                  : 
VAR                  : 11
VOID                 : 12 19
WHILE                : 
WRITE                : 
error                : 

Nonterminals, with rules where they appear

class                : 0
condition            : 65 66
condition_connector  : 66
condition_operator   : 60 61 62 63 64
condition_values     : 60 61
conditions           : 33 36 66
datatype             : 5 5 39 70 76 82 83
declarationExpression : 1 36
deniable_values      : 49 50
elifStatement        : 31 32
elifStatement_repeat : 30 32
empty                : 23 71 75
expression           : 69 83
for                  : 
function_argument    : 72 73
function_arguments_repeat : 41 69 73
function_lambda      : 1
ifElseStatement      : 1
ifStatement          : 29 30 34
inferedReturnFunction : 
map                  : 1
map_content          : 2
map_identifier       : 2 13 20
map_key              : 24
map_pair             : 25 26
map_pairs            : 22 26
map_type_specified   : 4
map_value            : 24
negation_values      : 51
number               : 63 63
optFunction_argument : 77 78
optFunction_arguments : 74 78
optFunction_argumentsExpression : 69
returnType           : 69
stack                : 
task                 : 36
value                : 27 28

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . map ifElseStatement function_lambda declarationExpression
    (2) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    MAP             shift and go to state 4

    class                          shift and go to state 1
    map                            shift and go to state 2
    map_identifier                 shift and go to state 3

state 1

    (0) S' -> class .



state 2

    (1) class -> map . ifElseStatement function_lambda declarationExpression
    (29) ifElseStatement -> . ifStatement
    (30) ifElseStatement -> . ifStatement elifStatement_repeat
    (33) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET

    IF              shift and go to state 7

    ifElseStatement                shift and go to state 5
    ifStatement                    shift and go to state 6

state 3

    (2) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 8


state 4

    (3) map_identifier -> MAP .
    (4) map_identifier -> MAP . map_type_specified
    (5) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 3 (map_identifier -> MAP .)
    COMMA           reduce using rule 3 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 3 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 10

    map_type_specified             shift and go to state 9

state 5

    (1) class -> map ifElseStatement . function_lambda declarationExpression
    (69) function_lambda -> . returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (14) returnType -> . INT
    (15) returnType -> . STRING
    (16) returnType -> . BOOL
    (17) returnType -> . DOUBLE
    (18) returnType -> . DYNAMIC
    (19) returnType -> . VOID
    (20) returnType -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    DOUBLE          shift and go to state 16
    DYNAMIC         shift and go to state 17
    VOID            shift and go to state 18
    MAP             shift and go to state 4

    function_lambda                shift and go to state 11
    returnType                     shift and go to state 12
    map_identifier                 shift and go to state 19

state 6

    (29) ifElseStatement -> ifStatement .
    (30) ifElseStatement -> ifStatement . elifStatement_repeat
    (31) elifStatement_repeat -> . elifStatement
    (32) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (34) elifStatement -> . ELSE ifStatement
    (35) elifStatement -> . ELSE LCURLYBRACKET RCURLYBRACKET

    INT             reduce using rule 29 (ifElseStatement -> ifStatement .)
    STRING          reduce using rule 29 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 29 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 29 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 29 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 29 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 29 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 22

    elifStatement_repeat           shift and go to state 20
    elifStatement                  shift and go to state 21

state 7

    (33) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET

    LPAREN          shift and go to state 23


state 8

    (2) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 24


state 9

    (4) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 4 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 4 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 4 (map_identifier -> MAP map_type_specified .)


state 10

    (5) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    MAP             shift and go to state 4

    datatype                       shift and go to state 25
    map_identifier                 shift and go to state 33

state 11

    (1) class -> map ifElseStatement function_lambda . declarationExpression
    (82) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (83) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    MAP             shift and go to state 4

    declarationExpression          shift and go to state 34
    datatype                       shift and go to state 35
    map_identifier                 shift and go to state 33

state 12

    (69) function_lambda -> returnType . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON

    IDENTIFIER      shift and go to state 36


state 13

    (14) returnType -> INT .

    IDENTIFIER      reduce using rule 14 (returnType -> INT .)


state 14

    (15) returnType -> STRING .

    IDENTIFIER      reduce using rule 15 (returnType -> STRING .)


state 15

    (16) returnType -> BOOL .

    IDENTIFIER      reduce using rule 16 (returnType -> BOOL .)


state 16

    (17) returnType -> DOUBLE .

    IDENTIFIER      reduce using rule 17 (returnType -> DOUBLE .)


state 17

    (18) returnType -> DYNAMIC .

    IDENTIFIER      reduce using rule 18 (returnType -> DYNAMIC .)


state 18

    (19) returnType -> VOID .

    IDENTIFIER      reduce using rule 19 (returnType -> VOID .)


state 19

    (20) returnType -> map_identifier .

    IDENTIFIER      reduce using rule 20 (returnType -> map_identifier .)


state 20

    (30) ifElseStatement -> ifStatement elifStatement_repeat .

    INT             reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STRING          reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 21

    (31) elifStatement_repeat -> elifStatement .
    (32) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (31) elifStatement_repeat -> . elifStatement
    (32) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (34) elifStatement -> . ELSE ifStatement
    (35) elifStatement -> . ELSE LCURLYBRACKET RCURLYBRACKET

    INT             reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    STRING          reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 22

    elifStatement                  shift and go to state 21
    elifStatement_repeat           shift and go to state 37

state 22

    (34) elifStatement -> ELSE . ifStatement
    (35) elifStatement -> ELSE . LCURLYBRACKET RCURLYBRACKET
    (33) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 39
    IF              shift and go to state 7

    ifStatement                    shift and go to state 38

state 23

    (33) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET RCURLYBRACKET
    (65) conditions -> . condition
    (66) conditions -> . condition condition_connector conditions
    (60) condition -> . IDENTIFIER condition_operator condition_values
    (61) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (62) condition -> . BOOLEAN condition_operator BOOLEAN
    (63) condition -> . number condition_operator number
    (64) condition -> . STR condition_operator STR
    (58) number -> . FLOAT
    (59) number -> . INTEGER

    IDENTIFIER      shift and go to state 42
    EXMARK          shift and go to state 43
    BOOLEAN         shift and go to state 44
    STR             shift and go to state 46
    FLOAT           shift and go to state 47
    INTEGER         shift and go to state 48

    conditions                     shift and go to state 40
    condition                      shift and go to state 41
    number                         shift and go to state 45

state 24

    (2) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 49


state 25

    (5) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 50


state 26

    (6) datatype -> INT .

    COMMA           reduce using rule 6 (datatype -> INT .)
    IDENTIFIER      reduce using rule 6 (datatype -> INT .)
    GREATERTHAN     reduce using rule 6 (datatype -> INT .)


state 27

    (7) datatype -> STRING .

    COMMA           reduce using rule 7 (datatype -> STRING .)
    IDENTIFIER      reduce using rule 7 (datatype -> STRING .)
    GREATERTHAN     reduce using rule 7 (datatype -> STRING .)


state 28

    (8) datatype -> BOOL .

    COMMA           reduce using rule 8 (datatype -> BOOL .)
    IDENTIFIER      reduce using rule 8 (datatype -> BOOL .)
    GREATERTHAN     reduce using rule 8 (datatype -> BOOL .)


state 29

    (9) datatype -> DOUBLE .

    COMMA           reduce using rule 9 (datatype -> DOUBLE .)
    IDENTIFIER      reduce using rule 9 (datatype -> DOUBLE .)
    GREATERTHAN     reduce using rule 9 (datatype -> DOUBLE .)


state 30

    (10) datatype -> DYNAMIC .

    COMMA           reduce using rule 10 (datatype -> DYNAMIC .)
    IDENTIFIER      reduce using rule 10 (datatype -> DYNAMIC .)
    GREATERTHAN     reduce using rule 10 (datatype -> DYNAMIC .)


state 31

    (11) datatype -> VAR .

    COMMA           reduce using rule 11 (datatype -> VAR .)
    IDENTIFIER      reduce using rule 11 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 11 (datatype -> VAR .)


state 32

    (12) datatype -> VOID .

    COMMA           reduce using rule 12 (datatype -> VOID .)
    IDENTIFIER      reduce using rule 12 (datatype -> VOID .)
    GREATERTHAN     reduce using rule 12 (datatype -> VOID .)


state 33

    (13) datatype -> map_identifier .

    COMMA           reduce using rule 13 (datatype -> map_identifier .)
    IDENTIFIER      reduce using rule 13 (datatype -> map_identifier .)
    GREATERTHAN     reduce using rule 13 (datatype -> map_identifier .)


state 34

    (1) class -> map ifElseStatement function_lambda declarationExpression .

    $end            reduce using rule 1 (class -> map ifElseStatement function_lambda declarationExpression .)


state 35

    (82) declarationExpression -> datatype . IDENTIFIER SEMICOLON
    (83) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 51


state 36

    (69) function_lambda -> returnType IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON

    LPAREN          shift and go to state 52


state 37

    (32) elifStatement_repeat -> elifStatement elifStatement_repeat .

    INT             reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STRING          reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 38

    (34) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 34 (elifStatement -> ELSE ifStatement .)


state 39

    (35) elifStatement -> ELSE LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 53


state 40

    (33) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET RCURLYBRACKET

    RPAREN          shift and go to state 54


state 41

    (65) conditions -> condition .
    (66) conditions -> condition . condition_connector conditions
    (67) condition_connector -> . AND
    (68) condition_connector -> . OR

    RPAREN          reduce using rule 65 (conditions -> condition .)
    AND             shift and go to state 56
    OR              shift and go to state 57

    condition_connector            shift and go to state 55

state 42

    (60) condition -> IDENTIFIER . condition_operator condition_values
    (55) condition_operator -> . DOUBLEQUAL
    (56) condition_operator -> . LESSTHAN
    (57) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 59
    LESSTHAN        shift and go to state 60
    GREATERTHAN     shift and go to state 61

    condition_operator             shift and go to state 58

state 43

    (61) condition -> EXMARK . IDENTIFIER condition_operator condition_values

    IDENTIFIER      shift and go to state 62


state 44

    (62) condition -> BOOLEAN . condition_operator BOOLEAN
    (55) condition_operator -> . DOUBLEQUAL
    (56) condition_operator -> . LESSTHAN
    (57) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 59
    LESSTHAN        shift and go to state 60
    GREATERTHAN     shift and go to state 61

    condition_operator             shift and go to state 63

state 45

    (63) condition -> number . condition_operator number
    (55) condition_operator -> . DOUBLEQUAL
    (56) condition_operator -> . LESSTHAN
    (57) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 59
    LESSTHAN        shift and go to state 60
    GREATERTHAN     shift and go to state 61

    condition_operator             shift and go to state 64

state 46

    (64) condition -> STR . condition_operator STR
    (55) condition_operator -> . DOUBLEQUAL
    (56) condition_operator -> . LESSTHAN
    (57) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 59
    LESSTHAN        shift and go to state 60
    GREATERTHAN     shift and go to state 61

    condition_operator             shift and go to state 65

state 47

    (58) number -> FLOAT .

    DOUBLEQUAL      reduce using rule 58 (number -> FLOAT .)
    LESSTHAN        reduce using rule 58 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 58 (number -> FLOAT .)
    AND             reduce using rule 58 (number -> FLOAT .)
    OR              reduce using rule 58 (number -> FLOAT .)
    RPAREN          reduce using rule 58 (number -> FLOAT .)


state 48

    (59) number -> INTEGER .

    DOUBLEQUAL      reduce using rule 59 (number -> INTEGER .)
    LESSTHAN        reduce using rule 59 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 59 (number -> INTEGER .)
    AND             reduce using rule 59 (number -> INTEGER .)
    OR              reduce using rule 59 (number -> INTEGER .)
    RPAREN          reduce using rule 59 (number -> INTEGER .)


state 49

    (2) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (22) map_content -> . map_pairs
    (23) map_content -> . empty
    (25) map_pairs -> . map_pair
    (26) map_pairs -> . map_pair COMMA map_pairs
    (21) empty -> .
    (24) map_pair -> . map_key COLON map_value
    (27) map_key -> . value
    (42) value -> . INTEGER
    (43) value -> . FLOAT
    (44) value -> . STR
    (45) value -> . BOOLEAN
    (46) value -> . IDENTIFIER

    RCURLYBRACKET   reduce using rule 21 (empty -> .)
    INTEGER         shift and go to state 73
    FLOAT           shift and go to state 74
    STR             shift and go to state 75
    BOOLEAN         shift and go to state 76
    IDENTIFIER      shift and go to state 66

    map_content                    shift and go to state 67
    map_pairs                      shift and go to state 68
    empty                          shift and go to state 69
    map_pair                       shift and go to state 70
    map_key                        shift and go to state 71
    value                          shift and go to state 72

state 50

    (5) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    MAP             shift and go to state 4

    datatype                       shift and go to state 77
    map_identifier                 shift and go to state 33

state 51

    (82) declarationExpression -> datatype IDENTIFIER . SEMICOLON
    (83) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON

    SEMICOLON       shift and go to state 78
    EQUAL           shift and go to state 79


state 52

    (69) function_lambda -> returnType IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (72) function_arguments_repeat -> . function_argument
    (73) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (70) function_argument -> . datatype IDENTIFIER
    (71) function_argument -> . empty
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (21) empty -> .
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    COMMA           reduce using rule 21 (empty -> .)
    LCURLYBRACKET   reduce using rule 21 (empty -> .)
    RPAREN          reduce using rule 21 (empty -> .)
    MAP             shift and go to state 4

    function_arguments_repeat      shift and go to state 80
    function_argument              shift and go to state 81
    datatype                       shift and go to state 82
    empty                          shift and go to state 83
    map_identifier                 shift and go to state 33

state 53

    (35) elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .

    ELSE            reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    STRING          reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)


state 54

    (33) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 84


state 55

    (66) conditions -> condition condition_connector . conditions
    (65) conditions -> . condition
    (66) conditions -> . condition condition_connector conditions
    (60) condition -> . IDENTIFIER condition_operator condition_values
    (61) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (62) condition -> . BOOLEAN condition_operator BOOLEAN
    (63) condition -> . number condition_operator number
    (64) condition -> . STR condition_operator STR
    (58) number -> . FLOAT
    (59) number -> . INTEGER

    IDENTIFIER      shift and go to state 42
    EXMARK          shift and go to state 43
    BOOLEAN         shift and go to state 44
    STR             shift and go to state 46
    FLOAT           shift and go to state 47
    INTEGER         shift and go to state 48

    condition                      shift and go to state 41
    conditions                     shift and go to state 85
    number                         shift and go to state 45

state 56

    (67) condition_connector -> AND .

    IDENTIFIER      reduce using rule 67 (condition_connector -> AND .)
    EXMARK          reduce using rule 67 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 67 (condition_connector -> AND .)
    STR             reduce using rule 67 (condition_connector -> AND .)
    FLOAT           reduce using rule 67 (condition_connector -> AND .)
    INTEGER         reduce using rule 67 (condition_connector -> AND .)


state 57

    (68) condition_connector -> OR .

    IDENTIFIER      reduce using rule 68 (condition_connector -> OR .)
    EXMARK          reduce using rule 68 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 68 (condition_connector -> OR .)
    STR             reduce using rule 68 (condition_connector -> OR .)
    FLOAT           reduce using rule 68 (condition_connector -> OR .)
    INTEGER         reduce using rule 68 (condition_connector -> OR .)


state 58

    (60) condition -> IDENTIFIER condition_operator . condition_values
    (51) condition_values -> . negation_values
    (52) condition_values -> . INTEGER
    (53) condition_values -> . FLOAT
    (54) condition_values -> . STR
    (49) negation_values -> . deniable_values
    (50) negation_values -> . EXMARK deniable_values
    (47) deniable_values -> . IDENTIFIER
    (48) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 89
    FLOAT           shift and go to state 90
    STR             shift and go to state 91
    EXMARK          shift and go to state 93
    IDENTIFIER      shift and go to state 86
    BOOLEAN         shift and go to state 94

    condition_values               shift and go to state 87
    negation_values                shift and go to state 88
    deniable_values                shift and go to state 92

state 59

    (55) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 55 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 55 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 55 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 55 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 55 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 55 (condition_operator -> DOUBLEQUAL .)


state 60

    (56) condition_operator -> LESSTHAN .

    INTEGER         reduce using rule 56 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 56 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 56 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 56 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 56 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 56 (condition_operator -> LESSTHAN .)


state 61

    (57) condition_operator -> GREATERTHAN .

    INTEGER         reduce using rule 57 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 57 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 57 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 57 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 57 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 57 (condition_operator -> GREATERTHAN .)


state 62

    (61) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (55) condition_operator -> . DOUBLEQUAL
    (56) condition_operator -> . LESSTHAN
    (57) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 59
    LESSTHAN        shift and go to state 60
    GREATERTHAN     shift and go to state 61

    condition_operator             shift and go to state 95

state 63

    (62) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 96


state 64

    (63) condition -> number condition_operator . number
    (58) number -> . FLOAT
    (59) number -> . INTEGER

    FLOAT           shift and go to state 47
    INTEGER         shift and go to state 48

    number                         shift and go to state 97

state 65

    (64) condition -> STR condition_operator . STR

    STR             shift and go to state 98


state 66

    (46) value -> IDENTIFIER .

    COLON           reduce using rule 46 (value -> IDENTIFIER .)
    COMMA           reduce using rule 46 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 46 (value -> IDENTIFIER .)


state 67

    (2) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 99


state 68

    (22) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 22 (map_content -> map_pairs .)


state 69

    (23) map_content -> empty .

    RCURLYBRACKET   reduce using rule 23 (map_content -> empty .)


state 70

    (25) map_pairs -> map_pair .
    (26) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 25 (map_pairs -> map_pair .)
    COMMA           shift and go to state 100


state 71

    (24) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 101


state 72

    (27) map_key -> value .

    COLON           reduce using rule 27 (map_key -> value .)


state 73

    (42) value -> INTEGER .

    COLON           reduce using rule 42 (value -> INTEGER .)
    COMMA           reduce using rule 42 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 42 (value -> INTEGER .)


state 74

    (43) value -> FLOAT .

    COLON           reduce using rule 43 (value -> FLOAT .)
    COMMA           reduce using rule 43 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 43 (value -> FLOAT .)


state 75

    (44) value -> STR .

    COLON           reduce using rule 44 (value -> STR .)
    COMMA           reduce using rule 44 (value -> STR .)
    RCURLYBRACKET   reduce using rule 44 (value -> STR .)


state 76

    (45) value -> BOOLEAN .

    COLON           reduce using rule 45 (value -> BOOLEAN .)
    COMMA           reduce using rule 45 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 45 (value -> BOOLEAN .)


state 77

    (5) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 102


state 78

    (82) declarationExpression -> datatype IDENTIFIER SEMICOLON .

    $end            reduce using rule 82 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)


state 79

    (83) declarationExpression -> datatype IDENTIFIER EQUAL . expression SEMICOLON
    (79) expression -> . IDENTIFIER PLUS IDENTIFIER
    (80) expression -> . IDENTIFIER MINUS IDENTIFIER
    (81) expression -> . IDENTIFIER

    IDENTIFIER      shift and go to state 103

    expression                     shift and go to state 104

state 80

    (69) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (74) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (75) optFunction_argumentsExpression -> . empty
    (21) empty -> .

    LCURLYBRACKET   shift and go to state 106
    RPAREN          reduce using rule 21 (empty -> .)

    optFunction_argumentsExpression shift and go to state 105
    empty                          shift and go to state 107

state 81

    (72) function_arguments_repeat -> function_argument .
    (73) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    LCURLYBRACKET   reduce using rule 72 (function_arguments_repeat -> function_argument .)
    RPAREN          reduce using rule 72 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 108


state 82

    (70) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 109


state 83

    (71) function_argument -> empty .

    COMMA           reduce using rule 71 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 71 (function_argument -> empty .)
    RPAREN          reduce using rule 71 (function_argument -> empty .)


state 84

    (33) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 110


state 85

    (66) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 66 (conditions -> condition condition_connector conditions .)


state 86

    (47) deniable_values -> IDENTIFIER .

    AND             reduce using rule 47 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 47 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 47 (deniable_values -> IDENTIFIER .)


state 87

    (60) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 60 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 60 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 60 (condition -> IDENTIFIER condition_operator condition_values .)


state 88

    (51) condition_values -> negation_values .

    AND             reduce using rule 51 (condition_values -> negation_values .)
    OR              reduce using rule 51 (condition_values -> negation_values .)
    RPAREN          reduce using rule 51 (condition_values -> negation_values .)


state 89

    (52) condition_values -> INTEGER .

    AND             reduce using rule 52 (condition_values -> INTEGER .)
    OR              reduce using rule 52 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 52 (condition_values -> INTEGER .)


state 90

    (53) condition_values -> FLOAT .

    AND             reduce using rule 53 (condition_values -> FLOAT .)
    OR              reduce using rule 53 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 53 (condition_values -> FLOAT .)


state 91

    (54) condition_values -> STR .

    AND             reduce using rule 54 (condition_values -> STR .)
    OR              reduce using rule 54 (condition_values -> STR .)
    RPAREN          reduce using rule 54 (condition_values -> STR .)


state 92

    (49) negation_values -> deniable_values .

    AND             reduce using rule 49 (negation_values -> deniable_values .)
    OR              reduce using rule 49 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 49 (negation_values -> deniable_values .)


state 93

    (50) negation_values -> EXMARK . deniable_values
    (47) deniable_values -> . IDENTIFIER
    (48) deniable_values -> . BOOLEAN

    IDENTIFIER      shift and go to state 86
    BOOLEAN         shift and go to state 94

    deniable_values                shift and go to state 111

state 94

    (48) deniable_values -> BOOLEAN .

    AND             reduce using rule 48 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 48 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 48 (deniable_values -> BOOLEAN .)


state 95

    (61) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (51) condition_values -> . negation_values
    (52) condition_values -> . INTEGER
    (53) condition_values -> . FLOAT
    (54) condition_values -> . STR
    (49) negation_values -> . deniable_values
    (50) negation_values -> . EXMARK deniable_values
    (47) deniable_values -> . IDENTIFIER
    (48) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 89
    FLOAT           shift and go to state 90
    STR             shift and go to state 91
    EXMARK          shift and go to state 93
    IDENTIFIER      shift and go to state 86
    BOOLEAN         shift and go to state 94

    condition_values               shift and go to state 112
    negation_values                shift and go to state 88
    deniable_values                shift and go to state 92

state 96

    (62) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 62 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 62 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 62 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 97

    (63) condition -> number condition_operator number .

    AND             reduce using rule 63 (condition -> number condition_operator number .)
    OR              reduce using rule 63 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 63 (condition -> number condition_operator number .)


state 98

    (64) condition -> STR condition_operator STR .

    AND             reduce using rule 64 (condition -> STR condition_operator STR .)
    OR              reduce using rule 64 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 64 (condition -> STR condition_operator STR .)


state 99

    (2) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 113


state 100

    (26) map_pairs -> map_pair COMMA . map_pairs
    (25) map_pairs -> . map_pair
    (26) map_pairs -> . map_pair COMMA map_pairs
    (24) map_pair -> . map_key COLON map_value
    (27) map_key -> . value
    (42) value -> . INTEGER
    (43) value -> . FLOAT
    (44) value -> . STR
    (45) value -> . BOOLEAN
    (46) value -> . IDENTIFIER

    INTEGER         shift and go to state 73
    FLOAT           shift and go to state 74
    STR             shift and go to state 75
    BOOLEAN         shift and go to state 76
    IDENTIFIER      shift and go to state 66

    map_pair                       shift and go to state 70
    map_pairs                      shift and go to state 114
    map_key                        shift and go to state 71
    value                          shift and go to state 72

state 101

    (24) map_pair -> map_key COLON . map_value
    (28) map_value -> . value
    (42) value -> . INTEGER
    (43) value -> . FLOAT
    (44) value -> . STR
    (45) value -> . BOOLEAN
    (46) value -> . IDENTIFIER

    INTEGER         shift and go to state 73
    FLOAT           shift and go to state 74
    STR             shift and go to state 75
    BOOLEAN         shift and go to state 76
    IDENTIFIER      shift and go to state 66

    map_value                      shift and go to state 115
    value                          shift and go to state 116

state 102

    (5) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 5 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 5 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 5 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 103

    (79) expression -> IDENTIFIER . PLUS IDENTIFIER
    (80) expression -> IDENTIFIER . MINUS IDENTIFIER
    (81) expression -> IDENTIFIER .

    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    SEMICOLON       reduce using rule 81 (expression -> IDENTIFIER .)


state 104

    (83) declarationExpression -> datatype IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 119


state 105

    (69) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 120


state 106

    (74) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (77) optFunction_arguments -> . optFunction_argument
    (78) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (76) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 123

    optFunction_arguments          shift and go to state 121
    optFunction_argument           shift and go to state 122

state 107

    (75) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 75 (optFunction_argumentsExpression -> empty .)


state 108

    (73) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (72) function_arguments_repeat -> . function_argument
    (73) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (70) function_argument -> . datatype IDENTIFIER
    (71) function_argument -> . empty
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (21) empty -> .
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    COMMA           reduce using rule 21 (empty -> .)
    LCURLYBRACKET   reduce using rule 21 (empty -> .)
    RPAREN          reduce using rule 21 (empty -> .)
    MAP             shift and go to state 4

    function_argument              shift and go to state 81
    function_arguments_repeat      shift and go to state 124
    datatype                       shift and go to state 82
    empty                          shift and go to state 83
    map_identifier                 shift and go to state 33

state 109

    (70) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 70 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 70 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 70 (function_argument -> datatype IDENTIFIER .)


state 110

    (33) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .

    ELSE            reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STRING          reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)


state 111

    (50) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 50 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 50 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 50 (negation_values -> EXMARK deniable_values .)


state 112

    (61) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 61 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 61 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 61 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 113

    (2) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    IF              reduce using rule 2 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 114

    (26) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 26 (map_pairs -> map_pair COMMA map_pairs .)


state 115

    (24) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 24 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 24 (map_pair -> map_key COLON map_value .)


state 116

    (28) map_value -> value .

    COMMA           reduce using rule 28 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 28 (map_value -> value .)


state 117

    (79) expression -> IDENTIFIER PLUS . IDENTIFIER

    IDENTIFIER      shift and go to state 125


state 118

    (80) expression -> IDENTIFIER MINUS . IDENTIFIER

    IDENTIFIER      shift and go to state 126


state 119

    (83) declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .

    $end            reduce using rule 83 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)


state 120

    (69) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 127


state 121

    (74) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 128


state 122

    (77) optFunction_arguments -> optFunction_argument .
    (78) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 77 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 129


state 123

    (76) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    MAP             shift and go to state 4

    datatype                       shift and go to state 130
    map_identifier                 shift and go to state 33

state 124

    (73) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    LCURLYBRACKET   reduce using rule 73 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    RPAREN          reduce using rule 73 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 125

    (79) expression -> IDENTIFIER PLUS IDENTIFIER .

    SEMICOLON       reduce using rule 79 (expression -> IDENTIFIER PLUS IDENTIFIER .)


state 126

    (80) expression -> IDENTIFIER MINUS IDENTIFIER .

    SEMICOLON       reduce using rule 80 (expression -> IDENTIFIER MINUS IDENTIFIER .)


state 127

    (69) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 131


state 128

    (74) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 74 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 129

    (78) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (77) optFunction_arguments -> . optFunction_argument
    (78) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (76) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 123

    optFunction_argument           shift and go to state 122
    optFunction_arguments          shift and go to state 132

state 130

    (76) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 133


state 131

    (69) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (79) expression -> . IDENTIFIER PLUS IDENTIFIER
    (80) expression -> . IDENTIFIER MINUS IDENTIFIER
    (81) expression -> . IDENTIFIER

    IDENTIFIER      shift and go to state 103

    expression                     shift and go to state 134

state 132

    (78) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 78 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 133

    (76) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 76 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 76 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 134

    (69) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 135


state 135

    (69) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    INT             reduce using rule 69 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STRING          reduce using rule 69 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOL            reduce using rule 69 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DOUBLE          reduce using rule 69 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DYNAMIC         reduce using rule 69 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VAR             reduce using rule 69 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VOID            reduce using rule 69 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAP             reduce using rule 69 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)

