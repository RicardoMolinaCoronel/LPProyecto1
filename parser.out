Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    APOSTROPHE
    ASSERT
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CLOSE
    COMMENT
    COMMENTMULTI
    CONST
    CONTINUE
    DEFAULT
    DEFERRED
    DO
    DOLLAR
    DOUBQUOTMARK
    ENUM
    EXIT
    EXPORT
    EXTENSION
    EXTERNAL
    FACTORY
    FILE
    FUNCTION
    GET
    IMPLEMENTS
    IMPORT
    IN
    IS
    ITERABLE
    LIBRARY
    METHOD
    NOTEQUAL
    OPENWRITE
    READLINESYNC
    SET
    TRY
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> class_content_repeat
Rule 2     class -> declarationMain class_content_repeat
Rule 3     class -> class_content_repeat declarationMain
Rule 4     class -> declarationMain
Rule 5     class_content -> map
Rule 6     class_content -> ifElseStatement
Rule 7     class_content -> function_lambda
Rule 8     class_content -> declarationExpression
Rule 9     class_content -> forStatement
Rule 10    class_content -> while
Rule 11    class_content -> stack
Rule 12    class_content -> inferedReturnFunction
Rule 13    class_content -> expression SEMICOLON
Rule 14    class_content -> print
Rule 15    class_content_repeat -> class_content
Rule 16    class_content_repeat -> class_content_repeat class_content
Rule 17    declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 18    datatypeOpt -> datatype
Rule 19    datatypeOpt -> empty
Rule 20    class_content -> semanticbool
Rule 21    class_content -> semanticlist
Rule 22    class_content -> asign
Rule 23    map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 24    map_identifier -> MAP
Rule 25    map_identifier -> MAP map_type_specified
Rule 26    map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 27    datatype -> INT
Rule 28    datatype -> STRING
Rule 29    datatype -> BOOL
Rule 30    datatype -> DOUBLE
Rule 31    datatype -> DYNAMIC
Rule 32    datatype -> VOID
Rule 33    datatype -> map_identifier
Rule 34    datatype -> VAR
Rule 35    returnType -> INT
Rule 36    returnType -> STRING
Rule 37    returnType -> BOOL
Rule 38    returnType -> DOUBLE
Rule 39    returnType -> DYNAMIC
Rule 40    returnType -> VOID
Rule 41    returnType -> map_identifier
Rule 42    print -> PRINT LPAREN value RPAREN SEMICOLON
Rule 43    empty -> <empty>
Rule 44    map_content -> map_pairs
Rule 45    map_content -> empty
Rule 46    map_pair -> map_key COLON map_value
Rule 47    map_pairs -> map_pair
Rule 48    map_pairs -> map_pair COMMA map_pairs
Rule 49    map_key -> value
Rule 50    map_value -> value
Rule 51    ifElseStatement -> ifStatement
Rule 52    ifElseStatement -> ifStatement elifStatement_repeat
Rule 53    elifStatement_repeat -> elifStatement
Rule 54    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 55    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 56    elifStatement -> ELSE ifStatement
Rule 57    elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 58    forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 59    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
Rule 60    while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 61    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
Rule 62    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 63    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
Rule 64    value -> INTEGER
Rule 65    value -> FLOAT
Rule 66    value -> STR
Rule 67    value -> BOOLEAN
Rule 68    value -> IDENTIFIER
Rule 69    value -> booleanOp
Rule 70    value -> propertiesAccess
Rule 71    opt_value -> value
Rule 72    opt_value -> empty
Rule 73    deniable_values -> IDENTIFIER
Rule 74    deniable_values -> BOOLEAN
Rule 75    deniable_values -> booleanOp
Rule 76    negation_values -> deniable_values
Rule 77    negation_values -> EXMARK deniable_values
Rule 78    condition_values -> negation_values
Rule 79    condition_values -> INTEGER
Rule 80    condition_values -> FLOAT
Rule 81    condition_values -> STR
Rule 82    condition_values -> NULL
Rule 83    condition_operator -> DOUBLEQUAL
Rule 84    condition_operator -> LESSTHAN
Rule 85    condition_operator -> GREATERTHAN
Rule 86    condition_operator -> LESSTHAN EQUAL
Rule 87    condition_operator -> GREATERTHAN EQUAL
Rule 88    number -> FLOAT
Rule 89    number -> INTEGER
Rule 90    condition -> IDENTIFIER condition_operator condition_values
Rule 91    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 92    condition -> BOOLEAN condition_operator BOOLEAN
Rule 93    condition -> number condition_operator number
Rule 94    condition -> STR condition_operator STR
Rule 95    condition -> booleanOp condition_operator booleanOp
Rule 96    condition -> negation_values
Rule 97    conditions -> condition
Rule 98    conditions -> condition condition_connector conditions
Rule 99    condition_connector -> AND
Rule 100   condition_connector -> OR
Rule 101   condition_connector -> AMPERSAND AMPERSAND
Rule 102   condition_connector -> PIPELINE PIPELINE
Rule 103   function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 104   function_argument -> datatype IDENTIFIER
Rule 105   function_argument -> empty
Rule 106   function_arguments_repeat -> function_argument
Rule 107   function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 108   optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 109   optFunction_argumentsExpression -> empty
Rule 110   optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 111   optFunction_arguments -> optFunction_argument
Rule 112   optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 113   expression -> value
Rule 114   expression -> value operatorExpression expression
Rule 115   expression -> value operatorExpression operatorExpression
Rule 116   asign -> IDENTIFIER EQUAL expression SEMICOLON
Rule 117   asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON
Rule 118   otherAsignations -> PLUS
Rule 119   otherAsignations -> MINUS
Rule 120   otherAsignations -> TIMES
Rule 121   otherAsignations -> DIVISION
Rule 122   otherAsignations -> REST
Rule 123   operableTypes -> IDENTIFIER
Rule 124   operableTypes -> number
Rule 125   operatorExpression -> PLUS
Rule 126   operatorExpression -> MINUS
Rule 127   operatorExpression -> TIMES
Rule 128   operatorExpression -> DIVISION
Rule 129   operatorExpression -> REST
Rule 130   declarationExpression -> datatype repeatDeclaration SEMICOLON
Rule 131   repeatDeclaration -> IDENTIFIER
Rule 132   repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration
Rule 133   declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON
Rule 134   declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
Rule 135   declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON
Rule 136   semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON
Rule 137   booleanOp -> TRUE
Rule 138   booleanOp -> FALSE
Rule 139   booloperation -> booleanOp condition_connector booleanOp
Rule 140   booloperation -> IDENTIFIER condition_connector booleanOp
Rule 141   booloperation -> IDENTIFIER condition_connector IDENTIFIER
Rule 142   booloperation -> booleanOp condition_connector IDENTIFIER
Rule 143   booloperations -> booloperation
Rule 144   booloperations -> booloperation condition_connector booloperations
Rule 145   semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
Rule 146   semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
Rule 147   semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
Rule 148   semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
Rule 149   semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
Rule 150   insidelist -> value
Rule 151   insidelist -> value COMMA insidelist
Rule 152   insidelistint -> INTEGER
Rule 153   insidelistint -> INTEGER COMMA insidelistint
Rule 154   insideliststr -> STR
Rule 155   insideliststr -> STR COMMA insideliststr
Rule 156   insidelistbool -> booleanOp
Rule 157   insidelistbool -> booleanOp COMMA insidelistbool
Rule 158   insidelistdouble -> FLOAT
Rule 159   insidelistdouble -> FLOAT COMMA insidelistdouble
Rule 160   declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON
Rule 161   declarationExpression -> STRING IDENTIFIER SEMICOLON
Rule 162   expressionString -> STR
Rule 163   expressionString -> STR operatorExpressionString expressionString
Rule 164   operatorExpressionString -> PLUS
Rule 165   declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON
Rule 166   declarationExpression -> INT IDENTIFIER SEMICOLON
Rule 167   expressionInteger -> number
Rule 168   expressionInteger -> number operatorExpression expressionInteger
Rule 169   expressionInteger -> IDENTIFIER
Rule 170   expressionInteger -> IDENTIFIER operatorExpression expressionInteger
Rule 171   properties -> KEYS
Rule 172   properties -> VALUES
Rule 173   propertiesAccess -> IDENTIFIER DOT properties

Terminals, with rules where they appear

ABSTRACT             : 
AMPERSAND            : 101 101
AND                  : 99
APOSTROPHE           : 
ASSERT               : 
ASYNC                : 
AWAIT                : 
BOOL                 : 29 37 136 148
BOOLEAN              : 67 74 92 92
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
CLOSE                : 
COLON                : 46
COMMA                : 26 48 107 112 132 151 153 155 157 159
COMMENT              : 
COMMENTMULTI         : 
CONST                : 
CONTINUE             : 
DEFAULT              : 
DEFERRED             : 
DIVISION             : 121 128
DO                   : 
DOLLAR               : 
DOT                  : 62 173
DOUBLE               : 30 38 149
DOUBLEQUAL           : 83
DOUBQUOTMARK         : 
DYNAMIC              : 31 39 145
ELSE                 : 56 57
ENUM                 : 
EQUAL                : 23 59 61 62 86 87 103 116 117 133 134 135 136 145 146 147 148 149 160 165
EXIT                 : 
EXMARK               : 77 91
EXPORT               : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 138
FILE                 : 
FINAL                : 59 61 62 135
FLOAT                : 65 80 88 158 159
FOR                  : 58
FUNCTION             : 
GET                  : 
GREATERTHAN          : 26 59 61 85 87 103 145 146 147 148 149
IDENTIFIER           : 23 59 61 62 62 63 68 73 90 91 103 104 110 116 117 123 131 132 133 134 134 135 136 140 141 141 142 145 146 147 148 149 160 161 165 166 169 170 173
IF                   : 55
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INT                  : 27 35 146 165 166
INTEGER              : 64 79 89 152 153
IS                   : 
ITERABLE             : 
KEYS                 : 171
LCURLYBRACKET        : 17 23 55 57 58 60 63 108
LESSTHAN             : 26 59 61 84 86 145 146 147 148 149
LIBRARY              : 
LIST                 : 145 146 147 148 149
LPAREN               : 17 42 55 58 59 60 61 62 63 103 134
LSQUAREBRACKET       : 145 146 147 148 149
MAIN                 : 17
MAP                  : 24 25
METHOD               : 
MINUS                : 119 126
NOTEQUAL             : 
NULL                 : 82
OF                   : 62
OPENWRITE            : 
OR                   : 100
PIPELINE             : 102 102
PLUS                 : 118 125 164
PRINT                : 42
RCURLYBRACKET        : 17 23 55 57 58 60 63 108
READLINESYNC         : 
REQUIRED             : 110
REST                 : 122 129
RETURN               : 63
RPAREN               : 17 42 55 58 59 60 61 62 63 103 134
RSQUAREBRACKET       : 145 146 147 148 149
SEMICOLON            : 13 23 42 58 58 59 61 62 63 103 116 117 130 133 134 135 136 145 146 147 148 149 160 161 165 166
SET                  : 
STACK                : 59 61 62
STR                  : 66 81 94 94 154 155 162 163
STRING               : 28 36 147 160 161
TIMES                : 120 127
TRUE                 : 137
TRY                  : 
VALUES               : 172
VAR                  : 34
VOID                 : 32 40
WHILE                : 60
WRITE                : 
error                : 

Nonterminals, with rules where they appear

asign                : 22
booleanOp            : 69 75 95 95 139 139 140 142 156 157
booloperation        : 143 144
booloperations       : 144
class                : 0
class_content        : 15 16
class_content_repeat : 1 2 3 16 17 55 57 60
condition            : 58 97 98
condition_connector  : 98 139 140 141 142 144
condition_operator   : 90 91 92 93 94 95
condition_values     : 90 91
conditions           : 55 60 98 136
datatype             : 18 26 26 59 61 103 104 110 130 133 134 134
datatypeOpt          : 17
declarationExpression : 8 58
declarationMain      : 2 3 4
deniable_values      : 76 77
elifStatement        : 53 54
elifStatement_repeat : 52 54
empty                : 19 45 72 105 109
expression           : 13 58 63 103 114 116 117 133 135
expressionInteger    : 165 168 170
expressionString     : 160 163
forStatement         : 9
function_argument    : 106 107
function_arguments_repeat : 63 103 107
function_lambda      : 7
ifElseStatement      : 6
ifStatement          : 51 52 56
inferedReturnFunction : 12
insidelist           : 145 151
insidelistbool       : 148 157
insidelistdouble     : 149 159
insidelistint        : 146 153
insideliststr        : 147 155
map                  : 5
map_content          : 23
map_identifier       : 23 33 41
map_key              : 46
map_pair             : 47 48
map_pairs            : 44 48
map_type_specified   : 25
map_value            : 46
negation_values      : 78 96
number               : 93 93 124 167 168
operableTypes        : 
operatorExpression   : 114 115 115 168 170
operatorExpressionString : 163
optFunction_argument : 111 112
optFunction_arguments : 108 112
optFunction_argumentsExpression : 103
opt_value            : 59
otherAsignations     : 117
print                : 14
properties           : 173
propertiesAccess     : 70
repeatDeclaration    : 130 132
returnType           : 
semanticbool         : 20
semanticlist         : 21
stack                : 11
value                : 42 49 50 71 113 114 115 150 151
while                : 10

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . class_content_repeat
    (2) class -> . declarationMain class_content_repeat
    (3) class -> . class_content_repeat declarationMain
    (4) class -> . declarationMain
    (15) class_content_repeat -> . class_content
    (16) class_content_repeat -> . class_content_repeat class_content
    (17) declarationMain -> . datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (18) datatypeOpt -> . datatype
    (19) datatypeOpt -> . empty
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (43) empty -> .
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    MAIN            reduce using rule 43 (empty -> .)
    MAP             shift and go to state 37
    IF              shift and go to state 38
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class                          shift and go to state 1
    class_content_repeat           shift and go to state 2
    declarationMain                shift and go to state 3
    class_content                  shift and go to state 4
    datatypeOpt                    shift and go to state 5
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    datatype                       shift and go to state 19
    empty                          shift and go to state 20
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 1

    (0) S' -> class .



state 2

    (1) class -> class_content_repeat .
    (3) class -> class_content_repeat . declarationMain
    (16) class_content_repeat -> class_content_repeat . class_content
    (17) declarationMain -> . datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (18) datatypeOpt -> . datatype
    (19) datatypeOpt -> . empty
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (43) empty -> .
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    $end            reduce using rule 1 (class -> class_content_repeat .)
    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    MAIN            reduce using rule 43 (empty -> .)
    MAP             shift and go to state 37
    IF              shift and go to state 38
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    declarationMain                shift and go to state 47
    class_content                  shift and go to state 48
    datatypeOpt                    shift and go to state 5
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    datatype                       shift and go to state 19
    empty                          shift and go to state 20
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 3

    (2) class -> declarationMain . class_content_repeat
    (4) class -> declarationMain .
    (15) class_content_repeat -> . class_content
    (16) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    $end            reduce using rule 4 (class -> declarationMain .)
    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content_repeat           shift and go to state 49
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 4

    (15) class_content_repeat -> class_content .

    FINAL           reduce using rule 15 (class_content_repeat -> class_content .)
    STRING          reduce using rule 15 (class_content_repeat -> class_content .)
    INT             reduce using rule 15 (class_content_repeat -> class_content .)
    FOR             reduce using rule 15 (class_content_repeat -> class_content .)
    WHILE           reduce using rule 15 (class_content_repeat -> class_content .)
    IDENTIFIER      reduce using rule 15 (class_content_repeat -> class_content .)
    PRINT           reduce using rule 15 (class_content_repeat -> class_content .)
    BOOL            reduce using rule 15 (class_content_repeat -> class_content .)
    LIST            reduce using rule 15 (class_content_repeat -> class_content .)
    DOUBLE          reduce using rule 15 (class_content_repeat -> class_content .)
    DYNAMIC         reduce using rule 15 (class_content_repeat -> class_content .)
    VOID            reduce using rule 15 (class_content_repeat -> class_content .)
    VAR             reduce using rule 15 (class_content_repeat -> class_content .)
    MAP             reduce using rule 15 (class_content_repeat -> class_content .)
    IF              reduce using rule 15 (class_content_repeat -> class_content .)
    INTEGER         reduce using rule 15 (class_content_repeat -> class_content .)
    FLOAT           reduce using rule 15 (class_content_repeat -> class_content .)
    STR             reduce using rule 15 (class_content_repeat -> class_content .)
    BOOLEAN         reduce using rule 15 (class_content_repeat -> class_content .)
    TRUE            reduce using rule 15 (class_content_repeat -> class_content .)
    FALSE           reduce using rule 15 (class_content_repeat -> class_content .)
    MAIN            reduce using rule 15 (class_content_repeat -> class_content .)
    $end            reduce using rule 15 (class_content_repeat -> class_content .)
    RCURLYBRACKET   reduce using rule 15 (class_content_repeat -> class_content .)


state 5

    (17) declarationMain -> datatypeOpt . MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    MAIN            shift and go to state 51


state 6

    (5) class_content -> map .

    FINAL           reduce using rule 5 (class_content -> map .)
    STRING          reduce using rule 5 (class_content -> map .)
    INT             reduce using rule 5 (class_content -> map .)
    FOR             reduce using rule 5 (class_content -> map .)
    WHILE           reduce using rule 5 (class_content -> map .)
    IDENTIFIER      reduce using rule 5 (class_content -> map .)
    PRINT           reduce using rule 5 (class_content -> map .)
    BOOL            reduce using rule 5 (class_content -> map .)
    LIST            reduce using rule 5 (class_content -> map .)
    DOUBLE          reduce using rule 5 (class_content -> map .)
    DYNAMIC         reduce using rule 5 (class_content -> map .)
    VOID            reduce using rule 5 (class_content -> map .)
    VAR             reduce using rule 5 (class_content -> map .)
    MAP             reduce using rule 5 (class_content -> map .)
    IF              reduce using rule 5 (class_content -> map .)
    INTEGER         reduce using rule 5 (class_content -> map .)
    FLOAT           reduce using rule 5 (class_content -> map .)
    STR             reduce using rule 5 (class_content -> map .)
    BOOLEAN         reduce using rule 5 (class_content -> map .)
    TRUE            reduce using rule 5 (class_content -> map .)
    FALSE           reduce using rule 5 (class_content -> map .)
    MAIN            reduce using rule 5 (class_content -> map .)
    $end            reduce using rule 5 (class_content -> map .)
    RCURLYBRACKET   reduce using rule 5 (class_content -> map .)


state 7

    (6) class_content -> ifElseStatement .

    FINAL           reduce using rule 6 (class_content -> ifElseStatement .)
    STRING          reduce using rule 6 (class_content -> ifElseStatement .)
    INT             reduce using rule 6 (class_content -> ifElseStatement .)
    FOR             reduce using rule 6 (class_content -> ifElseStatement .)
    WHILE           reduce using rule 6 (class_content -> ifElseStatement .)
    IDENTIFIER      reduce using rule 6 (class_content -> ifElseStatement .)
    PRINT           reduce using rule 6 (class_content -> ifElseStatement .)
    BOOL            reduce using rule 6 (class_content -> ifElseStatement .)
    LIST            reduce using rule 6 (class_content -> ifElseStatement .)
    DOUBLE          reduce using rule 6 (class_content -> ifElseStatement .)
    DYNAMIC         reduce using rule 6 (class_content -> ifElseStatement .)
    VOID            reduce using rule 6 (class_content -> ifElseStatement .)
    VAR             reduce using rule 6 (class_content -> ifElseStatement .)
    MAP             reduce using rule 6 (class_content -> ifElseStatement .)
    IF              reduce using rule 6 (class_content -> ifElseStatement .)
    INTEGER         reduce using rule 6 (class_content -> ifElseStatement .)
    FLOAT           reduce using rule 6 (class_content -> ifElseStatement .)
    STR             reduce using rule 6 (class_content -> ifElseStatement .)
    BOOLEAN         reduce using rule 6 (class_content -> ifElseStatement .)
    TRUE            reduce using rule 6 (class_content -> ifElseStatement .)
    FALSE           reduce using rule 6 (class_content -> ifElseStatement .)
    MAIN            reduce using rule 6 (class_content -> ifElseStatement .)
    $end            reduce using rule 6 (class_content -> ifElseStatement .)
    RCURLYBRACKET   reduce using rule 6 (class_content -> ifElseStatement .)


state 8

    (7) class_content -> function_lambda .

    FINAL           reduce using rule 7 (class_content -> function_lambda .)
    STRING          reduce using rule 7 (class_content -> function_lambda .)
    INT             reduce using rule 7 (class_content -> function_lambda .)
    FOR             reduce using rule 7 (class_content -> function_lambda .)
    WHILE           reduce using rule 7 (class_content -> function_lambda .)
    IDENTIFIER      reduce using rule 7 (class_content -> function_lambda .)
    PRINT           reduce using rule 7 (class_content -> function_lambda .)
    BOOL            reduce using rule 7 (class_content -> function_lambda .)
    LIST            reduce using rule 7 (class_content -> function_lambda .)
    DOUBLE          reduce using rule 7 (class_content -> function_lambda .)
    DYNAMIC         reduce using rule 7 (class_content -> function_lambda .)
    VOID            reduce using rule 7 (class_content -> function_lambda .)
    VAR             reduce using rule 7 (class_content -> function_lambda .)
    MAP             reduce using rule 7 (class_content -> function_lambda .)
    IF              reduce using rule 7 (class_content -> function_lambda .)
    INTEGER         reduce using rule 7 (class_content -> function_lambda .)
    FLOAT           reduce using rule 7 (class_content -> function_lambda .)
    STR             reduce using rule 7 (class_content -> function_lambda .)
    BOOLEAN         reduce using rule 7 (class_content -> function_lambda .)
    TRUE            reduce using rule 7 (class_content -> function_lambda .)
    FALSE           reduce using rule 7 (class_content -> function_lambda .)
    MAIN            reduce using rule 7 (class_content -> function_lambda .)
    $end            reduce using rule 7 (class_content -> function_lambda .)
    RCURLYBRACKET   reduce using rule 7 (class_content -> function_lambda .)


state 9

    (8) class_content -> declarationExpression .

    FINAL           reduce using rule 8 (class_content -> declarationExpression .)
    STRING          reduce using rule 8 (class_content -> declarationExpression .)
    INT             reduce using rule 8 (class_content -> declarationExpression .)
    FOR             reduce using rule 8 (class_content -> declarationExpression .)
    WHILE           reduce using rule 8 (class_content -> declarationExpression .)
    IDENTIFIER      reduce using rule 8 (class_content -> declarationExpression .)
    PRINT           reduce using rule 8 (class_content -> declarationExpression .)
    BOOL            reduce using rule 8 (class_content -> declarationExpression .)
    LIST            reduce using rule 8 (class_content -> declarationExpression .)
    DOUBLE          reduce using rule 8 (class_content -> declarationExpression .)
    DYNAMIC         reduce using rule 8 (class_content -> declarationExpression .)
    VOID            reduce using rule 8 (class_content -> declarationExpression .)
    VAR             reduce using rule 8 (class_content -> declarationExpression .)
    MAP             reduce using rule 8 (class_content -> declarationExpression .)
    IF              reduce using rule 8 (class_content -> declarationExpression .)
    INTEGER         reduce using rule 8 (class_content -> declarationExpression .)
    FLOAT           reduce using rule 8 (class_content -> declarationExpression .)
    STR             reduce using rule 8 (class_content -> declarationExpression .)
    BOOLEAN         reduce using rule 8 (class_content -> declarationExpression .)
    TRUE            reduce using rule 8 (class_content -> declarationExpression .)
    FALSE           reduce using rule 8 (class_content -> declarationExpression .)
    MAIN            reduce using rule 8 (class_content -> declarationExpression .)
    $end            reduce using rule 8 (class_content -> declarationExpression .)
    RCURLYBRACKET   reduce using rule 8 (class_content -> declarationExpression .)


state 10

    (9) class_content -> forStatement .

    FINAL           reduce using rule 9 (class_content -> forStatement .)
    STRING          reduce using rule 9 (class_content -> forStatement .)
    INT             reduce using rule 9 (class_content -> forStatement .)
    FOR             reduce using rule 9 (class_content -> forStatement .)
    WHILE           reduce using rule 9 (class_content -> forStatement .)
    IDENTIFIER      reduce using rule 9 (class_content -> forStatement .)
    PRINT           reduce using rule 9 (class_content -> forStatement .)
    BOOL            reduce using rule 9 (class_content -> forStatement .)
    LIST            reduce using rule 9 (class_content -> forStatement .)
    DOUBLE          reduce using rule 9 (class_content -> forStatement .)
    DYNAMIC         reduce using rule 9 (class_content -> forStatement .)
    VOID            reduce using rule 9 (class_content -> forStatement .)
    VAR             reduce using rule 9 (class_content -> forStatement .)
    MAP             reduce using rule 9 (class_content -> forStatement .)
    IF              reduce using rule 9 (class_content -> forStatement .)
    INTEGER         reduce using rule 9 (class_content -> forStatement .)
    FLOAT           reduce using rule 9 (class_content -> forStatement .)
    STR             reduce using rule 9 (class_content -> forStatement .)
    BOOLEAN         reduce using rule 9 (class_content -> forStatement .)
    TRUE            reduce using rule 9 (class_content -> forStatement .)
    FALSE           reduce using rule 9 (class_content -> forStatement .)
    MAIN            reduce using rule 9 (class_content -> forStatement .)
    $end            reduce using rule 9 (class_content -> forStatement .)
    RCURLYBRACKET   reduce using rule 9 (class_content -> forStatement .)


state 11

    (10) class_content -> while .

    FINAL           reduce using rule 10 (class_content -> while .)
    STRING          reduce using rule 10 (class_content -> while .)
    INT             reduce using rule 10 (class_content -> while .)
    FOR             reduce using rule 10 (class_content -> while .)
    WHILE           reduce using rule 10 (class_content -> while .)
    IDENTIFIER      reduce using rule 10 (class_content -> while .)
    PRINT           reduce using rule 10 (class_content -> while .)
    BOOL            reduce using rule 10 (class_content -> while .)
    LIST            reduce using rule 10 (class_content -> while .)
    DOUBLE          reduce using rule 10 (class_content -> while .)
    DYNAMIC         reduce using rule 10 (class_content -> while .)
    VOID            reduce using rule 10 (class_content -> while .)
    VAR             reduce using rule 10 (class_content -> while .)
    MAP             reduce using rule 10 (class_content -> while .)
    IF              reduce using rule 10 (class_content -> while .)
    INTEGER         reduce using rule 10 (class_content -> while .)
    FLOAT           reduce using rule 10 (class_content -> while .)
    STR             reduce using rule 10 (class_content -> while .)
    BOOLEAN         reduce using rule 10 (class_content -> while .)
    TRUE            reduce using rule 10 (class_content -> while .)
    FALSE           reduce using rule 10 (class_content -> while .)
    MAIN            reduce using rule 10 (class_content -> while .)
    $end            reduce using rule 10 (class_content -> while .)
    RCURLYBRACKET   reduce using rule 10 (class_content -> while .)


state 12

    (11) class_content -> stack .

    FINAL           reduce using rule 11 (class_content -> stack .)
    STRING          reduce using rule 11 (class_content -> stack .)
    INT             reduce using rule 11 (class_content -> stack .)
    FOR             reduce using rule 11 (class_content -> stack .)
    WHILE           reduce using rule 11 (class_content -> stack .)
    IDENTIFIER      reduce using rule 11 (class_content -> stack .)
    PRINT           reduce using rule 11 (class_content -> stack .)
    BOOL            reduce using rule 11 (class_content -> stack .)
    LIST            reduce using rule 11 (class_content -> stack .)
    DOUBLE          reduce using rule 11 (class_content -> stack .)
    DYNAMIC         reduce using rule 11 (class_content -> stack .)
    VOID            reduce using rule 11 (class_content -> stack .)
    VAR             reduce using rule 11 (class_content -> stack .)
    MAP             reduce using rule 11 (class_content -> stack .)
    IF              reduce using rule 11 (class_content -> stack .)
    INTEGER         reduce using rule 11 (class_content -> stack .)
    FLOAT           reduce using rule 11 (class_content -> stack .)
    STR             reduce using rule 11 (class_content -> stack .)
    BOOLEAN         reduce using rule 11 (class_content -> stack .)
    TRUE            reduce using rule 11 (class_content -> stack .)
    FALSE           reduce using rule 11 (class_content -> stack .)
    MAIN            reduce using rule 11 (class_content -> stack .)
    $end            reduce using rule 11 (class_content -> stack .)
    RCURLYBRACKET   reduce using rule 11 (class_content -> stack .)


state 13

    (12) class_content -> inferedReturnFunction .

    FINAL           reduce using rule 12 (class_content -> inferedReturnFunction .)
    STRING          reduce using rule 12 (class_content -> inferedReturnFunction .)
    INT             reduce using rule 12 (class_content -> inferedReturnFunction .)
    FOR             reduce using rule 12 (class_content -> inferedReturnFunction .)
    WHILE           reduce using rule 12 (class_content -> inferedReturnFunction .)
    IDENTIFIER      reduce using rule 12 (class_content -> inferedReturnFunction .)
    PRINT           reduce using rule 12 (class_content -> inferedReturnFunction .)
    BOOL            reduce using rule 12 (class_content -> inferedReturnFunction .)
    LIST            reduce using rule 12 (class_content -> inferedReturnFunction .)
    DOUBLE          reduce using rule 12 (class_content -> inferedReturnFunction .)
    DYNAMIC         reduce using rule 12 (class_content -> inferedReturnFunction .)
    VOID            reduce using rule 12 (class_content -> inferedReturnFunction .)
    VAR             reduce using rule 12 (class_content -> inferedReturnFunction .)
    MAP             reduce using rule 12 (class_content -> inferedReturnFunction .)
    IF              reduce using rule 12 (class_content -> inferedReturnFunction .)
    INTEGER         reduce using rule 12 (class_content -> inferedReturnFunction .)
    FLOAT           reduce using rule 12 (class_content -> inferedReturnFunction .)
    STR             reduce using rule 12 (class_content -> inferedReturnFunction .)
    BOOLEAN         reduce using rule 12 (class_content -> inferedReturnFunction .)
    TRUE            reduce using rule 12 (class_content -> inferedReturnFunction .)
    FALSE           reduce using rule 12 (class_content -> inferedReturnFunction .)
    MAIN            reduce using rule 12 (class_content -> inferedReturnFunction .)
    $end            reduce using rule 12 (class_content -> inferedReturnFunction .)
    RCURLYBRACKET   reduce using rule 12 (class_content -> inferedReturnFunction .)


state 14

    (13) class_content -> expression . SEMICOLON

    SEMICOLON       shift and go to state 52


state 15

    (14) class_content -> print .

    FINAL           reduce using rule 14 (class_content -> print .)
    STRING          reduce using rule 14 (class_content -> print .)
    INT             reduce using rule 14 (class_content -> print .)
    FOR             reduce using rule 14 (class_content -> print .)
    WHILE           reduce using rule 14 (class_content -> print .)
    IDENTIFIER      reduce using rule 14 (class_content -> print .)
    PRINT           reduce using rule 14 (class_content -> print .)
    BOOL            reduce using rule 14 (class_content -> print .)
    LIST            reduce using rule 14 (class_content -> print .)
    DOUBLE          reduce using rule 14 (class_content -> print .)
    DYNAMIC         reduce using rule 14 (class_content -> print .)
    VOID            reduce using rule 14 (class_content -> print .)
    VAR             reduce using rule 14 (class_content -> print .)
    MAP             reduce using rule 14 (class_content -> print .)
    IF              reduce using rule 14 (class_content -> print .)
    INTEGER         reduce using rule 14 (class_content -> print .)
    FLOAT           reduce using rule 14 (class_content -> print .)
    STR             reduce using rule 14 (class_content -> print .)
    BOOLEAN         reduce using rule 14 (class_content -> print .)
    TRUE            reduce using rule 14 (class_content -> print .)
    FALSE           reduce using rule 14 (class_content -> print .)
    MAIN            reduce using rule 14 (class_content -> print .)
    $end            reduce using rule 14 (class_content -> print .)
    RCURLYBRACKET   reduce using rule 14 (class_content -> print .)


state 16

    (20) class_content -> semanticbool .

    FINAL           reduce using rule 20 (class_content -> semanticbool .)
    STRING          reduce using rule 20 (class_content -> semanticbool .)
    INT             reduce using rule 20 (class_content -> semanticbool .)
    FOR             reduce using rule 20 (class_content -> semanticbool .)
    WHILE           reduce using rule 20 (class_content -> semanticbool .)
    IDENTIFIER      reduce using rule 20 (class_content -> semanticbool .)
    PRINT           reduce using rule 20 (class_content -> semanticbool .)
    BOOL            reduce using rule 20 (class_content -> semanticbool .)
    LIST            reduce using rule 20 (class_content -> semanticbool .)
    DOUBLE          reduce using rule 20 (class_content -> semanticbool .)
    DYNAMIC         reduce using rule 20 (class_content -> semanticbool .)
    VOID            reduce using rule 20 (class_content -> semanticbool .)
    VAR             reduce using rule 20 (class_content -> semanticbool .)
    MAP             reduce using rule 20 (class_content -> semanticbool .)
    IF              reduce using rule 20 (class_content -> semanticbool .)
    INTEGER         reduce using rule 20 (class_content -> semanticbool .)
    FLOAT           reduce using rule 20 (class_content -> semanticbool .)
    STR             reduce using rule 20 (class_content -> semanticbool .)
    BOOLEAN         reduce using rule 20 (class_content -> semanticbool .)
    TRUE            reduce using rule 20 (class_content -> semanticbool .)
    FALSE           reduce using rule 20 (class_content -> semanticbool .)
    MAIN            reduce using rule 20 (class_content -> semanticbool .)
    $end            reduce using rule 20 (class_content -> semanticbool .)
    RCURLYBRACKET   reduce using rule 20 (class_content -> semanticbool .)


state 17

    (21) class_content -> semanticlist .

    FINAL           reduce using rule 21 (class_content -> semanticlist .)
    STRING          reduce using rule 21 (class_content -> semanticlist .)
    INT             reduce using rule 21 (class_content -> semanticlist .)
    FOR             reduce using rule 21 (class_content -> semanticlist .)
    WHILE           reduce using rule 21 (class_content -> semanticlist .)
    IDENTIFIER      reduce using rule 21 (class_content -> semanticlist .)
    PRINT           reduce using rule 21 (class_content -> semanticlist .)
    BOOL            reduce using rule 21 (class_content -> semanticlist .)
    LIST            reduce using rule 21 (class_content -> semanticlist .)
    DOUBLE          reduce using rule 21 (class_content -> semanticlist .)
    DYNAMIC         reduce using rule 21 (class_content -> semanticlist .)
    VOID            reduce using rule 21 (class_content -> semanticlist .)
    VAR             reduce using rule 21 (class_content -> semanticlist .)
    MAP             reduce using rule 21 (class_content -> semanticlist .)
    IF              reduce using rule 21 (class_content -> semanticlist .)
    INTEGER         reduce using rule 21 (class_content -> semanticlist .)
    FLOAT           reduce using rule 21 (class_content -> semanticlist .)
    STR             reduce using rule 21 (class_content -> semanticlist .)
    BOOLEAN         reduce using rule 21 (class_content -> semanticlist .)
    TRUE            reduce using rule 21 (class_content -> semanticlist .)
    FALSE           reduce using rule 21 (class_content -> semanticlist .)
    MAIN            reduce using rule 21 (class_content -> semanticlist .)
    $end            reduce using rule 21 (class_content -> semanticlist .)
    RCURLYBRACKET   reduce using rule 21 (class_content -> semanticlist .)


state 18

    (22) class_content -> asign .

    FINAL           reduce using rule 22 (class_content -> asign .)
    STRING          reduce using rule 22 (class_content -> asign .)
    INT             reduce using rule 22 (class_content -> asign .)
    FOR             reduce using rule 22 (class_content -> asign .)
    WHILE           reduce using rule 22 (class_content -> asign .)
    IDENTIFIER      reduce using rule 22 (class_content -> asign .)
    PRINT           reduce using rule 22 (class_content -> asign .)
    BOOL            reduce using rule 22 (class_content -> asign .)
    LIST            reduce using rule 22 (class_content -> asign .)
    DOUBLE          reduce using rule 22 (class_content -> asign .)
    DYNAMIC         reduce using rule 22 (class_content -> asign .)
    VOID            reduce using rule 22 (class_content -> asign .)
    VAR             reduce using rule 22 (class_content -> asign .)
    MAP             reduce using rule 22 (class_content -> asign .)
    IF              reduce using rule 22 (class_content -> asign .)
    INTEGER         reduce using rule 22 (class_content -> asign .)
    FLOAT           reduce using rule 22 (class_content -> asign .)
    STR             reduce using rule 22 (class_content -> asign .)
    BOOLEAN         reduce using rule 22 (class_content -> asign .)
    TRUE            reduce using rule 22 (class_content -> asign .)
    FALSE           reduce using rule 22 (class_content -> asign .)
    MAIN            reduce using rule 22 (class_content -> asign .)
    $end            reduce using rule 22 (class_content -> asign .)
    RCURLYBRACKET   reduce using rule 22 (class_content -> asign .)


state 19

    (18) datatypeOpt -> datatype .
    (103) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (133) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> datatype . IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (131) repeatDeclaration -> . IDENTIFIER
    (132) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    MAIN            reduce using rule 18 (datatypeOpt -> datatype .)
    IDENTIFIER      shift and go to state 53

    repeatDeclaration              shift and go to state 54

state 20

    (19) datatypeOpt -> empty .

    MAIN            reduce using rule 19 (datatypeOpt -> empty .)


state 21

    (23) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) datatype -> map_identifier .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 55
    MAIN            reduce using rule 33 (datatype -> map_identifier .)

  ! IDENTIFIER      [ reduce using rule 33 (datatype -> map_identifier .) ]


state 22

    (63) inferedReturnFunction -> IDENTIFIER . LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (116) asign -> IDENTIFIER . EQUAL expression SEMICOLON
    (117) asign -> IDENTIFIER . otherAsignations EQUAL expression SEMICOLON
    (68) value -> IDENTIFIER .
    (173) propertiesAccess -> IDENTIFIER . DOT properties
    (118) otherAsignations -> . PLUS
    (119) otherAsignations -> . MINUS
    (120) otherAsignations -> . TIMES
    (121) otherAsignations -> . DIVISION
    (122) otherAsignations -> . REST

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for REST resolved as shift
    LPAREN          shift and go to state 56
    EQUAL           shift and go to state 57
    SEMICOLON       reduce using rule 68 (value -> IDENTIFIER .)
    DOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    TIMES           shift and go to state 62
    DIVISION        shift and go to state 63
    REST            shift and go to state 64

  ! PLUS            [ reduce using rule 68 (value -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 68 (value -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 68 (value -> IDENTIFIER .) ]
  ! DIVISION        [ reduce using rule 68 (value -> IDENTIFIER .) ]
  ! REST            [ reduce using rule 68 (value -> IDENTIFIER .) ]

    otherAsignations               shift and go to state 58

state 23

    (51) ifElseStatement -> ifStatement .
    (52) ifElseStatement -> ifStatement . elifStatement_repeat
    (53) elifStatement_repeat -> . elifStatement
    (54) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (56) elifStatement -> . ELSE ifStatement
    (57) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    FINAL           reduce using rule 51 (ifElseStatement -> ifStatement .)
    STRING          reduce using rule 51 (ifElseStatement -> ifStatement .)
    INT             reduce using rule 51 (ifElseStatement -> ifStatement .)
    FOR             reduce using rule 51 (ifElseStatement -> ifStatement .)
    WHILE           reduce using rule 51 (ifElseStatement -> ifStatement .)
    IDENTIFIER      reduce using rule 51 (ifElseStatement -> ifStatement .)
    PRINT           reduce using rule 51 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 51 (ifElseStatement -> ifStatement .)
    LIST            reduce using rule 51 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 51 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 51 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 51 (ifElseStatement -> ifStatement .)
    VAR             reduce using rule 51 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 51 (ifElseStatement -> ifStatement .)
    IF              reduce using rule 51 (ifElseStatement -> ifStatement .)
    INTEGER         reduce using rule 51 (ifElseStatement -> ifStatement .)
    FLOAT           reduce using rule 51 (ifElseStatement -> ifStatement .)
    STR             reduce using rule 51 (ifElseStatement -> ifStatement .)
    BOOLEAN         reduce using rule 51 (ifElseStatement -> ifStatement .)
    TRUE            reduce using rule 51 (ifElseStatement -> ifStatement .)
    FALSE           reduce using rule 51 (ifElseStatement -> ifStatement .)
    MAIN            reduce using rule 51 (ifElseStatement -> ifStatement .)
    $end            reduce using rule 51 (ifElseStatement -> ifStatement .)
    RCURLYBRACKET   reduce using rule 51 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 67

    elifStatement_repeat           shift and go to state 65
    elifStatement                  shift and go to state 66

state 24

    (135) declarationExpression -> FINAL . IDENTIFIER EQUAL expression SEMICOLON
    (59) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> FINAL . IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 68


state 25

    (160) declarationExpression -> STRING . IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> STRING . IDENTIFIER SEMICOLON
    (28) datatype -> STRING .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 69
    MAIN            reduce using rule 28 (datatype -> STRING .)

  ! IDENTIFIER      [ reduce using rule 28 (datatype -> STRING .) ]


state 26

    (165) declarationExpression -> INT . IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> INT . IDENTIFIER SEMICOLON
    (27) datatype -> INT .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 70
    MAIN            reduce using rule 27 (datatype -> INT .)

  ! IDENTIFIER      [ reduce using rule 27 (datatype -> INT .) ]


state 27

    (58) forStatement -> FOR . LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    LPAREN          shift and go to state 71


state 28

    (60) while -> WHILE . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 72


state 29

    (113) expression -> value .
    (114) expression -> value . operatorExpression expression
    (115) expression -> value . operatorExpression operatorExpression
    (125) operatorExpression -> . PLUS
    (126) operatorExpression -> . MINUS
    (127) operatorExpression -> . TIMES
    (128) operatorExpression -> . DIVISION
    (129) operatorExpression -> . REST

    SEMICOLON       reduce using rule 113 (expression -> value .)
    RPAREN          reduce using rule 113 (expression -> value .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76
    DIVISION        shift and go to state 77
    REST            shift and go to state 78

    operatorExpression             shift and go to state 73

state 30

    (42) print -> PRINT . LPAREN value RPAREN SEMICOLON

    LPAREN          shift and go to state 79


state 31

    (136) semanticbool -> BOOL . IDENTIFIER EQUAL conditions SEMICOLON
    (29) datatype -> BOOL .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 80
    MAIN            reduce using rule 29 (datatype -> BOOL .)

  ! IDENTIFIER      [ reduce using rule 29 (datatype -> BOOL .) ]


state 32

    (145) semanticlist -> LIST . LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> LIST . LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> LIST . LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> LIST . LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> LIST . LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    LESSTHAN        shift and go to state 81


state 33

    (31) datatype -> DYNAMIC .

    IDENTIFIER      reduce using rule 31 (datatype -> DYNAMIC .)
    MAIN            reduce using rule 31 (datatype -> DYNAMIC .)
    COMMA           reduce using rule 31 (datatype -> DYNAMIC .)
    RPAREN          reduce using rule 31 (datatype -> DYNAMIC .)
    GREATERTHAN     reduce using rule 31 (datatype -> DYNAMIC .)


state 34

    (30) datatype -> DOUBLE .

    IDENTIFIER      reduce using rule 30 (datatype -> DOUBLE .)
    MAIN            reduce using rule 30 (datatype -> DOUBLE .)
    COMMA           reduce using rule 30 (datatype -> DOUBLE .)
    RPAREN          reduce using rule 30 (datatype -> DOUBLE .)
    GREATERTHAN     reduce using rule 30 (datatype -> DOUBLE .)


state 35

    (32) datatype -> VOID .

    IDENTIFIER      reduce using rule 32 (datatype -> VOID .)
    MAIN            reduce using rule 32 (datatype -> VOID .)
    COMMA           reduce using rule 32 (datatype -> VOID .)
    RPAREN          reduce using rule 32 (datatype -> VOID .)
    GREATERTHAN     reduce using rule 32 (datatype -> VOID .)


state 36

    (34) datatype -> VAR .

    IDENTIFIER      reduce using rule 34 (datatype -> VAR .)
    MAIN            reduce using rule 34 (datatype -> VAR .)
    COMMA           reduce using rule 34 (datatype -> VAR .)
    RPAREN          reduce using rule 34 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 34 (datatype -> VAR .)


state 37

    (24) map_identifier -> MAP .
    (25) map_identifier -> MAP . map_type_specified
    (26) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 24 (map_identifier -> MAP .)
    MAIN            reduce using rule 24 (map_identifier -> MAP .)
    COMMA           reduce using rule 24 (map_identifier -> MAP .)
    RPAREN          reduce using rule 24 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 24 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 83

    map_type_specified             shift and go to state 82

state 38

    (55) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 84


state 39

    (64) value -> INTEGER .

    PLUS            reduce using rule 64 (value -> INTEGER .)
    MINUS           reduce using rule 64 (value -> INTEGER .)
    TIMES           reduce using rule 64 (value -> INTEGER .)
    DIVISION        reduce using rule 64 (value -> INTEGER .)
    REST            reduce using rule 64 (value -> INTEGER .)
    SEMICOLON       reduce using rule 64 (value -> INTEGER .)
    RPAREN          reduce using rule 64 (value -> INTEGER .)
    COLON           reduce using rule 64 (value -> INTEGER .)
    COMMA           reduce using rule 64 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 64 (value -> INTEGER .)
    RSQUAREBRACKET  reduce using rule 64 (value -> INTEGER .)


state 40

    (65) value -> FLOAT .

    PLUS            reduce using rule 65 (value -> FLOAT .)
    MINUS           reduce using rule 65 (value -> FLOAT .)
    TIMES           reduce using rule 65 (value -> FLOAT .)
    DIVISION        reduce using rule 65 (value -> FLOAT .)
    REST            reduce using rule 65 (value -> FLOAT .)
    SEMICOLON       reduce using rule 65 (value -> FLOAT .)
    RPAREN          reduce using rule 65 (value -> FLOAT .)
    COLON           reduce using rule 65 (value -> FLOAT .)
    COMMA           reduce using rule 65 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 65 (value -> FLOAT .)
    RSQUAREBRACKET  reduce using rule 65 (value -> FLOAT .)


state 41

    (66) value -> STR .

    PLUS            reduce using rule 66 (value -> STR .)
    MINUS           reduce using rule 66 (value -> STR .)
    TIMES           reduce using rule 66 (value -> STR .)
    DIVISION        reduce using rule 66 (value -> STR .)
    REST            reduce using rule 66 (value -> STR .)
    SEMICOLON       reduce using rule 66 (value -> STR .)
    RPAREN          reduce using rule 66 (value -> STR .)
    COLON           reduce using rule 66 (value -> STR .)
    COMMA           reduce using rule 66 (value -> STR .)
    RCURLYBRACKET   reduce using rule 66 (value -> STR .)
    RSQUAREBRACKET  reduce using rule 66 (value -> STR .)


state 42

    (67) value -> BOOLEAN .

    PLUS            reduce using rule 67 (value -> BOOLEAN .)
    MINUS           reduce using rule 67 (value -> BOOLEAN .)
    TIMES           reduce using rule 67 (value -> BOOLEAN .)
    DIVISION        reduce using rule 67 (value -> BOOLEAN .)
    REST            reduce using rule 67 (value -> BOOLEAN .)
    SEMICOLON       reduce using rule 67 (value -> BOOLEAN .)
    RPAREN          reduce using rule 67 (value -> BOOLEAN .)
    COLON           reduce using rule 67 (value -> BOOLEAN .)
    COMMA           reduce using rule 67 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 67 (value -> BOOLEAN .)
    RSQUAREBRACKET  reduce using rule 67 (value -> BOOLEAN .)


state 43

    (69) value -> booleanOp .

    PLUS            reduce using rule 69 (value -> booleanOp .)
    MINUS           reduce using rule 69 (value -> booleanOp .)
    TIMES           reduce using rule 69 (value -> booleanOp .)
    DIVISION        reduce using rule 69 (value -> booleanOp .)
    REST            reduce using rule 69 (value -> booleanOp .)
    SEMICOLON       reduce using rule 69 (value -> booleanOp .)
    RPAREN          reduce using rule 69 (value -> booleanOp .)
    COLON           reduce using rule 69 (value -> booleanOp .)
    COMMA           reduce using rule 69 (value -> booleanOp .)
    RCURLYBRACKET   reduce using rule 69 (value -> booleanOp .)
    RSQUAREBRACKET  reduce using rule 69 (value -> booleanOp .)


state 44

    (70) value -> propertiesAccess .

    PLUS            reduce using rule 70 (value -> propertiesAccess .)
    MINUS           reduce using rule 70 (value -> propertiesAccess .)
    TIMES           reduce using rule 70 (value -> propertiesAccess .)
    DIVISION        reduce using rule 70 (value -> propertiesAccess .)
    REST            reduce using rule 70 (value -> propertiesAccess .)
    SEMICOLON       reduce using rule 70 (value -> propertiesAccess .)
    RPAREN          reduce using rule 70 (value -> propertiesAccess .)
    COLON           reduce using rule 70 (value -> propertiesAccess .)
    COMMA           reduce using rule 70 (value -> propertiesAccess .)
    RCURLYBRACKET   reduce using rule 70 (value -> propertiesAccess .)
    RSQUAREBRACKET  reduce using rule 70 (value -> propertiesAccess .)


state 45

    (137) booleanOp -> TRUE .

    PLUS            reduce using rule 137 (booleanOp -> TRUE .)
    MINUS           reduce using rule 137 (booleanOp -> TRUE .)
    TIMES           reduce using rule 137 (booleanOp -> TRUE .)
    DIVISION        reduce using rule 137 (booleanOp -> TRUE .)
    REST            reduce using rule 137 (booleanOp -> TRUE .)
    SEMICOLON       reduce using rule 137 (booleanOp -> TRUE .)
    DOUBLEQUAL      reduce using rule 137 (booleanOp -> TRUE .)
    LESSTHAN        reduce using rule 137 (booleanOp -> TRUE .)
    GREATERTHAN     reduce using rule 137 (booleanOp -> TRUE .)
    AND             reduce using rule 137 (booleanOp -> TRUE .)
    OR              reduce using rule 137 (booleanOp -> TRUE .)
    AMPERSAND       reduce using rule 137 (booleanOp -> TRUE .)
    PIPELINE        reduce using rule 137 (booleanOp -> TRUE .)
    RPAREN          reduce using rule 137 (booleanOp -> TRUE .)
    COLON           reduce using rule 137 (booleanOp -> TRUE .)
    COMMA           reduce using rule 137 (booleanOp -> TRUE .)
    RCURLYBRACKET   reduce using rule 137 (booleanOp -> TRUE .)
    RSQUAREBRACKET  reduce using rule 137 (booleanOp -> TRUE .)


state 46

    (138) booleanOp -> FALSE .

    PLUS            reduce using rule 138 (booleanOp -> FALSE .)
    MINUS           reduce using rule 138 (booleanOp -> FALSE .)
    TIMES           reduce using rule 138 (booleanOp -> FALSE .)
    DIVISION        reduce using rule 138 (booleanOp -> FALSE .)
    REST            reduce using rule 138 (booleanOp -> FALSE .)
    SEMICOLON       reduce using rule 138 (booleanOp -> FALSE .)
    DOUBLEQUAL      reduce using rule 138 (booleanOp -> FALSE .)
    LESSTHAN        reduce using rule 138 (booleanOp -> FALSE .)
    GREATERTHAN     reduce using rule 138 (booleanOp -> FALSE .)
    AND             reduce using rule 138 (booleanOp -> FALSE .)
    OR              reduce using rule 138 (booleanOp -> FALSE .)
    AMPERSAND       reduce using rule 138 (booleanOp -> FALSE .)
    PIPELINE        reduce using rule 138 (booleanOp -> FALSE .)
    RPAREN          reduce using rule 138 (booleanOp -> FALSE .)
    COLON           reduce using rule 138 (booleanOp -> FALSE .)
    COMMA           reduce using rule 138 (booleanOp -> FALSE .)
    RCURLYBRACKET   reduce using rule 138 (booleanOp -> FALSE .)
    RSQUAREBRACKET  reduce using rule 138 (booleanOp -> FALSE .)


state 47

    (3) class -> class_content_repeat declarationMain .

    $end            reduce using rule 3 (class -> class_content_repeat declarationMain .)


state 48

    (16) class_content_repeat -> class_content_repeat class_content .

    FINAL           reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    STRING          reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    INT             reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    FOR             reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    WHILE           reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    IDENTIFIER      reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    PRINT           reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    BOOL            reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    LIST            reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    DOUBLE          reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    DYNAMIC         reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    VOID            reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    VAR             reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    MAP             reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    IF              reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    INTEGER         reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    FLOAT           reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    STR             reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    BOOLEAN         reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    TRUE            reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    FALSE           reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    MAIN            reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    $end            reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)
    RCURLYBRACKET   reduce using rule 16 (class_content_repeat -> class_content_repeat class_content .)


state 49

    (2) class -> declarationMain class_content_repeat .
    (16) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    $end            reduce using rule 2 (class -> declarationMain class_content_repeat .)
    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content                  shift and go to state 48
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 50

    (103) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (133) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> datatype . IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (131) repeatDeclaration -> . IDENTIFIER
    (132) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 53

    repeatDeclaration              shift and go to state 54

state 51

    (17) declarationMain -> datatypeOpt MAIN . LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 85


state 52

    (13) class_content -> expression SEMICOLON .

    FINAL           reduce using rule 13 (class_content -> expression SEMICOLON .)
    STRING          reduce using rule 13 (class_content -> expression SEMICOLON .)
    INT             reduce using rule 13 (class_content -> expression SEMICOLON .)
    FOR             reduce using rule 13 (class_content -> expression SEMICOLON .)
    WHILE           reduce using rule 13 (class_content -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (class_content -> expression SEMICOLON .)
    PRINT           reduce using rule 13 (class_content -> expression SEMICOLON .)
    BOOL            reduce using rule 13 (class_content -> expression SEMICOLON .)
    LIST            reduce using rule 13 (class_content -> expression SEMICOLON .)
    DOUBLE          reduce using rule 13 (class_content -> expression SEMICOLON .)
    DYNAMIC         reduce using rule 13 (class_content -> expression SEMICOLON .)
    VOID            reduce using rule 13 (class_content -> expression SEMICOLON .)
    VAR             reduce using rule 13 (class_content -> expression SEMICOLON .)
    MAP             reduce using rule 13 (class_content -> expression SEMICOLON .)
    IF              reduce using rule 13 (class_content -> expression SEMICOLON .)
    INTEGER         reduce using rule 13 (class_content -> expression SEMICOLON .)
    FLOAT           reduce using rule 13 (class_content -> expression SEMICOLON .)
    STR             reduce using rule 13 (class_content -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 13 (class_content -> expression SEMICOLON .)
    TRUE            reduce using rule 13 (class_content -> expression SEMICOLON .)
    FALSE           reduce using rule 13 (class_content -> expression SEMICOLON .)
    MAIN            reduce using rule 13 (class_content -> expression SEMICOLON .)
    $end            reduce using rule 13 (class_content -> expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 13 (class_content -> expression SEMICOLON .)


state 53

    (103) function_lambda -> datatype IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (133) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON
    (134) declarationExpression -> datatype IDENTIFIER . EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (131) repeatDeclaration -> IDENTIFIER .
    (132) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    LPAREN          shift and go to state 86
    EQUAL           shift and go to state 87
    SEMICOLON       reduce using rule 131 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 88


state 54

    (130) declarationExpression -> datatype repeatDeclaration . SEMICOLON

    SEMICOLON       shift and go to state 89


state 55

    (23) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 90


state 56

    (63) inferedReturnFunction -> IDENTIFIER LPAREN . function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (106) function_arguments_repeat -> . function_argument
    (107) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (104) function_argument -> . datatype IDENTIFIER
    (105) function_argument -> . empty
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (43) empty -> .
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 95
    STRING          shift and go to state 96
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    COMMA           reduce using rule 43 (empty -> .)
    RPAREN          reduce using rule 43 (empty -> .)
    MAP             shift and go to state 37

    function_arguments_repeat      shift and go to state 91
    function_argument              shift and go to state 92
    datatype                       shift and go to state 93
    empty                          shift and go to state 94
    map_identifier                 shift and go to state 98

state 57

    (116) asign -> IDENTIFIER EQUAL . expression SEMICOLON
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expression                     shift and go to state 100
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 58

    (117) asign -> IDENTIFIER otherAsignations . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 101


state 59

    (173) propertiesAccess -> IDENTIFIER DOT . properties
    (171) properties -> . KEYS
    (172) properties -> . VALUES

    KEYS            shift and go to state 103
    VALUES          shift and go to state 104

    properties                     shift and go to state 102

state 60

    (118) otherAsignations -> PLUS .

    EQUAL           reduce using rule 118 (otherAsignations -> PLUS .)


state 61

    (119) otherAsignations -> MINUS .

    EQUAL           reduce using rule 119 (otherAsignations -> MINUS .)


state 62

    (120) otherAsignations -> TIMES .

    EQUAL           reduce using rule 120 (otherAsignations -> TIMES .)


state 63

    (121) otherAsignations -> DIVISION .

    EQUAL           reduce using rule 121 (otherAsignations -> DIVISION .)


state 64

    (122) otherAsignations -> REST .

    EQUAL           reduce using rule 122 (otherAsignations -> REST .)


state 65

    (52) ifElseStatement -> ifStatement elifStatement_repeat .

    FINAL           reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STRING          reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INT             reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FOR             reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    WHILE           reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    PRINT           reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    LIST            reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VAR             reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IF              reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STR             reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    TRUE            reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FALSE           reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAIN            reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    $end            reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 52 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 66

    (53) elifStatement_repeat -> elifStatement .
    (54) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (53) elifStatement_repeat -> . elifStatement
    (54) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (56) elifStatement -> . ELSE ifStatement
    (57) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    FINAL           reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    STRING          reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    INT             reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    FOR             reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    WHILE           reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    IDENTIFIER      reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    PRINT           reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    LIST            reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    VAR             reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    IF              reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    INTEGER         reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    FLOAT           reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    STR             reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    BOOLEAN         reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    TRUE            reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    FALSE           reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    MAIN            reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    $end            reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    RCURLYBRACKET   reduce using rule 53 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 67

    elifStatement                  shift and go to state 66
    elifStatement_repeat           shift and go to state 105

state 67

    (56) elifStatement -> ELSE . ifStatement
    (57) elifStatement -> ELSE . LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 107
    IF              shift and go to state 38

    ifStatement                    shift and go to state 106

state 68

    (135) declarationExpression -> FINAL IDENTIFIER . EQUAL expression SEMICOLON
    (59) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> FINAL IDENTIFIER . EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    EQUAL           shift and go to state 108


state 69

    (160) declarationExpression -> STRING IDENTIFIER . EQUAL expressionString SEMICOLON
    (161) declarationExpression -> STRING IDENTIFIER . SEMICOLON

    EQUAL           shift and go to state 109
    SEMICOLON       shift and go to state 110


state 70

    (165) declarationExpression -> INT IDENTIFIER . EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> INT IDENTIFIER . SEMICOLON

    EQUAL           shift and go to state 111
    SEMICOLON       shift and go to state 112


state 71

    (58) forStatement -> FOR LPAREN . declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    FINAL           shift and go to state 115
    STRING          shift and go to state 25
    INT             shift and go to state 26
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    MAP             shift and go to state 37

    declarationExpression          shift and go to state 113
    datatype                       shift and go to state 114
    map_identifier                 shift and go to state 98

state 72

    (60) while -> WHILE LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (97) conditions -> . condition
    (98) conditions -> . condition condition_connector conditions
    (90) condition -> . IDENTIFIER condition_operator condition_values
    (91) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (92) condition -> . BOOLEAN condition_operator BOOLEAN
    (93) condition -> . number condition_operator number
    (94) condition -> . STR condition_operator STR
    (95) condition -> . booleanOp condition_operator booleanOp
    (96) condition -> . negation_values
    (88) number -> . FLOAT
    (89) number -> . INTEGER
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (76) negation_values -> . deniable_values
    (77) negation_values -> . EXMARK deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 118
    EXMARK          shift and go to state 119
    BOOLEAN         shift and go to state 120
    STR             shift and go to state 122
    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    conditions                     shift and go to state 116
    condition                      shift and go to state 117
    number                         shift and go to state 121
    booleanOp                      shift and go to state 123
    negation_values                shift and go to state 124
    deniable_values                shift and go to state 127

state 73

    (114) expression -> value operatorExpression . expression
    (115) expression -> value operatorExpression . operatorExpression
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (125) operatorExpression -> . PLUS
    (126) operatorExpression -> . MINUS
    (127) operatorExpression -> . TIMES
    (128) operatorExpression -> . DIVISION
    (129) operatorExpression -> . REST
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76
    DIVISION        shift and go to state 77
    REST            shift and go to state 78
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    value                          shift and go to state 29
    operatorExpression             shift and go to state 128
    expression                     shift and go to state 129
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 74

    (125) operatorExpression -> PLUS .

    PLUS            reduce using rule 125 (operatorExpression -> PLUS .)
    MINUS           reduce using rule 125 (operatorExpression -> PLUS .)
    TIMES           reduce using rule 125 (operatorExpression -> PLUS .)
    DIVISION        reduce using rule 125 (operatorExpression -> PLUS .)
    REST            reduce using rule 125 (operatorExpression -> PLUS .)
    INTEGER         reduce using rule 125 (operatorExpression -> PLUS .)
    FLOAT           reduce using rule 125 (operatorExpression -> PLUS .)
    STR             reduce using rule 125 (operatorExpression -> PLUS .)
    BOOLEAN         reduce using rule 125 (operatorExpression -> PLUS .)
    IDENTIFIER      reduce using rule 125 (operatorExpression -> PLUS .)
    TRUE            reduce using rule 125 (operatorExpression -> PLUS .)
    FALSE           reduce using rule 125 (operatorExpression -> PLUS .)
    SEMICOLON       reduce using rule 125 (operatorExpression -> PLUS .)
    RPAREN          reduce using rule 125 (operatorExpression -> PLUS .)


state 75

    (126) operatorExpression -> MINUS .

    PLUS            reduce using rule 126 (operatorExpression -> MINUS .)
    MINUS           reduce using rule 126 (operatorExpression -> MINUS .)
    TIMES           reduce using rule 126 (operatorExpression -> MINUS .)
    DIVISION        reduce using rule 126 (operatorExpression -> MINUS .)
    REST            reduce using rule 126 (operatorExpression -> MINUS .)
    INTEGER         reduce using rule 126 (operatorExpression -> MINUS .)
    FLOAT           reduce using rule 126 (operatorExpression -> MINUS .)
    STR             reduce using rule 126 (operatorExpression -> MINUS .)
    BOOLEAN         reduce using rule 126 (operatorExpression -> MINUS .)
    IDENTIFIER      reduce using rule 126 (operatorExpression -> MINUS .)
    TRUE            reduce using rule 126 (operatorExpression -> MINUS .)
    FALSE           reduce using rule 126 (operatorExpression -> MINUS .)
    SEMICOLON       reduce using rule 126 (operatorExpression -> MINUS .)
    RPAREN          reduce using rule 126 (operatorExpression -> MINUS .)


state 76

    (127) operatorExpression -> TIMES .

    PLUS            reduce using rule 127 (operatorExpression -> TIMES .)
    MINUS           reduce using rule 127 (operatorExpression -> TIMES .)
    TIMES           reduce using rule 127 (operatorExpression -> TIMES .)
    DIVISION        reduce using rule 127 (operatorExpression -> TIMES .)
    REST            reduce using rule 127 (operatorExpression -> TIMES .)
    INTEGER         reduce using rule 127 (operatorExpression -> TIMES .)
    FLOAT           reduce using rule 127 (operatorExpression -> TIMES .)
    STR             reduce using rule 127 (operatorExpression -> TIMES .)
    BOOLEAN         reduce using rule 127 (operatorExpression -> TIMES .)
    IDENTIFIER      reduce using rule 127 (operatorExpression -> TIMES .)
    TRUE            reduce using rule 127 (operatorExpression -> TIMES .)
    FALSE           reduce using rule 127 (operatorExpression -> TIMES .)
    SEMICOLON       reduce using rule 127 (operatorExpression -> TIMES .)
    RPAREN          reduce using rule 127 (operatorExpression -> TIMES .)


state 77

    (128) operatorExpression -> DIVISION .

    PLUS            reduce using rule 128 (operatorExpression -> DIVISION .)
    MINUS           reduce using rule 128 (operatorExpression -> DIVISION .)
    TIMES           reduce using rule 128 (operatorExpression -> DIVISION .)
    DIVISION        reduce using rule 128 (operatorExpression -> DIVISION .)
    REST            reduce using rule 128 (operatorExpression -> DIVISION .)
    INTEGER         reduce using rule 128 (operatorExpression -> DIVISION .)
    FLOAT           reduce using rule 128 (operatorExpression -> DIVISION .)
    STR             reduce using rule 128 (operatorExpression -> DIVISION .)
    BOOLEAN         reduce using rule 128 (operatorExpression -> DIVISION .)
    IDENTIFIER      reduce using rule 128 (operatorExpression -> DIVISION .)
    TRUE            reduce using rule 128 (operatorExpression -> DIVISION .)
    FALSE           reduce using rule 128 (operatorExpression -> DIVISION .)
    SEMICOLON       reduce using rule 128 (operatorExpression -> DIVISION .)
    RPAREN          reduce using rule 128 (operatorExpression -> DIVISION .)


state 78

    (129) operatorExpression -> REST .

    PLUS            reduce using rule 129 (operatorExpression -> REST .)
    MINUS           reduce using rule 129 (operatorExpression -> REST .)
    TIMES           reduce using rule 129 (operatorExpression -> REST .)
    DIVISION        reduce using rule 129 (operatorExpression -> REST .)
    REST            reduce using rule 129 (operatorExpression -> REST .)
    INTEGER         reduce using rule 129 (operatorExpression -> REST .)
    FLOAT           reduce using rule 129 (operatorExpression -> REST .)
    STR             reduce using rule 129 (operatorExpression -> REST .)
    BOOLEAN         reduce using rule 129 (operatorExpression -> REST .)
    IDENTIFIER      reduce using rule 129 (operatorExpression -> REST .)
    TRUE            reduce using rule 129 (operatorExpression -> REST .)
    FALSE           reduce using rule 129 (operatorExpression -> REST .)
    SEMICOLON       reduce using rule 129 (operatorExpression -> REST .)
    RPAREN          reduce using rule 129 (operatorExpression -> REST .)


state 79

    (42) print -> PRINT LPAREN . value RPAREN SEMICOLON
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    value                          shift and go to state 130
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 80

    (136) semanticbool -> BOOL IDENTIFIER . EQUAL conditions SEMICOLON

    EQUAL           shift and go to state 131


state 81

    (145) semanticlist -> LIST LESSTHAN . DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> LIST LESSTHAN . INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> LIST LESSTHAN . STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> LIST LESSTHAN . BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> LIST LESSTHAN . DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    DYNAMIC         shift and go to state 132
    INT             shift and go to state 133
    STRING          shift and go to state 134
    BOOL            shift and go to state 135
    DOUBLE          shift and go to state 136


state 82

    (25) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 25 (map_identifier -> MAP map_type_specified .)
    MAIN            reduce using rule 25 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 25 (map_identifier -> MAP map_type_specified .)
    RPAREN          reduce using rule 25 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 25 (map_identifier -> MAP map_type_specified .)


state 83

    (26) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 95
    STRING          shift and go to state 96
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    MAP             shift and go to state 37

    datatype                       shift and go to state 137
    map_identifier                 shift and go to state 98

state 84

    (55) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (97) conditions -> . condition
    (98) conditions -> . condition condition_connector conditions
    (90) condition -> . IDENTIFIER condition_operator condition_values
    (91) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (92) condition -> . BOOLEAN condition_operator BOOLEAN
    (93) condition -> . number condition_operator number
    (94) condition -> . STR condition_operator STR
    (95) condition -> . booleanOp condition_operator booleanOp
    (96) condition -> . negation_values
    (88) number -> . FLOAT
    (89) number -> . INTEGER
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (76) negation_values -> . deniable_values
    (77) negation_values -> . EXMARK deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 118
    EXMARK          shift and go to state 119
    BOOLEAN         shift and go to state 120
    STR             shift and go to state 122
    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    conditions                     shift and go to state 138
    condition                      shift and go to state 117
    number                         shift and go to state 121
    booleanOp                      shift and go to state 123
    negation_values                shift and go to state 124
    deniable_values                shift and go to state 127

state 85

    (17) declarationMain -> datatypeOpt MAIN LPAREN . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 139


state 86

    (103) function_lambda -> datatype IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (106) function_arguments_repeat -> . function_argument
    (107) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (104) function_argument -> . datatype IDENTIFIER
    (105) function_argument -> . empty
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (43) empty -> .
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 95
    STRING          shift and go to state 96
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    COMMA           reduce using rule 43 (empty -> .)
    LCURLYBRACKET   reduce using rule 43 (empty -> .)
    RPAREN          reduce using rule 43 (empty -> .)
    MAP             shift and go to state 37

    datatype                       shift and go to state 93
    function_arguments_repeat      shift and go to state 140
    function_argument              shift and go to state 92
    empty                          shift and go to state 94
    map_identifier                 shift and go to state 98

state 87

    (133) declarationExpression -> datatype IDENTIFIER EQUAL . expression SEMICOLON
    (134) declarationExpression -> datatype IDENTIFIER EQUAL . LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    LPAREN          shift and go to state 142
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expression                     shift and go to state 141
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 88

    (132) repeatDeclaration -> IDENTIFIER COMMA . repeatDeclaration
    (131) repeatDeclaration -> . IDENTIFIER
    (132) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 143

    repeatDeclaration              shift and go to state 144

state 89

    (130) declarationExpression -> datatype repeatDeclaration SEMICOLON .

    FINAL           reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    STRING          reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    INT             reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FOR             reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    WHILE           reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    IDENTIFIER      reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    PRINT           reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    BOOL            reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    LIST            reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    DOUBLE          reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    DYNAMIC         reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    VOID            reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    VAR             reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    MAP             reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    IF              reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    INTEGER         reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FLOAT           reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    STR             reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    BOOLEAN         reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    TRUE            reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FALSE           reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    MAIN            reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    $end            reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    SEMICOLON       reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    RCURLYBRACKET   reduce using rule 130 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)


state 90

    (23) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 145


state 91

    (63) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat . RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    RPAREN          shift and go to state 146


state 92

    (106) function_arguments_repeat -> function_argument .
    (107) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    RPAREN          reduce using rule 106 (function_arguments_repeat -> function_argument .)
    LCURLYBRACKET   reduce using rule 106 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 147


state 93

    (104) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 148


state 94

    (105) function_argument -> empty .

    COMMA           reduce using rule 105 (function_argument -> empty .)
    RPAREN          reduce using rule 105 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 105 (function_argument -> empty .)


state 95

    (27) datatype -> INT .

    IDENTIFIER      reduce using rule 27 (datatype -> INT .)
    COMMA           reduce using rule 27 (datatype -> INT .)
    RPAREN          reduce using rule 27 (datatype -> INT .)
    GREATERTHAN     reduce using rule 27 (datatype -> INT .)


state 96

    (28) datatype -> STRING .

    IDENTIFIER      reduce using rule 28 (datatype -> STRING .)
    COMMA           reduce using rule 28 (datatype -> STRING .)
    RPAREN          reduce using rule 28 (datatype -> STRING .)
    GREATERTHAN     reduce using rule 28 (datatype -> STRING .)


state 97

    (29) datatype -> BOOL .

    IDENTIFIER      reduce using rule 29 (datatype -> BOOL .)
    COMMA           reduce using rule 29 (datatype -> BOOL .)
    RPAREN          reduce using rule 29 (datatype -> BOOL .)
    GREATERTHAN     reduce using rule 29 (datatype -> BOOL .)


state 98

    (33) datatype -> map_identifier .

    IDENTIFIER      reduce using rule 33 (datatype -> map_identifier .)
    COMMA           reduce using rule 33 (datatype -> map_identifier .)
    RPAREN          reduce using rule 33 (datatype -> map_identifier .)
    GREATERTHAN     reduce using rule 33 (datatype -> map_identifier .)


state 99

    (68) value -> IDENTIFIER .
    (173) propertiesAccess -> IDENTIFIER . DOT properties

    PLUS            reduce using rule 68 (value -> IDENTIFIER .)
    MINUS           reduce using rule 68 (value -> IDENTIFIER .)
    TIMES           reduce using rule 68 (value -> IDENTIFIER .)
    DIVISION        reduce using rule 68 (value -> IDENTIFIER .)
    REST            reduce using rule 68 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 68 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 68 (value -> IDENTIFIER .)
    COLON           reduce using rule 68 (value -> IDENTIFIER .)
    COMMA           reduce using rule 68 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 68 (value -> IDENTIFIER .)
    RSQUAREBRACKET  reduce using rule 68 (value -> IDENTIFIER .)
    DOT             shift and go to state 59


state 100

    (116) asign -> IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 149


state 101

    (117) asign -> IDENTIFIER otherAsignations EQUAL . expression SEMICOLON
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expression                     shift and go to state 150
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 102

    (173) propertiesAccess -> IDENTIFIER DOT properties .

    PLUS            reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    MINUS           reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    TIMES           reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    DIVISION        reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    REST            reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    SEMICOLON       reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    RPAREN          reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    COLON           reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    COMMA           reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    RCURLYBRACKET   reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)
    RSQUAREBRACKET  reduce using rule 173 (propertiesAccess -> IDENTIFIER DOT properties .)


state 103

    (171) properties -> KEYS .

    PLUS            reduce using rule 171 (properties -> KEYS .)
    MINUS           reduce using rule 171 (properties -> KEYS .)
    TIMES           reduce using rule 171 (properties -> KEYS .)
    DIVISION        reduce using rule 171 (properties -> KEYS .)
    REST            reduce using rule 171 (properties -> KEYS .)
    SEMICOLON       reduce using rule 171 (properties -> KEYS .)
    RPAREN          reduce using rule 171 (properties -> KEYS .)
    COLON           reduce using rule 171 (properties -> KEYS .)
    COMMA           reduce using rule 171 (properties -> KEYS .)
    RCURLYBRACKET   reduce using rule 171 (properties -> KEYS .)
    RSQUAREBRACKET  reduce using rule 171 (properties -> KEYS .)


state 104

    (172) properties -> VALUES .

    PLUS            reduce using rule 172 (properties -> VALUES .)
    MINUS           reduce using rule 172 (properties -> VALUES .)
    TIMES           reduce using rule 172 (properties -> VALUES .)
    DIVISION        reduce using rule 172 (properties -> VALUES .)
    REST            reduce using rule 172 (properties -> VALUES .)
    SEMICOLON       reduce using rule 172 (properties -> VALUES .)
    RPAREN          reduce using rule 172 (properties -> VALUES .)
    COLON           reduce using rule 172 (properties -> VALUES .)
    COMMA           reduce using rule 172 (properties -> VALUES .)
    RCURLYBRACKET   reduce using rule 172 (properties -> VALUES .)
    RSQUAREBRACKET  reduce using rule 172 (properties -> VALUES .)


state 105

    (54) elifStatement_repeat -> elifStatement elifStatement_repeat .

    FINAL           reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STRING          reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INT             reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FOR             reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    WHILE           reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    PRINT           reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    LIST            reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VAR             reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IF              reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STR             reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    TRUE            reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FALSE           reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAIN            reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    $end            reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 54 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 106

    (56) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    FINAL           reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    FOR             reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    WHILE           reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    IDENTIFIER      reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    PRINT           reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    LIST            reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    VAR             reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    IF              reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    INTEGER         reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    FLOAT           reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    STR             reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    BOOLEAN         reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    TRUE            reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    FALSE           reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    MAIN            reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    $end            reduce using rule 56 (elifStatement -> ELSE ifStatement .)
    RCURLYBRACKET   reduce using rule 56 (elifStatement -> ELSE ifStatement .)


state 107

    (57) elifStatement -> ELSE LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (15) class_content_repeat -> . class_content
    (16) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content_repeat           shift and go to state 151
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 108

    (135) declarationExpression -> FINAL IDENTIFIER EQUAL . expression SEMICOLON
    (59) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> FINAL IDENTIFIER EQUAL . STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    STACK           shift and go to state 153
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expression                     shift and go to state 152
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 109

    (160) declarationExpression -> STRING IDENTIFIER EQUAL . expressionString SEMICOLON
    (162) expressionString -> . STR
    (163) expressionString -> . STR operatorExpressionString expressionString

    STR             shift and go to state 155

    expressionString               shift and go to state 154

state 110

    (161) declarationExpression -> STRING IDENTIFIER SEMICOLON .

    FINAL           reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    INT             reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    IF              reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    STR             reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    MAIN            reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    $end            reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 161 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)


state 111

    (165) declarationExpression -> INT IDENTIFIER EQUAL . expressionInteger SEMICOLON
    (167) expressionInteger -> . number
    (168) expressionInteger -> . number operatorExpression expressionInteger
    (169) expressionInteger -> . IDENTIFIER
    (170) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (88) number -> . FLOAT
    (89) number -> . INTEGER

    IDENTIFIER      shift and go to state 156
    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126

    expressionInteger              shift and go to state 157
    number                         shift and go to state 158

state 112

    (166) declarationExpression -> INT IDENTIFIER SEMICOLON .

    FINAL           reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    INT             reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    IF              reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    STR             reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    MAIN            reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    $end            reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 166 (declarationExpression -> INT IDENTIFIER SEMICOLON .)


state 113

    (58) forStatement -> FOR LPAREN declarationExpression . SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 159


state 114

    (130) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (133) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> datatype . IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (131) repeatDeclaration -> . IDENTIFIER
    (132) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 160

    repeatDeclaration              shift and go to state 54

state 115

    (135) declarationExpression -> FINAL . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 161


state 116

    (60) while -> WHILE LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 162


state 117

    (97) conditions -> condition .
    (98) conditions -> condition . condition_connector conditions
    (99) condition_connector -> . AND
    (100) condition_connector -> . OR
    (101) condition_connector -> . AMPERSAND AMPERSAND
    (102) condition_connector -> . PIPELINE PIPELINE

    RPAREN          reduce using rule 97 (conditions -> condition .)
    SEMICOLON       reduce using rule 97 (conditions -> condition .)
    AND             shift and go to state 164
    OR              shift and go to state 165
    AMPERSAND       shift and go to state 166
    PIPELINE        shift and go to state 167

    condition_connector            shift and go to state 163

state 118

    (90) condition -> IDENTIFIER . condition_operator condition_values
    (73) deniable_values -> IDENTIFIER .
    (83) condition_operator -> . DOUBLEQUAL
    (84) condition_operator -> . LESSTHAN
    (85) condition_operator -> . GREATERTHAN
    (86) condition_operator -> . LESSTHAN EQUAL
    (87) condition_operator -> . GREATERTHAN EQUAL

    AND             reduce using rule 73 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 73 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 73 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 73 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 73 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (deniable_values -> IDENTIFIER .)
    DOUBLEQUAL      shift and go to state 169
    LESSTHAN        shift and go to state 170
    GREATERTHAN     shift and go to state 171

    condition_operator             shift and go to state 168

state 119

    (91) condition -> EXMARK . IDENTIFIER condition_operator condition_values
    (77) negation_values -> EXMARK . deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 172
    BOOLEAN         shift and go to state 174
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    deniable_values                shift and go to state 173
    booleanOp                      shift and go to state 175

state 120

    (92) condition -> BOOLEAN . condition_operator BOOLEAN
    (74) deniable_values -> BOOLEAN .
    (83) condition_operator -> . DOUBLEQUAL
    (84) condition_operator -> . LESSTHAN
    (85) condition_operator -> . GREATERTHAN
    (86) condition_operator -> . LESSTHAN EQUAL
    (87) condition_operator -> . GREATERTHAN EQUAL

    AND             reduce using rule 74 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 74 (deniable_values -> BOOLEAN .)
    AMPERSAND       reduce using rule 74 (deniable_values -> BOOLEAN .)
    PIPELINE        reduce using rule 74 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 74 (deniable_values -> BOOLEAN .)
    SEMICOLON       reduce using rule 74 (deniable_values -> BOOLEAN .)
    DOUBLEQUAL      shift and go to state 169
    LESSTHAN        shift and go to state 170
    GREATERTHAN     shift and go to state 171

    condition_operator             shift and go to state 176

state 121

    (93) condition -> number . condition_operator number
    (83) condition_operator -> . DOUBLEQUAL
    (84) condition_operator -> . LESSTHAN
    (85) condition_operator -> . GREATERTHAN
    (86) condition_operator -> . LESSTHAN EQUAL
    (87) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 169
    LESSTHAN        shift and go to state 170
    GREATERTHAN     shift and go to state 171

    condition_operator             shift and go to state 177

state 122

    (94) condition -> STR . condition_operator STR
    (83) condition_operator -> . DOUBLEQUAL
    (84) condition_operator -> . LESSTHAN
    (85) condition_operator -> . GREATERTHAN
    (86) condition_operator -> . LESSTHAN EQUAL
    (87) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 169
    LESSTHAN        shift and go to state 170
    GREATERTHAN     shift and go to state 171

    condition_operator             shift and go to state 178

state 123

    (95) condition -> booleanOp . condition_operator booleanOp
    (75) deniable_values -> booleanOp .
    (83) condition_operator -> . DOUBLEQUAL
    (84) condition_operator -> . LESSTHAN
    (85) condition_operator -> . GREATERTHAN
    (86) condition_operator -> . LESSTHAN EQUAL
    (87) condition_operator -> . GREATERTHAN EQUAL

    AND             reduce using rule 75 (deniable_values -> booleanOp .)
    OR              reduce using rule 75 (deniable_values -> booleanOp .)
    AMPERSAND       reduce using rule 75 (deniable_values -> booleanOp .)
    PIPELINE        reduce using rule 75 (deniable_values -> booleanOp .)
    RPAREN          reduce using rule 75 (deniable_values -> booleanOp .)
    SEMICOLON       reduce using rule 75 (deniable_values -> booleanOp .)
    DOUBLEQUAL      shift and go to state 169
    LESSTHAN        shift and go to state 170
    GREATERTHAN     shift and go to state 171

    condition_operator             shift and go to state 179

state 124

    (96) condition -> negation_values .

    AND             reduce using rule 96 (condition -> negation_values .)
    OR              reduce using rule 96 (condition -> negation_values .)
    AMPERSAND       reduce using rule 96 (condition -> negation_values .)
    PIPELINE        reduce using rule 96 (condition -> negation_values .)
    RPAREN          reduce using rule 96 (condition -> negation_values .)
    SEMICOLON       reduce using rule 96 (condition -> negation_values .)


state 125

    (88) number -> FLOAT .

    DOUBLEQUAL      reduce using rule 88 (number -> FLOAT .)
    LESSTHAN        reduce using rule 88 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 88 (number -> FLOAT .)
    PLUS            reduce using rule 88 (number -> FLOAT .)
    MINUS           reduce using rule 88 (number -> FLOAT .)
    TIMES           reduce using rule 88 (number -> FLOAT .)
    DIVISION        reduce using rule 88 (number -> FLOAT .)
    REST            reduce using rule 88 (number -> FLOAT .)
    SEMICOLON       reduce using rule 88 (number -> FLOAT .)
    AND             reduce using rule 88 (number -> FLOAT .)
    OR              reduce using rule 88 (number -> FLOAT .)
    AMPERSAND       reduce using rule 88 (number -> FLOAT .)
    PIPELINE        reduce using rule 88 (number -> FLOAT .)
    RPAREN          reduce using rule 88 (number -> FLOAT .)


state 126

    (89) number -> INTEGER .

    DOUBLEQUAL      reduce using rule 89 (number -> INTEGER .)
    LESSTHAN        reduce using rule 89 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 89 (number -> INTEGER .)
    PLUS            reduce using rule 89 (number -> INTEGER .)
    MINUS           reduce using rule 89 (number -> INTEGER .)
    TIMES           reduce using rule 89 (number -> INTEGER .)
    DIVISION        reduce using rule 89 (number -> INTEGER .)
    REST            reduce using rule 89 (number -> INTEGER .)
    SEMICOLON       reduce using rule 89 (number -> INTEGER .)
    AND             reduce using rule 89 (number -> INTEGER .)
    OR              reduce using rule 89 (number -> INTEGER .)
    AMPERSAND       reduce using rule 89 (number -> INTEGER .)
    PIPELINE        reduce using rule 89 (number -> INTEGER .)
    RPAREN          reduce using rule 89 (number -> INTEGER .)


state 127

    (76) negation_values -> deniable_values .

    AND             reduce using rule 76 (negation_values -> deniable_values .)
    OR              reduce using rule 76 (negation_values -> deniable_values .)
    AMPERSAND       reduce using rule 76 (negation_values -> deniable_values .)
    PIPELINE        reduce using rule 76 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 76 (negation_values -> deniable_values .)
    SEMICOLON       reduce using rule 76 (negation_values -> deniable_values .)


state 128

    (115) expression -> value operatorExpression operatorExpression .

    SEMICOLON       reduce using rule 115 (expression -> value operatorExpression operatorExpression .)
    RPAREN          reduce using rule 115 (expression -> value operatorExpression operatorExpression .)


state 129

    (114) expression -> value operatorExpression expression .

    SEMICOLON       reduce using rule 114 (expression -> value operatorExpression expression .)
    RPAREN          reduce using rule 114 (expression -> value operatorExpression expression .)


state 130

    (42) print -> PRINT LPAREN value . RPAREN SEMICOLON

    RPAREN          shift and go to state 180


state 131

    (136) semanticbool -> BOOL IDENTIFIER EQUAL . conditions SEMICOLON
    (97) conditions -> . condition
    (98) conditions -> . condition condition_connector conditions
    (90) condition -> . IDENTIFIER condition_operator condition_values
    (91) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (92) condition -> . BOOLEAN condition_operator BOOLEAN
    (93) condition -> . number condition_operator number
    (94) condition -> . STR condition_operator STR
    (95) condition -> . booleanOp condition_operator booleanOp
    (96) condition -> . negation_values
    (88) number -> . FLOAT
    (89) number -> . INTEGER
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (76) negation_values -> . deniable_values
    (77) negation_values -> . EXMARK deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 118
    EXMARK          shift and go to state 119
    BOOLEAN         shift and go to state 120
    STR             shift and go to state 122
    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    conditions                     shift and go to state 181
    condition                      shift and go to state 117
    number                         shift and go to state 121
    booleanOp                      shift and go to state 123
    negation_values                shift and go to state 124
    deniable_values                shift and go to state 127

state 132

    (145) semanticlist -> LIST LESSTHAN DYNAMIC . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 182


state 133

    (146) semanticlist -> LIST LESSTHAN INT . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 183


state 134

    (147) semanticlist -> LIST LESSTHAN STRING . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 184


state 135

    (148) semanticlist -> LIST LESSTHAN BOOL . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 185


state 136

    (149) semanticlist -> LIST LESSTHAN DOUBLE . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 186


state 137

    (26) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 187


state 138

    (55) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 188


state 139

    (17) declarationMain -> datatypeOpt MAIN LPAREN RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 189


state 140

    (103) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (108) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (109) optFunction_argumentsExpression -> . empty
    (43) empty -> .

    LCURLYBRACKET   shift and go to state 191
    RPAREN          reduce using rule 43 (empty -> .)

    optFunction_argumentsExpression shift and go to state 190
    empty                          shift and go to state 192

state 141

    (133) declarationExpression -> datatype IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 193


state 142

    (134) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN . datatype RPAREN IDENTIFIER SEMICOLON
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 95
    STRING          shift and go to state 96
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    MAP             shift and go to state 37

    datatype                       shift and go to state 194
    map_identifier                 shift and go to state 98

state 143

    (131) repeatDeclaration -> IDENTIFIER .
    (132) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    SEMICOLON       reduce using rule 131 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 88


state 144

    (132) repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration .

    SEMICOLON       reduce using rule 132 (repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration .)


state 145

    (23) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (44) map_content -> . map_pairs
    (45) map_content -> . empty
    (47) map_pairs -> . map_pair
    (48) map_pairs -> . map_pair COMMA map_pairs
    (43) empty -> .
    (46) map_pair -> . map_key COLON map_value
    (49) map_key -> . value
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   reduce using rule 43 (empty -> .)
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    map_content                    shift and go to state 195
    map_pairs                      shift and go to state 196
    empty                          shift and go to state 197
    map_pair                       shift and go to state 198
    map_key                        shift and go to state 199
    value                          shift and go to state 200
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 146

    (63) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN . LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 201


state 147

    (107) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (106) function_arguments_repeat -> . function_argument
    (107) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (104) function_argument -> . datatype IDENTIFIER
    (105) function_argument -> . empty
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (43) empty -> .
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 95
    STRING          shift and go to state 96
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    COMMA           reduce using rule 43 (empty -> .)
    RPAREN          reduce using rule 43 (empty -> .)
    LCURLYBRACKET   reduce using rule 43 (empty -> .)
    MAP             shift and go to state 37

    function_argument              shift and go to state 92
    function_arguments_repeat      shift and go to state 202
    datatype                       shift and go to state 93
    empty                          shift and go to state 94
    map_identifier                 shift and go to state 98

state 148

    (104) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 104 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 104 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 104 (function_argument -> datatype IDENTIFIER .)


state 149

    (116) asign -> IDENTIFIER EQUAL expression SEMICOLON .

    FINAL           reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 116 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)


state 150

    (117) asign -> IDENTIFIER otherAsignations EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 203


state 151

    (57) elifStatement -> ELSE LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (16) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   shift and go to state 204
    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content                  shift and go to state 48
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 152

    (135) declarationExpression -> FINAL IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 205


state 153

    (59) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> FINAL IDENTIFIER EQUAL STACK . DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    LESSTHAN        shift and go to state 206
    DOT             shift and go to state 207


state 154

    (160) declarationExpression -> STRING IDENTIFIER EQUAL expressionString . SEMICOLON

    SEMICOLON       shift and go to state 208


state 155

    (162) expressionString -> STR .
    (163) expressionString -> STR . operatorExpressionString expressionString
    (164) operatorExpressionString -> . PLUS

    SEMICOLON       reduce using rule 162 (expressionString -> STR .)
    PLUS            shift and go to state 210

    operatorExpressionString       shift and go to state 209

state 156

    (169) expressionInteger -> IDENTIFIER .
    (170) expressionInteger -> IDENTIFIER . operatorExpression expressionInteger
    (125) operatorExpression -> . PLUS
    (126) operatorExpression -> . MINUS
    (127) operatorExpression -> . TIMES
    (128) operatorExpression -> . DIVISION
    (129) operatorExpression -> . REST

    SEMICOLON       reduce using rule 169 (expressionInteger -> IDENTIFIER .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76
    DIVISION        shift and go to state 77
    REST            shift and go to state 78

    operatorExpression             shift and go to state 211

state 157

    (165) declarationExpression -> INT IDENTIFIER EQUAL expressionInteger . SEMICOLON

    SEMICOLON       shift and go to state 212


state 158

    (167) expressionInteger -> number .
    (168) expressionInteger -> number . operatorExpression expressionInteger
    (125) operatorExpression -> . PLUS
    (126) operatorExpression -> . MINUS
    (127) operatorExpression -> . TIMES
    (128) operatorExpression -> . DIVISION
    (129) operatorExpression -> . REST

    SEMICOLON       reduce using rule 167 (expressionInteger -> number .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76
    DIVISION        shift and go to state 77
    REST            shift and go to state 78

    operatorExpression             shift and go to state 213

state 159

    (58) forStatement -> FOR LPAREN declarationExpression SEMICOLON . condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (90) condition -> . IDENTIFIER condition_operator condition_values
    (91) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (92) condition -> . BOOLEAN condition_operator BOOLEAN
    (93) condition -> . number condition_operator number
    (94) condition -> . STR condition_operator STR
    (95) condition -> . booleanOp condition_operator booleanOp
    (96) condition -> . negation_values
    (88) number -> . FLOAT
    (89) number -> . INTEGER
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (76) negation_values -> . deniable_values
    (77) negation_values -> . EXMARK deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 118
    EXMARK          shift and go to state 119
    BOOLEAN         shift and go to state 120
    STR             shift and go to state 122
    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    condition                      shift and go to state 214
    number                         shift and go to state 121
    booleanOp                      shift and go to state 123
    negation_values                shift and go to state 124
    deniable_values                shift and go to state 127

state 160

    (133) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON
    (134) declarationExpression -> datatype IDENTIFIER . EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (131) repeatDeclaration -> IDENTIFIER .
    (132) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    EQUAL           shift and go to state 87
    SEMICOLON       reduce using rule 131 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 88


state 161

    (135) declarationExpression -> FINAL IDENTIFIER . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 215


state 162

    (60) while -> WHILE LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 216


state 163

    (98) conditions -> condition condition_connector . conditions
    (97) conditions -> . condition
    (98) conditions -> . condition condition_connector conditions
    (90) condition -> . IDENTIFIER condition_operator condition_values
    (91) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (92) condition -> . BOOLEAN condition_operator BOOLEAN
    (93) condition -> . number condition_operator number
    (94) condition -> . STR condition_operator STR
    (95) condition -> . booleanOp condition_operator booleanOp
    (96) condition -> . negation_values
    (88) number -> . FLOAT
    (89) number -> . INTEGER
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (76) negation_values -> . deniable_values
    (77) negation_values -> . EXMARK deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp

    IDENTIFIER      shift and go to state 118
    EXMARK          shift and go to state 119
    BOOLEAN         shift and go to state 120
    STR             shift and go to state 122
    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    condition                      shift and go to state 117
    conditions                     shift and go to state 217
    number                         shift and go to state 121
    booleanOp                      shift and go to state 123
    negation_values                shift and go to state 124
    deniable_values                shift and go to state 127

state 164

    (99) condition_connector -> AND .

    IDENTIFIER      reduce using rule 99 (condition_connector -> AND .)
    EXMARK          reduce using rule 99 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 99 (condition_connector -> AND .)
    STR             reduce using rule 99 (condition_connector -> AND .)
    FLOAT           reduce using rule 99 (condition_connector -> AND .)
    INTEGER         reduce using rule 99 (condition_connector -> AND .)
    TRUE            reduce using rule 99 (condition_connector -> AND .)
    FALSE           reduce using rule 99 (condition_connector -> AND .)


state 165

    (100) condition_connector -> OR .

    IDENTIFIER      reduce using rule 100 (condition_connector -> OR .)
    EXMARK          reduce using rule 100 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 100 (condition_connector -> OR .)
    STR             reduce using rule 100 (condition_connector -> OR .)
    FLOAT           reduce using rule 100 (condition_connector -> OR .)
    INTEGER         reduce using rule 100 (condition_connector -> OR .)
    TRUE            reduce using rule 100 (condition_connector -> OR .)
    FALSE           reduce using rule 100 (condition_connector -> OR .)


state 166

    (101) condition_connector -> AMPERSAND . AMPERSAND

    AMPERSAND       shift and go to state 218


state 167

    (102) condition_connector -> PIPELINE . PIPELINE

    PIPELINE        shift and go to state 219


state 168

    (90) condition -> IDENTIFIER condition_operator . condition_values
    (78) condition_values -> . negation_values
    (79) condition_values -> . INTEGER
    (80) condition_values -> . FLOAT
    (81) condition_values -> . STR
    (82) condition_values -> . NULL
    (76) negation_values -> . deniable_values
    (77) negation_values -> . EXMARK deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE

    INTEGER         shift and go to state 223
    FLOAT           shift and go to state 224
    STR             shift and go to state 225
    NULL            shift and go to state 226
    EXMARK          shift and go to state 227
    IDENTIFIER      shift and go to state 220
    BOOLEAN         shift and go to state 174
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    condition_values               shift and go to state 221
    negation_values                shift and go to state 222
    deniable_values                shift and go to state 127
    booleanOp                      shift and go to state 175

state 169

    (83) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 83 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 83 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 83 (condition_operator -> DOUBLEQUAL .)
    NULL            reduce using rule 83 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 83 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 83 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 83 (condition_operator -> DOUBLEQUAL .)
    TRUE            reduce using rule 83 (condition_operator -> DOUBLEQUAL .)
    FALSE           reduce using rule 83 (condition_operator -> DOUBLEQUAL .)


state 170

    (84) condition_operator -> LESSTHAN .
    (86) condition_operator -> LESSTHAN . EQUAL

    INTEGER         reduce using rule 84 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 84 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 84 (condition_operator -> LESSTHAN .)
    NULL            reduce using rule 84 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 84 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 84 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 84 (condition_operator -> LESSTHAN .)
    TRUE            reduce using rule 84 (condition_operator -> LESSTHAN .)
    FALSE           reduce using rule 84 (condition_operator -> LESSTHAN .)
    EQUAL           shift and go to state 228


state 171

    (85) condition_operator -> GREATERTHAN .
    (87) condition_operator -> GREATERTHAN . EQUAL

    INTEGER         reduce using rule 85 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 85 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 85 (condition_operator -> GREATERTHAN .)
    NULL            reduce using rule 85 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 85 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 85 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 85 (condition_operator -> GREATERTHAN .)
    TRUE            reduce using rule 85 (condition_operator -> GREATERTHAN .)
    FALSE           reduce using rule 85 (condition_operator -> GREATERTHAN .)
    EQUAL           shift and go to state 229


state 172

    (91) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (73) deniable_values -> IDENTIFIER .
    (83) condition_operator -> . DOUBLEQUAL
    (84) condition_operator -> . LESSTHAN
    (85) condition_operator -> . GREATERTHAN
    (86) condition_operator -> . LESSTHAN EQUAL
    (87) condition_operator -> . GREATERTHAN EQUAL

    AND             reduce using rule 73 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 73 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 73 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 73 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 73 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (deniable_values -> IDENTIFIER .)
    DOUBLEQUAL      shift and go to state 169
    LESSTHAN        shift and go to state 170
    GREATERTHAN     shift and go to state 171

    condition_operator             shift and go to state 230

state 173

    (77) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 77 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 77 (negation_values -> EXMARK deniable_values .)
    AMPERSAND       reduce using rule 77 (negation_values -> EXMARK deniable_values .)
    PIPELINE        reduce using rule 77 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 77 (negation_values -> EXMARK deniable_values .)
    SEMICOLON       reduce using rule 77 (negation_values -> EXMARK deniable_values .)


state 174

    (74) deniable_values -> BOOLEAN .

    AND             reduce using rule 74 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 74 (deniable_values -> BOOLEAN .)
    AMPERSAND       reduce using rule 74 (deniable_values -> BOOLEAN .)
    PIPELINE        reduce using rule 74 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 74 (deniable_values -> BOOLEAN .)
    SEMICOLON       reduce using rule 74 (deniable_values -> BOOLEAN .)


state 175

    (75) deniable_values -> booleanOp .

    AND             reduce using rule 75 (deniable_values -> booleanOp .)
    OR              reduce using rule 75 (deniable_values -> booleanOp .)
    AMPERSAND       reduce using rule 75 (deniable_values -> booleanOp .)
    PIPELINE        reduce using rule 75 (deniable_values -> booleanOp .)
    RPAREN          reduce using rule 75 (deniable_values -> booleanOp .)
    SEMICOLON       reduce using rule 75 (deniable_values -> booleanOp .)


state 176

    (92) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 231


state 177

    (93) condition -> number condition_operator . number
    (88) number -> . FLOAT
    (89) number -> . INTEGER

    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126

    number                         shift and go to state 232

state 178

    (94) condition -> STR condition_operator . STR

    STR             shift and go to state 233


state 179

    (95) condition -> booleanOp condition_operator . booleanOp
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE

    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    booleanOp                      shift and go to state 234

state 180

    (42) print -> PRINT LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 235


state 181

    (136) semanticbool -> BOOL IDENTIFIER EQUAL conditions . SEMICOLON

    SEMICOLON       shift and go to state 236


state 182

    (145) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 237


state 183

    (146) semanticlist -> LIST LESSTHAN INT GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 238


state 184

    (147) semanticlist -> LIST LESSTHAN STRING GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 239


state 185

    (148) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 240


state 186

    (149) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 241


state 187

    (26) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 95
    STRING          shift and go to state 96
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    MAP             shift and go to state 37

    datatype                       shift and go to state 242
    map_identifier                 shift and go to state 98

state 188

    (55) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 243


state 189

    (17) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (15) class_content_repeat -> . class_content
    (16) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content_repeat           shift and go to state 244
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 190

    (103) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 245


state 191

    (108) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (111) optFunction_arguments -> . optFunction_argument
    (112) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (110) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 248

    optFunction_arguments          shift and go to state 246
    optFunction_argument           shift and go to state 247

state 192

    (109) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 109 (optFunction_argumentsExpression -> empty .)


state 193

    (133) declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .

    FINAL           reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 133 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)


state 194

    (134) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype . RPAREN IDENTIFIER SEMICOLON

    RPAREN          shift and go to state 249


state 195

    (23) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 250


state 196

    (44) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 44 (map_content -> map_pairs .)


state 197

    (45) map_content -> empty .

    RCURLYBRACKET   reduce using rule 45 (map_content -> empty .)


state 198

    (47) map_pairs -> map_pair .
    (48) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 47 (map_pairs -> map_pair .)
    COMMA           shift and go to state 251


state 199

    (46) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 252


state 200

    (49) map_key -> value .

    COLON           reduce using rule 49 (map_key -> value .)


state 201

    (63) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET . RETURN expression SEMICOLON RCURLYBRACKET

    RETURN          shift and go to state 253


state 202

    (107) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    RPAREN          reduce using rule 107 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    LCURLYBRACKET   reduce using rule 107 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 203

    (117) asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .

    FINAL           reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    STRING          reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    INT             reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    FOR             reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    LIST            reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    VOID            reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    VAR             reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    MAP             reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    IF              reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    STR             reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    $end            reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 117 (asign -> IDENTIFIER otherAsignations EQUAL expression SEMICOLON .)


state 204

    (57) elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    PRINT           reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 57 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 205

    (135) declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .

    FINAL           reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 135 (declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON .)


state 206

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 95
    STRING          shift and go to state 96
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    MAP             shift and go to state 37

    datatype                       shift and go to state 254
    map_identifier                 shift and go to state 98

state 207

    (62) stack -> FINAL IDENTIFIER EQUAL STACK DOT . OF LPAREN IDENTIFIER RPAREN SEMICOLON

    OF              shift and go to state 255


state 208

    (160) declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .

    FINAL           reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    STRING          reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    INT             reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FOR             reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    WHILE           reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    IDENTIFIER      reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    PRINT           reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    BOOL            reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    LIST            reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    DOUBLE          reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    DYNAMIC         reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    VOID            reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    VAR             reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    MAP             reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    IF              reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    INTEGER         reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FLOAT           reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    STR             reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    BOOLEAN         reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    TRUE            reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FALSE           reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    MAIN            reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    $end            reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    SEMICOLON       reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    RCURLYBRACKET   reduce using rule 160 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)


state 209

    (163) expressionString -> STR operatorExpressionString . expressionString
    (162) expressionString -> . STR
    (163) expressionString -> . STR operatorExpressionString expressionString

    STR             shift and go to state 155

    expressionString               shift and go to state 256

state 210

    (164) operatorExpressionString -> PLUS .

    STR             reduce using rule 164 (operatorExpressionString -> PLUS .)


state 211

    (170) expressionInteger -> IDENTIFIER operatorExpression . expressionInteger
    (167) expressionInteger -> . number
    (168) expressionInteger -> . number operatorExpression expressionInteger
    (169) expressionInteger -> . IDENTIFIER
    (170) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (88) number -> . FLOAT
    (89) number -> . INTEGER

    IDENTIFIER      shift and go to state 156
    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126

    expressionInteger              shift and go to state 257
    number                         shift and go to state 158

state 212

    (165) declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .

    FINAL           reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    STRING          reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    INT             reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FOR             reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    WHILE           reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    IDENTIFIER      reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    PRINT           reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    BOOL            reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    LIST            reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    DOUBLE          reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    DYNAMIC         reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    VOID            reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    VAR             reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    MAP             reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    IF              reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    INTEGER         reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FLOAT           reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    STR             reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    BOOLEAN         reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    TRUE            reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FALSE           reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    MAIN            reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    $end            reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    SEMICOLON       reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    RCURLYBRACKET   reduce using rule 165 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)


state 213

    (168) expressionInteger -> number operatorExpression . expressionInteger
    (167) expressionInteger -> . number
    (168) expressionInteger -> . number operatorExpression expressionInteger
    (169) expressionInteger -> . IDENTIFIER
    (170) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (88) number -> . FLOAT
    (89) number -> . INTEGER

    IDENTIFIER      shift and go to state 156
    FLOAT           shift and go to state 125
    INTEGER         shift and go to state 126

    number                         shift and go to state 158
    expressionInteger              shift and go to state 258

state 214

    (58) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition . SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 259


state 215

    (135) declarationExpression -> FINAL IDENTIFIER EQUAL . expression SEMICOLON
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expression                     shift and go to state 152
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 216

    (60) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (15) class_content_repeat -> . class_content
    (16) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content_repeat           shift and go to state 260
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 217

    (98) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 98 (conditions -> condition condition_connector conditions .)
    SEMICOLON       reduce using rule 98 (conditions -> condition condition_connector conditions .)


state 218

    (101) condition_connector -> AMPERSAND AMPERSAND .

    IDENTIFIER      reduce using rule 101 (condition_connector -> AMPERSAND AMPERSAND .)
    EXMARK          reduce using rule 101 (condition_connector -> AMPERSAND AMPERSAND .)
    BOOLEAN         reduce using rule 101 (condition_connector -> AMPERSAND AMPERSAND .)
    STR             reduce using rule 101 (condition_connector -> AMPERSAND AMPERSAND .)
    FLOAT           reduce using rule 101 (condition_connector -> AMPERSAND AMPERSAND .)
    INTEGER         reduce using rule 101 (condition_connector -> AMPERSAND AMPERSAND .)
    TRUE            reduce using rule 101 (condition_connector -> AMPERSAND AMPERSAND .)
    FALSE           reduce using rule 101 (condition_connector -> AMPERSAND AMPERSAND .)


state 219

    (102) condition_connector -> PIPELINE PIPELINE .

    IDENTIFIER      reduce using rule 102 (condition_connector -> PIPELINE PIPELINE .)
    EXMARK          reduce using rule 102 (condition_connector -> PIPELINE PIPELINE .)
    BOOLEAN         reduce using rule 102 (condition_connector -> PIPELINE PIPELINE .)
    STR             reduce using rule 102 (condition_connector -> PIPELINE PIPELINE .)
    FLOAT           reduce using rule 102 (condition_connector -> PIPELINE PIPELINE .)
    INTEGER         reduce using rule 102 (condition_connector -> PIPELINE PIPELINE .)
    TRUE            reduce using rule 102 (condition_connector -> PIPELINE PIPELINE .)
    FALSE           reduce using rule 102 (condition_connector -> PIPELINE PIPELINE .)


state 220

    (73) deniable_values -> IDENTIFIER .

    AND             reduce using rule 73 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 73 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 73 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 73 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 73 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (deniable_values -> IDENTIFIER .)


state 221

    (90) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 90 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 90 (condition -> IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 90 (condition -> IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 90 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 90 (condition -> IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 90 (condition -> IDENTIFIER condition_operator condition_values .)


state 222

    (78) condition_values -> negation_values .

    AND             reduce using rule 78 (condition_values -> negation_values .)
    OR              reduce using rule 78 (condition_values -> negation_values .)
    AMPERSAND       reduce using rule 78 (condition_values -> negation_values .)
    PIPELINE        reduce using rule 78 (condition_values -> negation_values .)
    RPAREN          reduce using rule 78 (condition_values -> negation_values .)
    SEMICOLON       reduce using rule 78 (condition_values -> negation_values .)


state 223

    (79) condition_values -> INTEGER .

    AND             reduce using rule 79 (condition_values -> INTEGER .)
    OR              reduce using rule 79 (condition_values -> INTEGER .)
    AMPERSAND       reduce using rule 79 (condition_values -> INTEGER .)
    PIPELINE        reduce using rule 79 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 79 (condition_values -> INTEGER .)
    SEMICOLON       reduce using rule 79 (condition_values -> INTEGER .)


state 224

    (80) condition_values -> FLOAT .

    AND             reduce using rule 80 (condition_values -> FLOAT .)
    OR              reduce using rule 80 (condition_values -> FLOAT .)
    AMPERSAND       reduce using rule 80 (condition_values -> FLOAT .)
    PIPELINE        reduce using rule 80 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 80 (condition_values -> FLOAT .)
    SEMICOLON       reduce using rule 80 (condition_values -> FLOAT .)


state 225

    (81) condition_values -> STR .

    AND             reduce using rule 81 (condition_values -> STR .)
    OR              reduce using rule 81 (condition_values -> STR .)
    AMPERSAND       reduce using rule 81 (condition_values -> STR .)
    PIPELINE        reduce using rule 81 (condition_values -> STR .)
    RPAREN          reduce using rule 81 (condition_values -> STR .)
    SEMICOLON       reduce using rule 81 (condition_values -> STR .)


state 226

    (82) condition_values -> NULL .

    AND             reduce using rule 82 (condition_values -> NULL .)
    OR              reduce using rule 82 (condition_values -> NULL .)
    AMPERSAND       reduce using rule 82 (condition_values -> NULL .)
    PIPELINE        reduce using rule 82 (condition_values -> NULL .)
    RPAREN          reduce using rule 82 (condition_values -> NULL .)
    SEMICOLON       reduce using rule 82 (condition_values -> NULL .)


state 227

    (77) negation_values -> EXMARK . deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 220
    BOOLEAN         shift and go to state 174
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    deniable_values                shift and go to state 173
    booleanOp                      shift and go to state 175

state 228

    (86) condition_operator -> LESSTHAN EQUAL .

    INTEGER         reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)
    FLOAT           reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)
    STR             reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)
    NULL            reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)
    EXMARK          reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)
    IDENTIFIER      reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)
    BOOLEAN         reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)
    TRUE            reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)
    FALSE           reduce using rule 86 (condition_operator -> LESSTHAN EQUAL .)


state 229

    (87) condition_operator -> GREATERTHAN EQUAL .

    INTEGER         reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)
    FLOAT           reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)
    STR             reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)
    NULL            reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)
    EXMARK          reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)
    IDENTIFIER      reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)
    BOOLEAN         reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)
    TRUE            reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)
    FALSE           reduce using rule 87 (condition_operator -> GREATERTHAN EQUAL .)


state 230

    (91) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (78) condition_values -> . negation_values
    (79) condition_values -> . INTEGER
    (80) condition_values -> . FLOAT
    (81) condition_values -> . STR
    (82) condition_values -> . NULL
    (76) negation_values -> . deniable_values
    (77) negation_values -> . EXMARK deniable_values
    (73) deniable_values -> . IDENTIFIER
    (74) deniable_values -> . BOOLEAN
    (75) deniable_values -> . booleanOp
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE

    INTEGER         shift and go to state 223
    FLOAT           shift and go to state 224
    STR             shift and go to state 225
    NULL            shift and go to state 226
    EXMARK          shift and go to state 227
    IDENTIFIER      shift and go to state 220
    BOOLEAN         shift and go to state 174
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    condition_values               shift and go to state 261
    negation_values                shift and go to state 222
    deniable_values                shift and go to state 127
    booleanOp                      shift and go to state 175

state 231

    (92) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 92 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 92 (condition -> BOOLEAN condition_operator BOOLEAN .)
    AMPERSAND       reduce using rule 92 (condition -> BOOLEAN condition_operator BOOLEAN .)
    PIPELINE        reduce using rule 92 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 92 (condition -> BOOLEAN condition_operator BOOLEAN .)
    SEMICOLON       reduce using rule 92 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 232

    (93) condition -> number condition_operator number .

    AND             reduce using rule 93 (condition -> number condition_operator number .)
    OR              reduce using rule 93 (condition -> number condition_operator number .)
    AMPERSAND       reduce using rule 93 (condition -> number condition_operator number .)
    PIPELINE        reduce using rule 93 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 93 (condition -> number condition_operator number .)
    SEMICOLON       reduce using rule 93 (condition -> number condition_operator number .)


state 233

    (94) condition -> STR condition_operator STR .

    AND             reduce using rule 94 (condition -> STR condition_operator STR .)
    OR              reduce using rule 94 (condition -> STR condition_operator STR .)
    AMPERSAND       reduce using rule 94 (condition -> STR condition_operator STR .)
    PIPELINE        reduce using rule 94 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 94 (condition -> STR condition_operator STR .)
    SEMICOLON       reduce using rule 94 (condition -> STR condition_operator STR .)


state 234

    (95) condition -> booleanOp condition_operator booleanOp .

    AND             reduce using rule 95 (condition -> booleanOp condition_operator booleanOp .)
    OR              reduce using rule 95 (condition -> booleanOp condition_operator booleanOp .)
    AMPERSAND       reduce using rule 95 (condition -> booleanOp condition_operator booleanOp .)
    PIPELINE        reduce using rule 95 (condition -> booleanOp condition_operator booleanOp .)
    RPAREN          reduce using rule 95 (condition -> booleanOp condition_operator booleanOp .)
    SEMICOLON       reduce using rule 95 (condition -> booleanOp condition_operator booleanOp .)


state 235

    (42) print -> PRINT LPAREN value RPAREN SEMICOLON .

    FINAL           reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    INT             reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    WHILE           reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    LIST            reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VOID            reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    MAP             reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    STR             reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    TRUE            reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FALSE           reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    MAIN            reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 42 (print -> PRINT LPAREN value RPAREN SEMICOLON .)


state 236

    (136) semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .

    FINAL           reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    STRING          reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    INT             reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    FOR             reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    WHILE           reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    IDENTIFIER      reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    PRINT           reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    BOOL            reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    LIST            reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    DOUBLE          reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    DYNAMIC         reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    VOID            reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    VAR             reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    MAP             reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    IF              reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    INTEGER         reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    FLOAT           reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    STR             reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    BOOLEAN         reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    TRUE            reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    FALSE           reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    MAIN            reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    $end            reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)
    RCURLYBRACKET   reduce using rule 136 (semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON .)


state 237

    (145) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 262


state 238

    (146) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 263


state 239

    (147) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 264


state 240

    (148) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 265


state 241

    (149) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 266


state 242

    (26) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 267


state 243

    (55) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (15) class_content_repeat -> . class_content
    (16) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content_repeat           shift and go to state 268
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 244

    (17) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (16) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   shift and go to state 269
    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content                  shift and go to state 48
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 245

    (103) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 270


state 246

    (108) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 271


state 247

    (111) optFunction_arguments -> optFunction_argument .
    (112) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 111 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 272


state 248

    (110) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 95
    STRING          shift and go to state 96
    BOOL            shift and go to state 97
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    MAP             shift and go to state 37

    datatype                       shift and go to state 273
    map_identifier                 shift and go to state 98

state 249

    (134) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 274


state 250

    (23) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 275


state 251

    (48) map_pairs -> map_pair COMMA . map_pairs
    (47) map_pairs -> . map_pair
    (48) map_pairs -> . map_pair COMMA map_pairs
    (46) map_pair -> . map_key COLON map_value
    (49) map_key -> . value
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    map_pair                       shift and go to state 198
    map_pairs                      shift and go to state 276
    map_key                        shift and go to state 199
    value                          shift and go to state 200
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 252

    (46) map_pair -> map_key COLON . map_value
    (50) map_value -> . value
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    map_value                      shift and go to state 277
    value                          shift and go to state 278
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 253

    (63) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN . expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expression                     shift and go to state 279
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 254

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN RPAREN SEMICOLON

    GREATERTHAN     shift and go to state 280


state 255

    (62) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF . LPAREN IDENTIFIER RPAREN SEMICOLON

    LPAREN          shift and go to state 281


state 256

    (163) expressionString -> STR operatorExpressionString expressionString .

    SEMICOLON       reduce using rule 163 (expressionString -> STR operatorExpressionString expressionString .)


state 257

    (170) expressionInteger -> IDENTIFIER operatorExpression expressionInteger .

    SEMICOLON       reduce using rule 170 (expressionInteger -> IDENTIFIER operatorExpression expressionInteger .)


state 258

    (168) expressionInteger -> number operatorExpression expressionInteger .

    SEMICOLON       reduce using rule 168 (expressionInteger -> number operatorExpression expressionInteger .)


state 259

    (58) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON . expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expression                     shift and go to state 282
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 260

    (60) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (16) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   shift and go to state 283
    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content                  shift and go to state 48
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 261

    (91) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 91 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 91 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 91 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 91 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 91 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 91 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 262

    (145) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 284


state 263

    (146) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 285


state 264

    (147) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 286


state 265

    (148) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 287


state 266

    (149) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 288


state 267

    (26) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 26 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    MAIN            reduce using rule 26 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 26 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    RPAREN          reduce using rule 26 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 26 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 268

    (55) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (16) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (14) class_content -> . print
    (20) class_content -> . semanticbool
    (21) class_content -> . semanticlist
    (22) class_content -> . asign
    (23) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (51) ifElseStatement -> . ifStatement
    (52) ifElseStatement -> . ifStatement elifStatement_repeat
    (103) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (130) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (133) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (134) declarationExpression -> . datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
    (135) declarationExpression -> . FINAL IDENTIFIER EQUAL expression SEMICOLON
    (160) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (161) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (165) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (166) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (58) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (60) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (62) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (63) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (42) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (136) semanticbool -> . BOOL IDENTIFIER EQUAL conditions SEMICOLON
    (145) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (146) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (147) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (148) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (149) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (116) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (117) asign -> . IDENTIFIER otherAsignations EQUAL expression SEMICOLON
    (24) map_identifier -> . MAP
    (25) map_identifier -> . MAP map_type_specified
    (55) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (27) datatype -> . INT
    (28) datatype -> . STRING
    (29) datatype -> . BOOL
    (30) datatype -> . DOUBLE
    (31) datatype -> . DYNAMIC
    (32) datatype -> . VOID
    (33) datatype -> . map_identifier
    (34) datatype -> . VAR
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   shift and go to state 289
    FINAL           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    IDENTIFIER      shift and go to state 22
    PRINT           shift and go to state 30
    BOOL            shift and go to state 31
    LIST            shift and go to state 32
    MAP             shift and go to state 37
    IF              shift and go to state 38
    DOUBLE          shift and go to state 34
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    class_content                  shift and go to state 48
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    print                          shift and go to state 15
    semanticbool                   shift and go to state 16
    semanticlist                   shift and go to state 17
    asign                          shift and go to state 18
    map_identifier                 shift and go to state 21
    ifStatement                    shift and go to state 23
    datatype                       shift and go to state 50
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 269

    (17) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    FINAL           reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    PRINT           reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 17 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 270

    (103) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 290


state 271

    (108) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 108 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 272

    (112) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (111) optFunction_arguments -> . optFunction_argument
    (112) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (110) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 248

    optFunction_argument           shift and go to state 247
    optFunction_arguments          shift and go to state 291

state 273

    (110) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 292


state 274

    (134) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 293


state 275

    (23) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    FINAL           reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STRING          reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INT             reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FOR             reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    WHILE           reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    PRINT           reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOL            reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    LIST            reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VOID            reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VAR             reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAP             reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IF              reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INTEGER         reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FLOAT           reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STR             reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    TRUE            reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FALSE           reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAIN            reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    $end            reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 23 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 276

    (48) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 48 (map_pairs -> map_pair COMMA map_pairs .)


state 277

    (46) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 46 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 46 (map_pair -> map_key COLON map_value .)


state 278

    (50) map_value -> value .

    COMMA           reduce using rule 50 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 50 (map_value -> value .)


state 279

    (63) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression . SEMICOLON RCURLYBRACKET

    SEMICOLON       shift and go to state 294


state 280

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN opt_value RPAREN SEMICOLON
    (61) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 295


state 281

    (62) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN . IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 296


state 282

    (58) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression . RPAREN LCURLYBRACKET RCURLYBRACKET

    RPAREN          shift and go to state 297


state 283

    (60) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    FINAL           reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    PRINT           reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 60 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 284

    (145) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelist RSQUAREBRACKET SEMICOLON
    (150) insidelist -> . value
    (151) insidelist -> . value COMMA insidelist
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    insidelist                     shift and go to state 298
    value                          shift and go to state 299
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 285

    (146) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistint RSQUAREBRACKET SEMICOLON
    (152) insidelistint -> . INTEGER
    (153) insidelistint -> . INTEGER COMMA insidelistint

    INTEGER         shift and go to state 301

    insidelistint                  shift and go to state 300

state 286

    (147) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insideliststr RSQUAREBRACKET SEMICOLON
    (154) insideliststr -> . STR
    (155) insideliststr -> . STR COMMA insideliststr

    STR             shift and go to state 303

    insideliststr                  shift and go to state 302

state 287

    (148) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistbool RSQUAREBRACKET SEMICOLON
    (156) insidelistbool -> . booleanOp
    (157) insidelistbool -> . booleanOp COMMA insidelistbool
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE

    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    insidelistbool                 shift and go to state 304
    booleanOp                      shift and go to state 305

state 288

    (149) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistdouble RSQUAREBRACKET SEMICOLON
    (158) insidelistdouble -> . FLOAT
    (159) insidelistdouble -> . FLOAT COMMA insidelistdouble

    FLOAT           shift and go to state 307

    insidelistdouble               shift and go to state 306

state 289

    (55) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    PRINT           reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 55 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 290

    (103) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (113) expression -> . value
    (114) expression -> . value operatorExpression expression
    (115) expression -> . value operatorExpression operatorExpression
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expression                     shift and go to state 308
    value                          shift and go to state 29
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 291

    (112) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 112 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 292

    (110) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 110 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 110 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 293

    (134) declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .

    FINAL           reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    INT             reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    STR             reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    MAIN            reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    $end            reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 134 (declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON .)


state 294

    (63) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 309


state 295

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . opt_value RPAREN SEMICOLON
    (61) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . RPAREN SEMICOLON
    (71) opt_value -> . value
    (72) opt_value -> . empty
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (43) empty -> .
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 311
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

  ! RPAREN          [ reduce using rule 43 (empty -> .) ]

    opt_value                      shift and go to state 310
    value                          shift and go to state 312
    empty                          shift and go to state 313
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 296

    (62) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER . RPAREN SEMICOLON

    RPAREN          shift and go to state 314


state 297

    (58) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN . LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 315


state 298

    (145) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 316


state 299

    (150) insidelist -> value .
    (151) insidelist -> value . COMMA insidelist

    RSQUAREBRACKET  reduce using rule 150 (insidelist -> value .)
    COMMA           shift and go to state 317


state 300

    (146) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 318


state 301

    (152) insidelistint -> INTEGER .
    (153) insidelistint -> INTEGER . COMMA insidelistint

    RSQUAREBRACKET  reduce using rule 152 (insidelistint -> INTEGER .)
    COMMA           shift and go to state 319


state 302

    (147) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 320


state 303

    (154) insideliststr -> STR .
    (155) insideliststr -> STR . COMMA insideliststr

    RSQUAREBRACKET  reduce using rule 154 (insideliststr -> STR .)
    COMMA           shift and go to state 321


state 304

    (148) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 322


state 305

    (156) insidelistbool -> booleanOp .
    (157) insidelistbool -> booleanOp . COMMA insidelistbool

    RSQUAREBRACKET  reduce using rule 156 (insidelistbool -> booleanOp .)
    COMMA           shift and go to state 323


state 306

    (149) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 324


state 307

    (158) insidelistdouble -> FLOAT .
    (159) insidelistdouble -> FLOAT . COMMA insidelistdouble

    RSQUAREBRACKET  reduce using rule 158 (insidelistdouble -> FLOAT .)
    COMMA           shift and go to state 325


state 308

    (103) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 326


state 309

    (63) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .

    FINAL           reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STRING          reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INT             reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FOR             reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    WHILE           reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    PRINT           reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOL            reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    LIST            reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DOUBLE          reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DYNAMIC         reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VOID            reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VAR             reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAP             reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IF              reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INTEGER         reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FLOAT           reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STR             reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOLEAN         reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    TRUE            reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FALSE           reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAIN            reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    $end            reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 63 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)


state 310

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value . RPAREN SEMICOLON

    RPAREN          shift and go to state 327


state 311

    (61) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 328


state 312

    (71) opt_value -> value .

    RPAREN          reduce using rule 71 (opt_value -> value .)


state 313

    (72) opt_value -> empty .

    RPAREN          reduce using rule 72 (opt_value -> empty .)


state 314

    (62) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 329


state 315

    (58) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 330


state 316

    (145) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 331


state 317

    (151) insidelist -> value COMMA . insidelist
    (150) insidelist -> . value
    (151) insidelist -> . value COMMA insidelist
    (64) value -> . INTEGER
    (65) value -> . FLOAT
    (66) value -> . STR
    (67) value -> . BOOLEAN
    (68) value -> . IDENTIFIER
    (69) value -> . booleanOp
    (70) value -> . propertiesAccess
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE
    (173) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    BOOLEAN         shift and go to state 42
    IDENTIFIER      shift and go to state 99
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    value                          shift and go to state 299
    insidelist                     shift and go to state 332
    booleanOp                      shift and go to state 43
    propertiesAccess               shift and go to state 44

state 318

    (146) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 333


state 319

    (153) insidelistint -> INTEGER COMMA . insidelistint
    (152) insidelistint -> . INTEGER
    (153) insidelistint -> . INTEGER COMMA insidelistint

    INTEGER         shift and go to state 301

    insidelistint                  shift and go to state 334

state 320

    (147) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 335


state 321

    (155) insideliststr -> STR COMMA . insideliststr
    (154) insideliststr -> . STR
    (155) insideliststr -> . STR COMMA insideliststr

    STR             shift and go to state 303

    insideliststr                  shift and go to state 336

state 322

    (148) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 337


state 323

    (157) insidelistbool -> booleanOp COMMA . insidelistbool
    (156) insidelistbool -> . booleanOp
    (157) insidelistbool -> . booleanOp COMMA insidelistbool
    (137) booleanOp -> . TRUE
    (138) booleanOp -> . FALSE

    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    booleanOp                      shift and go to state 305
    insidelistbool                 shift and go to state 338

state 324

    (149) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 339


state 325

    (159) insidelistdouble -> FLOAT COMMA . insidelistdouble
    (158) insidelistdouble -> . FLOAT
    (159) insidelistdouble -> . FLOAT COMMA insidelistdouble

    FLOAT           shift and go to state 307

    insidelistdouble               shift and go to state 340

state 326

    (103) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    FINAL           reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STRING          reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INT             reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FOR             reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    WHILE           reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    PRINT           reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOL            reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    LIST            reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DOUBLE          reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DYNAMIC         reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VOID            reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VAR             reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAP             reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IF              reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INTEGER         reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FLOAT           reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STR             reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOLEAN         reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    TRUE            reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FALSE           reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAIN            reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    $end            reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 103 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)


state 327

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 341


state 328

    (61) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .

    FINAL           reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STR             reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAIN            reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 61 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)


state 329

    (62) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .

    FINAL           reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STRING          reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INT             reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FOR             reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    WHILE           reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    PRINT           reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOL            reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    LIST            reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VOID            reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VAR             reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAP             reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IF              reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INTEGER         reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STR             reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    TRUE            reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FALSE           reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAIN            reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    $end            reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 62 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)


state 330

    (58) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .

    FINAL           reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STRING          reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FOR             reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    WHILE           reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    PRINT           reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    LIST            reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VAR             reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IF              reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INTEGER         reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FLOAT           reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STR             reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOLEAN         reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    TRUE            reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FALSE           reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAIN            reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    $end            reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 58 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)


state 331

    (145) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .

    FINAL           reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 145 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)


state 332

    (151) insidelist -> value COMMA insidelist .

    RSQUAREBRACKET  reduce using rule 151 (insidelist -> value COMMA insidelist .)


state 333

    (146) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .

    FINAL           reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 146 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)


state 334

    (153) insidelistint -> INTEGER COMMA insidelistint .

    RSQUAREBRACKET  reduce using rule 153 (insidelistint -> INTEGER COMMA insidelistint .)


state 335

    (147) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .

    FINAL           reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 147 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)


state 336

    (155) insideliststr -> STR COMMA insideliststr .

    RSQUAREBRACKET  reduce using rule 155 (insideliststr -> STR COMMA insideliststr .)


state 337

    (148) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .

    FINAL           reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 148 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)


state 338

    (157) insidelistbool -> booleanOp COMMA insidelistbool .

    RSQUAREBRACKET  reduce using rule 157 (insidelistbool -> booleanOp COMMA insidelistbool .)


state 339

    (149) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .

    FINAL           reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    STRING          reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    PRINT           reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 149 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)


state 340

    (159) insidelistdouble -> FLOAT COMMA insidelistdouble .

    RSQUAREBRACKET  reduce using rule 159 (insidelistdouble -> FLOAT COMMA insidelistdouble .)


state 341

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .

    FINAL           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STRING          reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INT             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FOR             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    WHILE           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    PRINT           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOL            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    LIST            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VOID            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VAR             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAP             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IF              reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STR             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    TRUE            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FALSE           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAIN            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    $end            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 21 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 22 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 22 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 22 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 22 resolved as shift
WARNING: shift/reduce conflict for REST in state 22 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 25 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 26 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 31 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 295 resolved as shift
