Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APOSTROPHE
    ASYNC
    AWAIT
    CATCH
    CLOSE
    COMMENT
    DO
    DOLLAR
    DOUBQUOTMARK
    EXIT
    FILE
    IMPORT
    IN
    IS
    ITERABLE
    METHOD
    NOTEQUAL
    OPENWRITE
    PRINT
    READLINESYNC
    SET
    TRY
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> class_content_repeat
Rule 2     class -> declarationMain class_content_repeat
Rule 3     class -> class_content_repeat declarationMain
Rule 4     class -> declarationMain
Rule 5     class_content -> map
Rule 6     class_content -> ifElseStatement
Rule 7     class_content -> function_lambda
Rule 8     class_content -> declarationExpression
Rule 9     class_content -> forStatement
Rule 10    class_content -> while
Rule 11    class_content -> stack
Rule 12    class_content -> inferedReturnFunction
Rule 13    class_content -> expression SEMICOLON
Rule 14    class_content_repeat -> class_content
Rule 15    class_content_repeat -> class_content_repeat class_content
Rule 16    declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 17    datatypeOpt -> datatype
Rule 18    datatypeOpt -> empty
Rule 19    class_content -> semanticbool
Rule 20    class_content -> semanticlist
Rule 21    class_content -> asign
Rule 22    map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 23    map_identifier -> MAP
Rule 24    map_identifier -> MAP map_type_specified
Rule 25    map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 26    datatype -> INT
Rule 27    datatype -> STRING
Rule 28    datatype -> BOOL
Rule 29    datatype -> DOUBLE
Rule 30    datatype -> DYNAMIC
Rule 31    datatype -> VOID
Rule 32    datatype -> map_identifier
Rule 33    datatype -> VAR
Rule 34    returnType -> INT
Rule 35    returnType -> STRING
Rule 36    returnType -> BOOL
Rule 37    returnType -> DOUBLE
Rule 38    returnType -> DYNAMIC
Rule 39    returnType -> VOID
Rule 40    returnType -> map_identifier
Rule 41    empty -> <empty>
Rule 42    map_content -> map_pairs
Rule 43    map_content -> empty
Rule 44    map_pair -> map_key COLON map_value
Rule 45    map_pairs -> map_pair
Rule 46    map_pairs -> map_pair COMMA map_pairs
Rule 47    map_key -> value
Rule 48    map_value -> value
Rule 49    ifElseStatement -> ifStatement
Rule 50    ifElseStatement -> ifStatement elifStatement_repeat
Rule 51    elifStatement_repeat -> elifStatement
Rule 52    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 53    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 54    elifStatement -> ELSE ifStatement
Rule 55    elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 56    forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 57    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
Rule 58    while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 59    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
Rule 60    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 61    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
Rule 62    value -> INTEGER
Rule 63    value -> FLOAT
Rule 64    value -> STR
Rule 65    value -> BOOLEAN
Rule 66    value -> IDENTIFIER
Rule 67    value -> booleanOp
Rule 68    value -> propertiesAccess
Rule 69    opt_value -> value
Rule 70    opt_value -> empty
Rule 71    deniable_values -> IDENTIFIER
Rule 72    deniable_values -> BOOLEAN
Rule 73    deniable_values -> booleanOp
Rule 74    negation_values -> deniable_values
Rule 75    negation_values -> EXMARK deniable_values
Rule 76    condition_values -> negation_values
Rule 77    condition_values -> INTEGER
Rule 78    condition_values -> FLOAT
Rule 79    condition_values -> STR
Rule 80    condition_values -> NULL
Rule 81    condition_operator -> DOUBLEQUAL
Rule 82    condition_operator -> LESSTHAN
Rule 83    condition_operator -> GREATERTHAN
Rule 84    condition_operator -> LESSTHAN EQUAL
Rule 85    condition_operator -> GREATERTHAN EQUAL
Rule 86    number -> FLOAT
Rule 87    number -> INTEGER
Rule 88    condition -> IDENTIFIER condition_operator condition_values
Rule 89    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 90    condition -> BOOLEAN condition_operator BOOLEAN
Rule 91    condition -> number condition_operator number
Rule 92    condition -> STR condition_operator STR
Rule 93    condition -> booleanOp condition_operator booleanOp
Rule 94    conditions -> condition
Rule 95    conditions -> condition condition_connector conditions
Rule 96    condition_connector -> AND
Rule 97    condition_connector -> OR
Rule 98    condition_connector -> AMPERSAND AMPERSAND
Rule 99    condition_connector -> PIPELINE PIPELINE
Rule 100   function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 101   function_argument -> datatype IDENTIFIER
Rule 102   function_argument -> empty
Rule 103   function_arguments_repeat -> function_argument
Rule 104   function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 105   optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 106   optFunction_argumentsExpression -> empty
Rule 107   optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 108   optFunction_arguments -> optFunction_argument
Rule 109   optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 110   expression -> value
Rule 111   expression -> value operatorExpression expression
Rule 112   expression -> value operatorExpression operatorExpression
Rule 113   asign -> IDENTIFIER EQUAL expression SEMICOLON
Rule 114   operableTypes -> IDENTIFIER
Rule 115   operableTypes -> number
Rule 116   operatorExpression -> PLUS
Rule 117   operatorExpression -> MINUS
Rule 118   operatorExpression -> TIMES
Rule 119   operatorExpression -> DIVISION
Rule 120   declarationExpression -> datatype repeatDeclaration SEMICOLON
Rule 121   repeatDeclaration -> IDENTIFIER
Rule 122   repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration
Rule 123   declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON
Rule 124   semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
Rule 125   semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON
Rule 126   booleanOp -> TRUE
Rule 127   booleanOp -> FALSE
Rule 128   booloperation -> booleanOp condition_connector booleanOp
Rule 129   booloperation -> IDENTIFIER condition_connector booleanOp
Rule 130   booloperation -> IDENTIFIER condition_connector IDENTIFIER
Rule 131   booloperation -> booleanOp condition_connector IDENTIFIER
Rule 132   booloperations -> booloperation
Rule 133   booloperations -> booloperation condition_connector booloperations
Rule 134   semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
Rule 135   semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
Rule 136   semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
Rule 137   semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
Rule 138   semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
Rule 139   insidelist -> value
Rule 140   insidelist -> value COMMA insidelist
Rule 141   insidelistint -> INTEGER
Rule 142   insidelistint -> INTEGER COMMA insidelistint
Rule 143   insideliststr -> STR
Rule 144   insideliststr -> STR COMMA insideliststr
Rule 145   insidelistbool -> booleanOp
Rule 146   insidelistbool -> booleanOp COMMA insidelistbool
Rule 147   insidelistdouble -> FLOAT
Rule 148   insidelistdouble -> FLOAT COMMA insidelistdouble
Rule 149   declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON
Rule 150   declarationExpression -> STRING IDENTIFIER SEMICOLON
Rule 151   expressionString -> STR
Rule 152   expressionString -> STR operatorExpressionString expressionString
Rule 153   operatorExpressionString -> PLUS
Rule 154   declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON
Rule 155   declarationExpression -> INT IDENTIFIER SEMICOLON
Rule 156   expressionInteger -> number
Rule 157   expressionInteger -> number operatorExpression expressionInteger
Rule 158   expressionInteger -> IDENTIFIER
Rule 159   expressionInteger -> IDENTIFIER operatorExpression expressionInteger
Rule 160   properties -> KEYS
Rule 161   properties -> VALUES
Rule 162   propertiesAccess -> IDENTIFIER DOT properties

Terminals, with rules where they appear

AMPERSAND            : 98 98
AND                  : 96
APOSTROPHE           : 
ASYNC                : 
AWAIT                : 
BOOL                 : 28 36 124 125 137
BOOLEAN              : 65 72 90 90
CATCH                : 
CLOSE                : 
COLON                : 44
COMMA                : 25 46 104 109 122 140 142 144 146 148
COMMENT              : 
DIVISION             : 119
DO                   : 
DOLLAR               : 
DOT                  : 60 162
DOUBLE               : 29 37 138
DOUBLEQUAL           : 81
DOUBQUOTMARK         : 
DYNAMIC              : 30 38 134
ELSE                 : 54 55
EQUAL                : 22 57 59 60 84 85 100 113 123 124 125 134 135 136 137 138 149 154
EXIT                 : 
EXMARK               : 75 89
FALSE                : 127
FILE                 : 
FINAL                : 57 59 60
FLOAT                : 63 78 86 147 148
FOR                  : 56
GREATERTHAN          : 25 57 59 83 85 100 134 135 136 137 138
IDENTIFIER           : 22 57 59 60 60 61 66 71 88 89 100 101 107 113 114 121 122 123 124 125 129 130 130 131 134 135 136 137 138 149 150 154 155 158 159 162
IF                   : 53
IMPORT               : 
IN                   : 
INT                  : 26 34 135 154 155
INTEGER              : 62 77 87 141 142
IS                   : 
ITERABLE             : 
KEYS                 : 160
LCURLYBRACKET        : 16 22 53 55 56 58 61 105
LESSTHAN             : 25 57 59 82 84 134 135 136 137 138
LIST                 : 134 135 136 137 138
LPAREN               : 16 53 56 57 58 59 60 61 100
LSQUAREBRACKET       : 134 135 136 137 138
MAIN                 : 16
MAP                  : 23 24
METHOD               : 
MINUS                : 117
NOTEQUAL             : 
NULL                 : 80
OF                   : 60
OPENWRITE            : 
OR                   : 97
PIPELINE             : 99 99
PLUS                 : 116 153
PRINT                : 
RCURLYBRACKET        : 16 22 53 55 56 58 61 105
READLINESYNC         : 
REQUIRED             : 107
RETURN               : 61
RPAREN               : 16 53 56 57 58 59 60 61 100
RSQUAREBRACKET       : 134 135 136 137 138
SEMICOLON            : 13 22 56 56 57 59 60 61 100 113 120 123 124 125 134 135 136 137 138 149 150 154 155
SET                  : 
STACK                : 57 59 60
STR                  : 64 79 92 92 143 144 151 152
STRING               : 27 35 136 149 150
TIMES                : 118
TRUE                 : 126
TRY                  : 
VALUES               : 161
VAR                  : 33
VOID                 : 31 39
WHILE                : 58
WRITE                : 
error                : 

Nonterminals, with rules where they appear

asign                : 21
booleanOp            : 67 73 93 93 124 128 128 129 131 145 146
booloperation        : 132 133
booloperations       : 125 133
class                : 0
class_content        : 14 15
class_content_repeat : 1 2 3 15 16 53 55 58
condition            : 56 94 95
condition_connector  : 95 128 129 130 131 133
condition_operator   : 88 89 90 91 92 93
condition_values     : 88 89
conditions           : 53 58 95
datatype             : 17 25 25 57 59 100 101 107 120 123
datatypeOpt          : 16
declarationExpression : 8 56
declarationMain      : 2 3 4
deniable_values      : 74 75
elifStatement        : 51 52
elifStatement_repeat : 50 52
empty                : 18 43 70 102 106
expression           : 13 56 61 100 111 113 123
expressionInteger    : 154 157 159
expressionString     : 149 152
forStatement         : 9
function_argument    : 103 104
function_arguments_repeat : 61 100 104
function_lambda      : 7
ifElseStatement      : 6
ifStatement          : 49 50 54
inferedReturnFunction : 12
insidelist           : 134 140
insidelistbool       : 137 146
insidelistdouble     : 138 148
insidelistint        : 135 142
insideliststr        : 136 144
map                  : 5
map_content          : 22
map_identifier       : 22 32 40
map_key              : 44
map_pair             : 45 46
map_pairs            : 42 46
map_type_specified   : 24
map_value            : 44
negation_values      : 76
number               : 91 91 115 156 157
operableTypes        : 
operatorExpression   : 111 112 112 157 159
operatorExpressionString : 152
optFunction_argument : 108 109
optFunction_arguments : 105 109
optFunction_argumentsExpression : 100
opt_value            : 57
properties           : 162
propertiesAccess     : 68
repeatDeclaration    : 120 122
returnType           : 
semanticbool         : 19
semanticlist         : 20
stack                : 11
value                : 47 48 69 110 111 112 139 140
while                : 10

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . class_content_repeat
    (2) class -> . declarationMain class_content_repeat
    (3) class -> . class_content_repeat declarationMain
    (4) class -> . declarationMain
    (14) class_content_repeat -> . class_content
    (15) class_content_repeat -> . class_content_repeat class_content
    (16) declarationMain -> . datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (17) datatypeOpt -> . datatype
    (18) datatypeOpt -> . empty
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (41) empty -> .
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    MAIN            reduce using rule 41 (empty -> .)
    MAP             shift and go to state 36
    IF              shift and go to state 37
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class                          shift and go to state 1
    class_content_repeat           shift and go to state 2
    declarationMain                shift and go to state 3
    class_content                  shift and go to state 4
    datatypeOpt                    shift and go to state 5
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    datatype                       shift and go to state 18
    empty                          shift and go to state 19
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 1

    (0) S' -> class .



state 2

    (1) class -> class_content_repeat .
    (3) class -> class_content_repeat . declarationMain
    (15) class_content_repeat -> class_content_repeat . class_content
    (16) declarationMain -> . datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (17) datatypeOpt -> . datatype
    (18) datatypeOpt -> . empty
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (41) empty -> .
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    $end            reduce using rule 1 (class -> class_content_repeat .)
    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    MAIN            reduce using rule 41 (empty -> .)
    MAP             shift and go to state 36
    IF              shift and go to state 37
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    declarationMain                shift and go to state 45
    class_content                  shift and go to state 46
    datatypeOpt                    shift and go to state 5
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    datatype                       shift and go to state 18
    empty                          shift and go to state 19
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 3

    (2) class -> declarationMain . class_content_repeat
    (4) class -> declarationMain .
    (14) class_content_repeat -> . class_content
    (15) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    $end            reduce using rule 4 (class -> declarationMain .)
    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content_repeat           shift and go to state 47
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 4

    (14) class_content_repeat -> class_content .

    STRING          reduce using rule 14 (class_content_repeat -> class_content .)
    INT             reduce using rule 14 (class_content_repeat -> class_content .)
    FOR             reduce using rule 14 (class_content_repeat -> class_content .)
    WHILE           reduce using rule 14 (class_content_repeat -> class_content .)
    FINAL           reduce using rule 14 (class_content_repeat -> class_content .)
    IDENTIFIER      reduce using rule 14 (class_content_repeat -> class_content .)
    BOOL            reduce using rule 14 (class_content_repeat -> class_content .)
    LIST            reduce using rule 14 (class_content_repeat -> class_content .)
    DOUBLE          reduce using rule 14 (class_content_repeat -> class_content .)
    DYNAMIC         reduce using rule 14 (class_content_repeat -> class_content .)
    VOID            reduce using rule 14 (class_content_repeat -> class_content .)
    VAR             reduce using rule 14 (class_content_repeat -> class_content .)
    MAP             reduce using rule 14 (class_content_repeat -> class_content .)
    IF              reduce using rule 14 (class_content_repeat -> class_content .)
    INTEGER         reduce using rule 14 (class_content_repeat -> class_content .)
    FLOAT           reduce using rule 14 (class_content_repeat -> class_content .)
    STR             reduce using rule 14 (class_content_repeat -> class_content .)
    BOOLEAN         reduce using rule 14 (class_content_repeat -> class_content .)
    TRUE            reduce using rule 14 (class_content_repeat -> class_content .)
    FALSE           reduce using rule 14 (class_content_repeat -> class_content .)
    MAIN            reduce using rule 14 (class_content_repeat -> class_content .)
    $end            reduce using rule 14 (class_content_repeat -> class_content .)
    RCURLYBRACKET   reduce using rule 14 (class_content_repeat -> class_content .)


state 5

    (16) declarationMain -> datatypeOpt . MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    MAIN            shift and go to state 49


state 6

    (5) class_content -> map .

    STRING          reduce using rule 5 (class_content -> map .)
    INT             reduce using rule 5 (class_content -> map .)
    FOR             reduce using rule 5 (class_content -> map .)
    WHILE           reduce using rule 5 (class_content -> map .)
    FINAL           reduce using rule 5 (class_content -> map .)
    IDENTIFIER      reduce using rule 5 (class_content -> map .)
    BOOL            reduce using rule 5 (class_content -> map .)
    LIST            reduce using rule 5 (class_content -> map .)
    DOUBLE          reduce using rule 5 (class_content -> map .)
    DYNAMIC         reduce using rule 5 (class_content -> map .)
    VOID            reduce using rule 5 (class_content -> map .)
    VAR             reduce using rule 5 (class_content -> map .)
    MAP             reduce using rule 5 (class_content -> map .)
    IF              reduce using rule 5 (class_content -> map .)
    INTEGER         reduce using rule 5 (class_content -> map .)
    FLOAT           reduce using rule 5 (class_content -> map .)
    STR             reduce using rule 5 (class_content -> map .)
    BOOLEAN         reduce using rule 5 (class_content -> map .)
    TRUE            reduce using rule 5 (class_content -> map .)
    FALSE           reduce using rule 5 (class_content -> map .)
    MAIN            reduce using rule 5 (class_content -> map .)
    $end            reduce using rule 5 (class_content -> map .)
    RCURLYBRACKET   reduce using rule 5 (class_content -> map .)


state 7

    (6) class_content -> ifElseStatement .

    STRING          reduce using rule 6 (class_content -> ifElseStatement .)
    INT             reduce using rule 6 (class_content -> ifElseStatement .)
    FOR             reduce using rule 6 (class_content -> ifElseStatement .)
    WHILE           reduce using rule 6 (class_content -> ifElseStatement .)
    FINAL           reduce using rule 6 (class_content -> ifElseStatement .)
    IDENTIFIER      reduce using rule 6 (class_content -> ifElseStatement .)
    BOOL            reduce using rule 6 (class_content -> ifElseStatement .)
    LIST            reduce using rule 6 (class_content -> ifElseStatement .)
    DOUBLE          reduce using rule 6 (class_content -> ifElseStatement .)
    DYNAMIC         reduce using rule 6 (class_content -> ifElseStatement .)
    VOID            reduce using rule 6 (class_content -> ifElseStatement .)
    VAR             reduce using rule 6 (class_content -> ifElseStatement .)
    MAP             reduce using rule 6 (class_content -> ifElseStatement .)
    IF              reduce using rule 6 (class_content -> ifElseStatement .)
    INTEGER         reduce using rule 6 (class_content -> ifElseStatement .)
    FLOAT           reduce using rule 6 (class_content -> ifElseStatement .)
    STR             reduce using rule 6 (class_content -> ifElseStatement .)
    BOOLEAN         reduce using rule 6 (class_content -> ifElseStatement .)
    TRUE            reduce using rule 6 (class_content -> ifElseStatement .)
    FALSE           reduce using rule 6 (class_content -> ifElseStatement .)
    MAIN            reduce using rule 6 (class_content -> ifElseStatement .)
    $end            reduce using rule 6 (class_content -> ifElseStatement .)
    RCURLYBRACKET   reduce using rule 6 (class_content -> ifElseStatement .)


state 8

    (7) class_content -> function_lambda .

    STRING          reduce using rule 7 (class_content -> function_lambda .)
    INT             reduce using rule 7 (class_content -> function_lambda .)
    FOR             reduce using rule 7 (class_content -> function_lambda .)
    WHILE           reduce using rule 7 (class_content -> function_lambda .)
    FINAL           reduce using rule 7 (class_content -> function_lambda .)
    IDENTIFIER      reduce using rule 7 (class_content -> function_lambda .)
    BOOL            reduce using rule 7 (class_content -> function_lambda .)
    LIST            reduce using rule 7 (class_content -> function_lambda .)
    DOUBLE          reduce using rule 7 (class_content -> function_lambda .)
    DYNAMIC         reduce using rule 7 (class_content -> function_lambda .)
    VOID            reduce using rule 7 (class_content -> function_lambda .)
    VAR             reduce using rule 7 (class_content -> function_lambda .)
    MAP             reduce using rule 7 (class_content -> function_lambda .)
    IF              reduce using rule 7 (class_content -> function_lambda .)
    INTEGER         reduce using rule 7 (class_content -> function_lambda .)
    FLOAT           reduce using rule 7 (class_content -> function_lambda .)
    STR             reduce using rule 7 (class_content -> function_lambda .)
    BOOLEAN         reduce using rule 7 (class_content -> function_lambda .)
    TRUE            reduce using rule 7 (class_content -> function_lambda .)
    FALSE           reduce using rule 7 (class_content -> function_lambda .)
    MAIN            reduce using rule 7 (class_content -> function_lambda .)
    $end            reduce using rule 7 (class_content -> function_lambda .)
    RCURLYBRACKET   reduce using rule 7 (class_content -> function_lambda .)


state 9

    (8) class_content -> declarationExpression .

    STRING          reduce using rule 8 (class_content -> declarationExpression .)
    INT             reduce using rule 8 (class_content -> declarationExpression .)
    FOR             reduce using rule 8 (class_content -> declarationExpression .)
    WHILE           reduce using rule 8 (class_content -> declarationExpression .)
    FINAL           reduce using rule 8 (class_content -> declarationExpression .)
    IDENTIFIER      reduce using rule 8 (class_content -> declarationExpression .)
    BOOL            reduce using rule 8 (class_content -> declarationExpression .)
    LIST            reduce using rule 8 (class_content -> declarationExpression .)
    DOUBLE          reduce using rule 8 (class_content -> declarationExpression .)
    DYNAMIC         reduce using rule 8 (class_content -> declarationExpression .)
    VOID            reduce using rule 8 (class_content -> declarationExpression .)
    VAR             reduce using rule 8 (class_content -> declarationExpression .)
    MAP             reduce using rule 8 (class_content -> declarationExpression .)
    IF              reduce using rule 8 (class_content -> declarationExpression .)
    INTEGER         reduce using rule 8 (class_content -> declarationExpression .)
    FLOAT           reduce using rule 8 (class_content -> declarationExpression .)
    STR             reduce using rule 8 (class_content -> declarationExpression .)
    BOOLEAN         reduce using rule 8 (class_content -> declarationExpression .)
    TRUE            reduce using rule 8 (class_content -> declarationExpression .)
    FALSE           reduce using rule 8 (class_content -> declarationExpression .)
    MAIN            reduce using rule 8 (class_content -> declarationExpression .)
    $end            reduce using rule 8 (class_content -> declarationExpression .)
    RCURLYBRACKET   reduce using rule 8 (class_content -> declarationExpression .)


state 10

    (9) class_content -> forStatement .

    STRING          reduce using rule 9 (class_content -> forStatement .)
    INT             reduce using rule 9 (class_content -> forStatement .)
    FOR             reduce using rule 9 (class_content -> forStatement .)
    WHILE           reduce using rule 9 (class_content -> forStatement .)
    FINAL           reduce using rule 9 (class_content -> forStatement .)
    IDENTIFIER      reduce using rule 9 (class_content -> forStatement .)
    BOOL            reduce using rule 9 (class_content -> forStatement .)
    LIST            reduce using rule 9 (class_content -> forStatement .)
    DOUBLE          reduce using rule 9 (class_content -> forStatement .)
    DYNAMIC         reduce using rule 9 (class_content -> forStatement .)
    VOID            reduce using rule 9 (class_content -> forStatement .)
    VAR             reduce using rule 9 (class_content -> forStatement .)
    MAP             reduce using rule 9 (class_content -> forStatement .)
    IF              reduce using rule 9 (class_content -> forStatement .)
    INTEGER         reduce using rule 9 (class_content -> forStatement .)
    FLOAT           reduce using rule 9 (class_content -> forStatement .)
    STR             reduce using rule 9 (class_content -> forStatement .)
    BOOLEAN         reduce using rule 9 (class_content -> forStatement .)
    TRUE            reduce using rule 9 (class_content -> forStatement .)
    FALSE           reduce using rule 9 (class_content -> forStatement .)
    MAIN            reduce using rule 9 (class_content -> forStatement .)
    $end            reduce using rule 9 (class_content -> forStatement .)
    RCURLYBRACKET   reduce using rule 9 (class_content -> forStatement .)


state 11

    (10) class_content -> while .

    STRING          reduce using rule 10 (class_content -> while .)
    INT             reduce using rule 10 (class_content -> while .)
    FOR             reduce using rule 10 (class_content -> while .)
    WHILE           reduce using rule 10 (class_content -> while .)
    FINAL           reduce using rule 10 (class_content -> while .)
    IDENTIFIER      reduce using rule 10 (class_content -> while .)
    BOOL            reduce using rule 10 (class_content -> while .)
    LIST            reduce using rule 10 (class_content -> while .)
    DOUBLE          reduce using rule 10 (class_content -> while .)
    DYNAMIC         reduce using rule 10 (class_content -> while .)
    VOID            reduce using rule 10 (class_content -> while .)
    VAR             reduce using rule 10 (class_content -> while .)
    MAP             reduce using rule 10 (class_content -> while .)
    IF              reduce using rule 10 (class_content -> while .)
    INTEGER         reduce using rule 10 (class_content -> while .)
    FLOAT           reduce using rule 10 (class_content -> while .)
    STR             reduce using rule 10 (class_content -> while .)
    BOOLEAN         reduce using rule 10 (class_content -> while .)
    TRUE            reduce using rule 10 (class_content -> while .)
    FALSE           reduce using rule 10 (class_content -> while .)
    MAIN            reduce using rule 10 (class_content -> while .)
    $end            reduce using rule 10 (class_content -> while .)
    RCURLYBRACKET   reduce using rule 10 (class_content -> while .)


state 12

    (11) class_content -> stack .

    STRING          reduce using rule 11 (class_content -> stack .)
    INT             reduce using rule 11 (class_content -> stack .)
    FOR             reduce using rule 11 (class_content -> stack .)
    WHILE           reduce using rule 11 (class_content -> stack .)
    FINAL           reduce using rule 11 (class_content -> stack .)
    IDENTIFIER      reduce using rule 11 (class_content -> stack .)
    BOOL            reduce using rule 11 (class_content -> stack .)
    LIST            reduce using rule 11 (class_content -> stack .)
    DOUBLE          reduce using rule 11 (class_content -> stack .)
    DYNAMIC         reduce using rule 11 (class_content -> stack .)
    VOID            reduce using rule 11 (class_content -> stack .)
    VAR             reduce using rule 11 (class_content -> stack .)
    MAP             reduce using rule 11 (class_content -> stack .)
    IF              reduce using rule 11 (class_content -> stack .)
    INTEGER         reduce using rule 11 (class_content -> stack .)
    FLOAT           reduce using rule 11 (class_content -> stack .)
    STR             reduce using rule 11 (class_content -> stack .)
    BOOLEAN         reduce using rule 11 (class_content -> stack .)
    TRUE            reduce using rule 11 (class_content -> stack .)
    FALSE           reduce using rule 11 (class_content -> stack .)
    MAIN            reduce using rule 11 (class_content -> stack .)
    $end            reduce using rule 11 (class_content -> stack .)
    RCURLYBRACKET   reduce using rule 11 (class_content -> stack .)


state 13

    (12) class_content -> inferedReturnFunction .

    STRING          reduce using rule 12 (class_content -> inferedReturnFunction .)
    INT             reduce using rule 12 (class_content -> inferedReturnFunction .)
    FOR             reduce using rule 12 (class_content -> inferedReturnFunction .)
    WHILE           reduce using rule 12 (class_content -> inferedReturnFunction .)
    FINAL           reduce using rule 12 (class_content -> inferedReturnFunction .)
    IDENTIFIER      reduce using rule 12 (class_content -> inferedReturnFunction .)
    BOOL            reduce using rule 12 (class_content -> inferedReturnFunction .)
    LIST            reduce using rule 12 (class_content -> inferedReturnFunction .)
    DOUBLE          reduce using rule 12 (class_content -> inferedReturnFunction .)
    DYNAMIC         reduce using rule 12 (class_content -> inferedReturnFunction .)
    VOID            reduce using rule 12 (class_content -> inferedReturnFunction .)
    VAR             reduce using rule 12 (class_content -> inferedReturnFunction .)
    MAP             reduce using rule 12 (class_content -> inferedReturnFunction .)
    IF              reduce using rule 12 (class_content -> inferedReturnFunction .)
    INTEGER         reduce using rule 12 (class_content -> inferedReturnFunction .)
    FLOAT           reduce using rule 12 (class_content -> inferedReturnFunction .)
    STR             reduce using rule 12 (class_content -> inferedReturnFunction .)
    BOOLEAN         reduce using rule 12 (class_content -> inferedReturnFunction .)
    TRUE            reduce using rule 12 (class_content -> inferedReturnFunction .)
    FALSE           reduce using rule 12 (class_content -> inferedReturnFunction .)
    MAIN            reduce using rule 12 (class_content -> inferedReturnFunction .)
    $end            reduce using rule 12 (class_content -> inferedReturnFunction .)
    RCURLYBRACKET   reduce using rule 12 (class_content -> inferedReturnFunction .)


state 14

    (13) class_content -> expression . SEMICOLON

    SEMICOLON       shift and go to state 50


state 15

    (19) class_content -> semanticbool .

    STRING          reduce using rule 19 (class_content -> semanticbool .)
    INT             reduce using rule 19 (class_content -> semanticbool .)
    FOR             reduce using rule 19 (class_content -> semanticbool .)
    WHILE           reduce using rule 19 (class_content -> semanticbool .)
    FINAL           reduce using rule 19 (class_content -> semanticbool .)
    IDENTIFIER      reduce using rule 19 (class_content -> semanticbool .)
    BOOL            reduce using rule 19 (class_content -> semanticbool .)
    LIST            reduce using rule 19 (class_content -> semanticbool .)
    DOUBLE          reduce using rule 19 (class_content -> semanticbool .)
    DYNAMIC         reduce using rule 19 (class_content -> semanticbool .)
    VOID            reduce using rule 19 (class_content -> semanticbool .)
    VAR             reduce using rule 19 (class_content -> semanticbool .)
    MAP             reduce using rule 19 (class_content -> semanticbool .)
    IF              reduce using rule 19 (class_content -> semanticbool .)
    INTEGER         reduce using rule 19 (class_content -> semanticbool .)
    FLOAT           reduce using rule 19 (class_content -> semanticbool .)
    STR             reduce using rule 19 (class_content -> semanticbool .)
    BOOLEAN         reduce using rule 19 (class_content -> semanticbool .)
    TRUE            reduce using rule 19 (class_content -> semanticbool .)
    FALSE           reduce using rule 19 (class_content -> semanticbool .)
    MAIN            reduce using rule 19 (class_content -> semanticbool .)
    $end            reduce using rule 19 (class_content -> semanticbool .)
    RCURLYBRACKET   reduce using rule 19 (class_content -> semanticbool .)


state 16

    (20) class_content -> semanticlist .

    STRING          reduce using rule 20 (class_content -> semanticlist .)
    INT             reduce using rule 20 (class_content -> semanticlist .)
    FOR             reduce using rule 20 (class_content -> semanticlist .)
    WHILE           reduce using rule 20 (class_content -> semanticlist .)
    FINAL           reduce using rule 20 (class_content -> semanticlist .)
    IDENTIFIER      reduce using rule 20 (class_content -> semanticlist .)
    BOOL            reduce using rule 20 (class_content -> semanticlist .)
    LIST            reduce using rule 20 (class_content -> semanticlist .)
    DOUBLE          reduce using rule 20 (class_content -> semanticlist .)
    DYNAMIC         reduce using rule 20 (class_content -> semanticlist .)
    VOID            reduce using rule 20 (class_content -> semanticlist .)
    VAR             reduce using rule 20 (class_content -> semanticlist .)
    MAP             reduce using rule 20 (class_content -> semanticlist .)
    IF              reduce using rule 20 (class_content -> semanticlist .)
    INTEGER         reduce using rule 20 (class_content -> semanticlist .)
    FLOAT           reduce using rule 20 (class_content -> semanticlist .)
    STR             reduce using rule 20 (class_content -> semanticlist .)
    BOOLEAN         reduce using rule 20 (class_content -> semanticlist .)
    TRUE            reduce using rule 20 (class_content -> semanticlist .)
    FALSE           reduce using rule 20 (class_content -> semanticlist .)
    MAIN            reduce using rule 20 (class_content -> semanticlist .)
    $end            reduce using rule 20 (class_content -> semanticlist .)
    RCURLYBRACKET   reduce using rule 20 (class_content -> semanticlist .)


state 17

    (21) class_content -> asign .

    STRING          reduce using rule 21 (class_content -> asign .)
    INT             reduce using rule 21 (class_content -> asign .)
    FOR             reduce using rule 21 (class_content -> asign .)
    WHILE           reduce using rule 21 (class_content -> asign .)
    FINAL           reduce using rule 21 (class_content -> asign .)
    IDENTIFIER      reduce using rule 21 (class_content -> asign .)
    BOOL            reduce using rule 21 (class_content -> asign .)
    LIST            reduce using rule 21 (class_content -> asign .)
    DOUBLE          reduce using rule 21 (class_content -> asign .)
    DYNAMIC         reduce using rule 21 (class_content -> asign .)
    VOID            reduce using rule 21 (class_content -> asign .)
    VAR             reduce using rule 21 (class_content -> asign .)
    MAP             reduce using rule 21 (class_content -> asign .)
    IF              reduce using rule 21 (class_content -> asign .)
    INTEGER         reduce using rule 21 (class_content -> asign .)
    FLOAT           reduce using rule 21 (class_content -> asign .)
    STR             reduce using rule 21 (class_content -> asign .)
    BOOLEAN         reduce using rule 21 (class_content -> asign .)
    TRUE            reduce using rule 21 (class_content -> asign .)
    FALSE           reduce using rule 21 (class_content -> asign .)
    MAIN            reduce using rule 21 (class_content -> asign .)
    $end            reduce using rule 21 (class_content -> asign .)
    RCURLYBRACKET   reduce using rule 21 (class_content -> asign .)


state 18

    (17) datatypeOpt -> datatype .
    (100) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (123) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (121) repeatDeclaration -> . IDENTIFIER
    (122) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    MAIN            reduce using rule 17 (datatypeOpt -> datatype .)
    IDENTIFIER      shift and go to state 51

    repeatDeclaration              shift and go to state 52

state 19

    (18) datatypeOpt -> empty .

    MAIN            reduce using rule 18 (datatypeOpt -> empty .)


state 20

    (22) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (32) datatype -> map_identifier .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 53
    MAIN            reduce using rule 32 (datatype -> map_identifier .)

  ! IDENTIFIER      [ reduce using rule 32 (datatype -> map_identifier .) ]


state 21

    (61) inferedReturnFunction -> IDENTIFIER . LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (113) asign -> IDENTIFIER . EQUAL expression SEMICOLON
    (66) value -> IDENTIFIER .
    (162) propertiesAccess -> IDENTIFIER . DOT properties

    LPAREN          shift and go to state 54
    EQUAL           shift and go to state 55
    PLUS            reduce using rule 66 (value -> IDENTIFIER .)
    MINUS           reduce using rule 66 (value -> IDENTIFIER .)
    TIMES           reduce using rule 66 (value -> IDENTIFIER .)
    DIVISION        reduce using rule 66 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 66 (value -> IDENTIFIER .)
    DOT             shift and go to state 56


state 22

    (49) ifElseStatement -> ifStatement .
    (50) ifElseStatement -> ifStatement . elifStatement_repeat
    (51) elifStatement_repeat -> . elifStatement
    (52) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (54) elifStatement -> . ELSE ifStatement
    (55) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    STRING          reduce using rule 49 (ifElseStatement -> ifStatement .)
    INT             reduce using rule 49 (ifElseStatement -> ifStatement .)
    FOR             reduce using rule 49 (ifElseStatement -> ifStatement .)
    WHILE           reduce using rule 49 (ifElseStatement -> ifStatement .)
    FINAL           reduce using rule 49 (ifElseStatement -> ifStatement .)
    IDENTIFIER      reduce using rule 49 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 49 (ifElseStatement -> ifStatement .)
    LIST            reduce using rule 49 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 49 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 49 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 49 (ifElseStatement -> ifStatement .)
    VAR             reduce using rule 49 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 49 (ifElseStatement -> ifStatement .)
    IF              reduce using rule 49 (ifElseStatement -> ifStatement .)
    INTEGER         reduce using rule 49 (ifElseStatement -> ifStatement .)
    FLOAT           reduce using rule 49 (ifElseStatement -> ifStatement .)
    STR             reduce using rule 49 (ifElseStatement -> ifStatement .)
    BOOLEAN         reduce using rule 49 (ifElseStatement -> ifStatement .)
    TRUE            reduce using rule 49 (ifElseStatement -> ifStatement .)
    FALSE           reduce using rule 49 (ifElseStatement -> ifStatement .)
    MAIN            reduce using rule 49 (ifElseStatement -> ifStatement .)
    $end            reduce using rule 49 (ifElseStatement -> ifStatement .)
    RCURLYBRACKET   reduce using rule 49 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 59

    elifStatement_repeat           shift and go to state 57
    elifStatement                  shift and go to state 58

state 23

    (149) declarationExpression -> STRING . IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> STRING . IDENTIFIER SEMICOLON
    (27) datatype -> STRING .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 60
    MAIN            reduce using rule 27 (datatype -> STRING .)

  ! IDENTIFIER      [ reduce using rule 27 (datatype -> STRING .) ]


state 24

    (154) declarationExpression -> INT . IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> INT . IDENTIFIER SEMICOLON
    (26) datatype -> INT .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 61
    MAIN            reduce using rule 26 (datatype -> INT .)

  ! IDENTIFIER      [ reduce using rule 26 (datatype -> INT .) ]


state 25

    (56) forStatement -> FOR . LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    LPAREN          shift and go to state 62


state 26

    (58) while -> WHILE . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 63


state 27

    (57) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> FINAL . IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 64


state 28

    (110) expression -> value .
    (111) expression -> value . operatorExpression expression
    (112) expression -> value . operatorExpression operatorExpression
    (116) operatorExpression -> . PLUS
    (117) operatorExpression -> . MINUS
    (118) operatorExpression -> . TIMES
    (119) operatorExpression -> . DIVISION

    SEMICOLON       reduce using rule 110 (expression -> value .)
    RPAREN          reduce using rule 110 (expression -> value .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVISION        shift and go to state 69

    operatorExpression             shift and go to state 65

state 29

    (124) semanticbool -> BOOL . IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> BOOL . IDENTIFIER EQUAL booloperations SEMICOLON
    (28) datatype -> BOOL .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 70
    MAIN            reduce using rule 28 (datatype -> BOOL .)

  ! IDENTIFIER      [ reduce using rule 28 (datatype -> BOOL .) ]


state 30

    (67) value -> booleanOp .

    PLUS            reduce using rule 67 (value -> booleanOp .)
    MINUS           reduce using rule 67 (value -> booleanOp .)
    TIMES           reduce using rule 67 (value -> booleanOp .)
    DIVISION        reduce using rule 67 (value -> booleanOp .)
    SEMICOLON       reduce using rule 67 (value -> booleanOp .)
    RPAREN          reduce using rule 67 (value -> booleanOp .)
    COLON           reduce using rule 67 (value -> booleanOp .)
    COMMA           reduce using rule 67 (value -> booleanOp .)
    RCURLYBRACKET   reduce using rule 67 (value -> booleanOp .)
    RSQUAREBRACKET  reduce using rule 67 (value -> booleanOp .)


state 31

    (134) semanticlist -> LIST . LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> LIST . LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> LIST . LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> LIST . LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> LIST . LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    LESSTHAN        shift and go to state 71


state 32

    (30) datatype -> DYNAMIC .

    IDENTIFIER      reduce using rule 30 (datatype -> DYNAMIC .)
    MAIN            reduce using rule 30 (datatype -> DYNAMIC .)
    COMMA           reduce using rule 30 (datatype -> DYNAMIC .)
    GREATERTHAN     reduce using rule 30 (datatype -> DYNAMIC .)


state 33

    (29) datatype -> DOUBLE .

    IDENTIFIER      reduce using rule 29 (datatype -> DOUBLE .)
    MAIN            reduce using rule 29 (datatype -> DOUBLE .)
    COMMA           reduce using rule 29 (datatype -> DOUBLE .)
    GREATERTHAN     reduce using rule 29 (datatype -> DOUBLE .)


state 34

    (31) datatype -> VOID .

    IDENTIFIER      reduce using rule 31 (datatype -> VOID .)
    MAIN            reduce using rule 31 (datatype -> VOID .)
    COMMA           reduce using rule 31 (datatype -> VOID .)
    GREATERTHAN     reduce using rule 31 (datatype -> VOID .)


state 35

    (33) datatype -> VAR .

    IDENTIFIER      reduce using rule 33 (datatype -> VAR .)
    MAIN            reduce using rule 33 (datatype -> VAR .)
    COMMA           reduce using rule 33 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 33 (datatype -> VAR .)


state 36

    (23) map_identifier -> MAP .
    (24) map_identifier -> MAP . map_type_specified
    (25) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 23 (map_identifier -> MAP .)
    MAIN            reduce using rule 23 (map_identifier -> MAP .)
    COMMA           reduce using rule 23 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 23 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 73

    map_type_specified             shift and go to state 72

state 37

    (53) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 74


state 38

    (62) value -> INTEGER .

    PLUS            reduce using rule 62 (value -> INTEGER .)
    MINUS           reduce using rule 62 (value -> INTEGER .)
    TIMES           reduce using rule 62 (value -> INTEGER .)
    DIVISION        reduce using rule 62 (value -> INTEGER .)
    SEMICOLON       reduce using rule 62 (value -> INTEGER .)
    RPAREN          reduce using rule 62 (value -> INTEGER .)
    COLON           reduce using rule 62 (value -> INTEGER .)
    COMMA           reduce using rule 62 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 62 (value -> INTEGER .)
    RSQUAREBRACKET  reduce using rule 62 (value -> INTEGER .)


state 39

    (63) value -> FLOAT .

    PLUS            reduce using rule 63 (value -> FLOAT .)
    MINUS           reduce using rule 63 (value -> FLOAT .)
    TIMES           reduce using rule 63 (value -> FLOAT .)
    DIVISION        reduce using rule 63 (value -> FLOAT .)
    SEMICOLON       reduce using rule 63 (value -> FLOAT .)
    RPAREN          reduce using rule 63 (value -> FLOAT .)
    COLON           reduce using rule 63 (value -> FLOAT .)
    COMMA           reduce using rule 63 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 63 (value -> FLOAT .)
    RSQUAREBRACKET  reduce using rule 63 (value -> FLOAT .)


state 40

    (64) value -> STR .

    PLUS            reduce using rule 64 (value -> STR .)
    MINUS           reduce using rule 64 (value -> STR .)
    TIMES           reduce using rule 64 (value -> STR .)
    DIVISION        reduce using rule 64 (value -> STR .)
    SEMICOLON       reduce using rule 64 (value -> STR .)
    RPAREN          reduce using rule 64 (value -> STR .)
    COLON           reduce using rule 64 (value -> STR .)
    COMMA           reduce using rule 64 (value -> STR .)
    RCURLYBRACKET   reduce using rule 64 (value -> STR .)
    RSQUAREBRACKET  reduce using rule 64 (value -> STR .)


state 41

    (65) value -> BOOLEAN .

    PLUS            reduce using rule 65 (value -> BOOLEAN .)
    MINUS           reduce using rule 65 (value -> BOOLEAN .)
    TIMES           reduce using rule 65 (value -> BOOLEAN .)
    DIVISION        reduce using rule 65 (value -> BOOLEAN .)
    SEMICOLON       reduce using rule 65 (value -> BOOLEAN .)
    RPAREN          reduce using rule 65 (value -> BOOLEAN .)
    COLON           reduce using rule 65 (value -> BOOLEAN .)
    COMMA           reduce using rule 65 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 65 (value -> BOOLEAN .)
    RSQUAREBRACKET  reduce using rule 65 (value -> BOOLEAN .)


state 42

    (68) value -> propertiesAccess .

    PLUS            reduce using rule 68 (value -> propertiesAccess .)
    MINUS           reduce using rule 68 (value -> propertiesAccess .)
    TIMES           reduce using rule 68 (value -> propertiesAccess .)
    DIVISION        reduce using rule 68 (value -> propertiesAccess .)
    SEMICOLON       reduce using rule 68 (value -> propertiesAccess .)
    RPAREN          reduce using rule 68 (value -> propertiesAccess .)
    COLON           reduce using rule 68 (value -> propertiesAccess .)
    COMMA           reduce using rule 68 (value -> propertiesAccess .)
    RCURLYBRACKET   reduce using rule 68 (value -> propertiesAccess .)
    RSQUAREBRACKET  reduce using rule 68 (value -> propertiesAccess .)


state 43

    (126) booleanOp -> TRUE .

    PLUS            reduce using rule 126 (booleanOp -> TRUE .)
    MINUS           reduce using rule 126 (booleanOp -> TRUE .)
    TIMES           reduce using rule 126 (booleanOp -> TRUE .)
    DIVISION        reduce using rule 126 (booleanOp -> TRUE .)
    SEMICOLON       reduce using rule 126 (booleanOp -> TRUE .)
    DOUBLEQUAL      reduce using rule 126 (booleanOp -> TRUE .)
    LESSTHAN        reduce using rule 126 (booleanOp -> TRUE .)
    GREATERTHAN     reduce using rule 126 (booleanOp -> TRUE .)
    RPAREN          reduce using rule 126 (booleanOp -> TRUE .)
    AND             reduce using rule 126 (booleanOp -> TRUE .)
    OR              reduce using rule 126 (booleanOp -> TRUE .)
    AMPERSAND       reduce using rule 126 (booleanOp -> TRUE .)
    PIPELINE        reduce using rule 126 (booleanOp -> TRUE .)
    COLON           reduce using rule 126 (booleanOp -> TRUE .)
    COMMA           reduce using rule 126 (booleanOp -> TRUE .)
    RCURLYBRACKET   reduce using rule 126 (booleanOp -> TRUE .)
    RSQUAREBRACKET  reduce using rule 126 (booleanOp -> TRUE .)


state 44

    (127) booleanOp -> FALSE .

    PLUS            reduce using rule 127 (booleanOp -> FALSE .)
    MINUS           reduce using rule 127 (booleanOp -> FALSE .)
    TIMES           reduce using rule 127 (booleanOp -> FALSE .)
    DIVISION        reduce using rule 127 (booleanOp -> FALSE .)
    SEMICOLON       reduce using rule 127 (booleanOp -> FALSE .)
    DOUBLEQUAL      reduce using rule 127 (booleanOp -> FALSE .)
    LESSTHAN        reduce using rule 127 (booleanOp -> FALSE .)
    GREATERTHAN     reduce using rule 127 (booleanOp -> FALSE .)
    RPAREN          reduce using rule 127 (booleanOp -> FALSE .)
    AND             reduce using rule 127 (booleanOp -> FALSE .)
    OR              reduce using rule 127 (booleanOp -> FALSE .)
    AMPERSAND       reduce using rule 127 (booleanOp -> FALSE .)
    PIPELINE        reduce using rule 127 (booleanOp -> FALSE .)
    COLON           reduce using rule 127 (booleanOp -> FALSE .)
    COMMA           reduce using rule 127 (booleanOp -> FALSE .)
    RCURLYBRACKET   reduce using rule 127 (booleanOp -> FALSE .)
    RSQUAREBRACKET  reduce using rule 127 (booleanOp -> FALSE .)


state 45

    (3) class -> class_content_repeat declarationMain .

    $end            reduce using rule 3 (class -> class_content_repeat declarationMain .)


state 46

    (15) class_content_repeat -> class_content_repeat class_content .

    STRING          reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    INT             reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    FOR             reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    WHILE           reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    FINAL           reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    IDENTIFIER      reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    BOOL            reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    LIST            reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    DOUBLE          reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    DYNAMIC         reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    VOID            reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    VAR             reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    MAP             reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    IF              reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    INTEGER         reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    FLOAT           reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    STR             reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    BOOLEAN         reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    TRUE            reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    FALSE           reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    MAIN            reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    $end            reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)
    RCURLYBRACKET   reduce using rule 15 (class_content_repeat -> class_content_repeat class_content .)


state 47

    (2) class -> declarationMain class_content_repeat .
    (15) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    $end            reduce using rule 2 (class -> declarationMain class_content_repeat .)
    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content                  shift and go to state 46
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 48

    (100) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (123) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (121) repeatDeclaration -> . IDENTIFIER
    (122) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 51

    repeatDeclaration              shift and go to state 52

state 49

    (16) declarationMain -> datatypeOpt MAIN . LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 75


state 50

    (13) class_content -> expression SEMICOLON .

    STRING          reduce using rule 13 (class_content -> expression SEMICOLON .)
    INT             reduce using rule 13 (class_content -> expression SEMICOLON .)
    FOR             reduce using rule 13 (class_content -> expression SEMICOLON .)
    WHILE           reduce using rule 13 (class_content -> expression SEMICOLON .)
    FINAL           reduce using rule 13 (class_content -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (class_content -> expression SEMICOLON .)
    BOOL            reduce using rule 13 (class_content -> expression SEMICOLON .)
    LIST            reduce using rule 13 (class_content -> expression SEMICOLON .)
    DOUBLE          reduce using rule 13 (class_content -> expression SEMICOLON .)
    DYNAMIC         reduce using rule 13 (class_content -> expression SEMICOLON .)
    VOID            reduce using rule 13 (class_content -> expression SEMICOLON .)
    VAR             reduce using rule 13 (class_content -> expression SEMICOLON .)
    MAP             reduce using rule 13 (class_content -> expression SEMICOLON .)
    IF              reduce using rule 13 (class_content -> expression SEMICOLON .)
    INTEGER         reduce using rule 13 (class_content -> expression SEMICOLON .)
    FLOAT           reduce using rule 13 (class_content -> expression SEMICOLON .)
    STR             reduce using rule 13 (class_content -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 13 (class_content -> expression SEMICOLON .)
    TRUE            reduce using rule 13 (class_content -> expression SEMICOLON .)
    FALSE           reduce using rule 13 (class_content -> expression SEMICOLON .)
    MAIN            reduce using rule 13 (class_content -> expression SEMICOLON .)
    $end            reduce using rule 13 (class_content -> expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 13 (class_content -> expression SEMICOLON .)


state 51

    (100) function_lambda -> datatype IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (123) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON
    (121) repeatDeclaration -> IDENTIFIER .
    (122) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    LPAREN          shift and go to state 76
    EQUAL           shift and go to state 77
    SEMICOLON       reduce using rule 121 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 78


state 52

    (120) declarationExpression -> datatype repeatDeclaration . SEMICOLON

    SEMICOLON       shift and go to state 79


state 53

    (22) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 80


state 54

    (61) inferedReturnFunction -> IDENTIFIER LPAREN . function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (103) function_arguments_repeat -> . function_argument
    (104) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (101) function_argument -> . datatype IDENTIFIER
    (102) function_argument -> . empty
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (41) empty -> .
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    COMMA           reduce using rule 41 (empty -> .)
    RPAREN          reduce using rule 41 (empty -> .)
    MAP             shift and go to state 36

    function_arguments_repeat      shift and go to state 81
    function_argument              shift and go to state 82
    datatype                       shift and go to state 83
    empty                          shift and go to state 84
    map_identifier                 shift and go to state 88

state 55

    (113) asign -> IDENTIFIER EQUAL . expression SEMICOLON
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 90
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 56

    (162) propertiesAccess -> IDENTIFIER DOT . properties
    (160) properties -> . KEYS
    (161) properties -> . VALUES

    KEYS            shift and go to state 92
    VALUES          shift and go to state 93

    properties                     shift and go to state 91

state 57

    (50) ifElseStatement -> ifStatement elifStatement_repeat .

    STRING          reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INT             reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FOR             reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    WHILE           reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FINAL           reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    LIST            reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VAR             reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IF              reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STR             reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    TRUE            reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FALSE           reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAIN            reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    $end            reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 50 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 58

    (51) elifStatement_repeat -> elifStatement .
    (52) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (51) elifStatement_repeat -> . elifStatement
    (52) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (54) elifStatement -> . ELSE ifStatement
    (55) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    STRING          reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    INT             reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    FOR             reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    WHILE           reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    FINAL           reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    IDENTIFIER      reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    LIST            reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    VAR             reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    IF              reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    INTEGER         reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    FLOAT           reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    STR             reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    BOOLEAN         reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    TRUE            reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    FALSE           reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    MAIN            reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    $end            reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    RCURLYBRACKET   reduce using rule 51 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 59

    elifStatement                  shift and go to state 58
    elifStatement_repeat           shift and go to state 94

state 59

    (54) elifStatement -> ELSE . ifStatement
    (55) elifStatement -> ELSE . LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 96
    IF              shift and go to state 37

    ifStatement                    shift and go to state 95

state 60

    (149) declarationExpression -> STRING IDENTIFIER . EQUAL expressionString SEMICOLON
    (150) declarationExpression -> STRING IDENTIFIER . SEMICOLON

    EQUAL           shift and go to state 97
    SEMICOLON       shift and go to state 98


state 61

    (154) declarationExpression -> INT IDENTIFIER . EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> INT IDENTIFIER . SEMICOLON

    EQUAL           shift and go to state 99
    SEMICOLON       shift and go to state 100


state 62

    (56) forStatement -> FOR LPAREN . declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified

    STRING          shift and go to state 23
    INT             shift and go to state 24
    BOOL            shift and go to state 87
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    MAP             shift and go to state 36

    declarationExpression          shift and go to state 101
    datatype                       shift and go to state 102
    map_identifier                 shift and go to state 88

state 63

    (58) while -> WHILE LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (94) conditions -> . condition
    (95) conditions -> . condition condition_connector conditions
    (88) condition -> . IDENTIFIER condition_operator condition_values
    (89) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (90) condition -> . BOOLEAN condition_operator BOOLEAN
    (91) condition -> . number condition_operator number
    (92) condition -> . STR condition_operator STR
    (93) condition -> . booleanOp condition_operator booleanOp
    (86) number -> . FLOAT
    (87) number -> . INTEGER
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 105
    EXMARK          shift and go to state 106
    BOOLEAN         shift and go to state 107
    STR             shift and go to state 109
    FLOAT           shift and go to state 111
    INTEGER         shift and go to state 112
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    conditions                     shift and go to state 103
    condition                      shift and go to state 104
    number                         shift and go to state 108
    booleanOp                      shift and go to state 110

state 64

    (57) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> FINAL IDENTIFIER . EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    EQUAL           shift and go to state 113


state 65

    (111) expression -> value operatorExpression . expression
    (112) expression -> value operatorExpression . operatorExpression
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (116) operatorExpression -> . PLUS
    (117) operatorExpression -> . MINUS
    (118) operatorExpression -> . TIMES
    (119) operatorExpression -> . DIVISION
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVISION        shift and go to state 69
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    value                          shift and go to state 28
    operatorExpression             shift and go to state 114
    expression                     shift and go to state 115
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 66

    (116) operatorExpression -> PLUS .

    PLUS            reduce using rule 116 (operatorExpression -> PLUS .)
    MINUS           reduce using rule 116 (operatorExpression -> PLUS .)
    TIMES           reduce using rule 116 (operatorExpression -> PLUS .)
    DIVISION        reduce using rule 116 (operatorExpression -> PLUS .)
    INTEGER         reduce using rule 116 (operatorExpression -> PLUS .)
    FLOAT           reduce using rule 116 (operatorExpression -> PLUS .)
    STR             reduce using rule 116 (operatorExpression -> PLUS .)
    BOOLEAN         reduce using rule 116 (operatorExpression -> PLUS .)
    IDENTIFIER      reduce using rule 116 (operatorExpression -> PLUS .)
    TRUE            reduce using rule 116 (operatorExpression -> PLUS .)
    FALSE           reduce using rule 116 (operatorExpression -> PLUS .)
    SEMICOLON       reduce using rule 116 (operatorExpression -> PLUS .)
    RPAREN          reduce using rule 116 (operatorExpression -> PLUS .)


state 67

    (117) operatorExpression -> MINUS .

    PLUS            reduce using rule 117 (operatorExpression -> MINUS .)
    MINUS           reduce using rule 117 (operatorExpression -> MINUS .)
    TIMES           reduce using rule 117 (operatorExpression -> MINUS .)
    DIVISION        reduce using rule 117 (operatorExpression -> MINUS .)
    INTEGER         reduce using rule 117 (operatorExpression -> MINUS .)
    FLOAT           reduce using rule 117 (operatorExpression -> MINUS .)
    STR             reduce using rule 117 (operatorExpression -> MINUS .)
    BOOLEAN         reduce using rule 117 (operatorExpression -> MINUS .)
    IDENTIFIER      reduce using rule 117 (operatorExpression -> MINUS .)
    TRUE            reduce using rule 117 (operatorExpression -> MINUS .)
    FALSE           reduce using rule 117 (operatorExpression -> MINUS .)
    SEMICOLON       reduce using rule 117 (operatorExpression -> MINUS .)
    RPAREN          reduce using rule 117 (operatorExpression -> MINUS .)


state 68

    (118) operatorExpression -> TIMES .

    PLUS            reduce using rule 118 (operatorExpression -> TIMES .)
    MINUS           reduce using rule 118 (operatorExpression -> TIMES .)
    TIMES           reduce using rule 118 (operatorExpression -> TIMES .)
    DIVISION        reduce using rule 118 (operatorExpression -> TIMES .)
    INTEGER         reduce using rule 118 (operatorExpression -> TIMES .)
    FLOAT           reduce using rule 118 (operatorExpression -> TIMES .)
    STR             reduce using rule 118 (operatorExpression -> TIMES .)
    BOOLEAN         reduce using rule 118 (operatorExpression -> TIMES .)
    IDENTIFIER      reduce using rule 118 (operatorExpression -> TIMES .)
    TRUE            reduce using rule 118 (operatorExpression -> TIMES .)
    FALSE           reduce using rule 118 (operatorExpression -> TIMES .)
    SEMICOLON       reduce using rule 118 (operatorExpression -> TIMES .)
    RPAREN          reduce using rule 118 (operatorExpression -> TIMES .)


state 69

    (119) operatorExpression -> DIVISION .

    PLUS            reduce using rule 119 (operatorExpression -> DIVISION .)
    MINUS           reduce using rule 119 (operatorExpression -> DIVISION .)
    TIMES           reduce using rule 119 (operatorExpression -> DIVISION .)
    DIVISION        reduce using rule 119 (operatorExpression -> DIVISION .)
    INTEGER         reduce using rule 119 (operatorExpression -> DIVISION .)
    FLOAT           reduce using rule 119 (operatorExpression -> DIVISION .)
    STR             reduce using rule 119 (operatorExpression -> DIVISION .)
    BOOLEAN         reduce using rule 119 (operatorExpression -> DIVISION .)
    IDENTIFIER      reduce using rule 119 (operatorExpression -> DIVISION .)
    TRUE            reduce using rule 119 (operatorExpression -> DIVISION .)
    FALSE           reduce using rule 119 (operatorExpression -> DIVISION .)
    SEMICOLON       reduce using rule 119 (operatorExpression -> DIVISION .)
    RPAREN          reduce using rule 119 (operatorExpression -> DIVISION .)


state 70

    (124) semanticbool -> BOOL IDENTIFIER . EQUAL booleanOp SEMICOLON
    (125) semanticbool -> BOOL IDENTIFIER . EQUAL booloperations SEMICOLON

    EQUAL           shift and go to state 116


state 71

    (134) semanticlist -> LIST LESSTHAN . DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> LIST LESSTHAN . INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> LIST LESSTHAN . STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> LIST LESSTHAN . BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> LIST LESSTHAN . DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    DYNAMIC         shift and go to state 117
    INT             shift and go to state 118
    STRING          shift and go to state 119
    BOOL            shift and go to state 120
    DOUBLE          shift and go to state 121


state 72

    (24) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 24 (map_identifier -> MAP map_type_specified .)
    MAIN            reduce using rule 24 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 24 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 24 (map_identifier -> MAP map_type_specified .)


state 73

    (25) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    MAP             shift and go to state 36

    datatype                       shift and go to state 122
    map_identifier                 shift and go to state 88

state 74

    (53) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (94) conditions -> . condition
    (95) conditions -> . condition condition_connector conditions
    (88) condition -> . IDENTIFIER condition_operator condition_values
    (89) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (90) condition -> . BOOLEAN condition_operator BOOLEAN
    (91) condition -> . number condition_operator number
    (92) condition -> . STR condition_operator STR
    (93) condition -> . booleanOp condition_operator booleanOp
    (86) number -> . FLOAT
    (87) number -> . INTEGER
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 105
    EXMARK          shift and go to state 106
    BOOLEAN         shift and go to state 107
    STR             shift and go to state 109
    FLOAT           shift and go to state 111
    INTEGER         shift and go to state 112
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    conditions                     shift and go to state 123
    condition                      shift and go to state 104
    number                         shift and go to state 108
    booleanOp                      shift and go to state 110

state 75

    (16) declarationMain -> datatypeOpt MAIN LPAREN . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 124


state 76

    (100) function_lambda -> datatype IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (103) function_arguments_repeat -> . function_argument
    (104) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (101) function_argument -> . datatype IDENTIFIER
    (102) function_argument -> . empty
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (41) empty -> .
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    COMMA           reduce using rule 41 (empty -> .)
    LCURLYBRACKET   reduce using rule 41 (empty -> .)
    RPAREN          reduce using rule 41 (empty -> .)
    MAP             shift and go to state 36

    datatype                       shift and go to state 83
    function_arguments_repeat      shift and go to state 125
    function_argument              shift and go to state 82
    empty                          shift and go to state 84
    map_identifier                 shift and go to state 88

state 77

    (123) declarationExpression -> datatype IDENTIFIER EQUAL . expression SEMICOLON
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 126
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 78

    (122) repeatDeclaration -> IDENTIFIER COMMA . repeatDeclaration
    (121) repeatDeclaration -> . IDENTIFIER
    (122) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 127

    repeatDeclaration              shift and go to state 128

state 79

    (120) declarationExpression -> datatype repeatDeclaration SEMICOLON .

    STRING          reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    INT             reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FOR             reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    WHILE           reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FINAL           reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    IDENTIFIER      reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    BOOL            reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    LIST            reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    DOUBLE          reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    DYNAMIC         reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    VOID            reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    VAR             reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    MAP             reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    IF              reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    INTEGER         reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FLOAT           reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    STR             reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    BOOLEAN         reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    TRUE            reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    FALSE           reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    MAIN            reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    $end            reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    SEMICOLON       reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)
    RCURLYBRACKET   reduce using rule 120 (declarationExpression -> datatype repeatDeclaration SEMICOLON .)


state 80

    (22) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 129


state 81

    (61) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat . RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    RPAREN          shift and go to state 130


state 82

    (103) function_arguments_repeat -> function_argument .
    (104) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    RPAREN          reduce using rule 103 (function_arguments_repeat -> function_argument .)
    LCURLYBRACKET   reduce using rule 103 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 131


state 83

    (101) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 132


state 84

    (102) function_argument -> empty .

    COMMA           reduce using rule 102 (function_argument -> empty .)
    RPAREN          reduce using rule 102 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 102 (function_argument -> empty .)


state 85

    (26) datatype -> INT .

    IDENTIFIER      reduce using rule 26 (datatype -> INT .)
    COMMA           reduce using rule 26 (datatype -> INT .)
    GREATERTHAN     reduce using rule 26 (datatype -> INT .)


state 86

    (27) datatype -> STRING .

    IDENTIFIER      reduce using rule 27 (datatype -> STRING .)
    COMMA           reduce using rule 27 (datatype -> STRING .)
    GREATERTHAN     reduce using rule 27 (datatype -> STRING .)


state 87

    (28) datatype -> BOOL .

    IDENTIFIER      reduce using rule 28 (datatype -> BOOL .)
    COMMA           reduce using rule 28 (datatype -> BOOL .)
    GREATERTHAN     reduce using rule 28 (datatype -> BOOL .)


state 88

    (32) datatype -> map_identifier .

    IDENTIFIER      reduce using rule 32 (datatype -> map_identifier .)
    COMMA           reduce using rule 32 (datatype -> map_identifier .)
    GREATERTHAN     reduce using rule 32 (datatype -> map_identifier .)


state 89

    (66) value -> IDENTIFIER .
    (162) propertiesAccess -> IDENTIFIER . DOT properties

    PLUS            reduce using rule 66 (value -> IDENTIFIER .)
    MINUS           reduce using rule 66 (value -> IDENTIFIER .)
    TIMES           reduce using rule 66 (value -> IDENTIFIER .)
    DIVISION        reduce using rule 66 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 66 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 66 (value -> IDENTIFIER .)
    COLON           reduce using rule 66 (value -> IDENTIFIER .)
    COMMA           reduce using rule 66 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 66 (value -> IDENTIFIER .)
    RSQUAREBRACKET  reduce using rule 66 (value -> IDENTIFIER .)
    DOT             shift and go to state 56


state 90

    (113) asign -> IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 133


state 91

    (162) propertiesAccess -> IDENTIFIER DOT properties .

    PLUS            reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    MINUS           reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    TIMES           reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    DIVISION        reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    SEMICOLON       reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    RPAREN          reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    COLON           reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    COMMA           reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    RCURLYBRACKET   reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)
    RSQUAREBRACKET  reduce using rule 162 (propertiesAccess -> IDENTIFIER DOT properties .)


state 92

    (160) properties -> KEYS .

    PLUS            reduce using rule 160 (properties -> KEYS .)
    MINUS           reduce using rule 160 (properties -> KEYS .)
    TIMES           reduce using rule 160 (properties -> KEYS .)
    DIVISION        reduce using rule 160 (properties -> KEYS .)
    SEMICOLON       reduce using rule 160 (properties -> KEYS .)
    RPAREN          reduce using rule 160 (properties -> KEYS .)
    COLON           reduce using rule 160 (properties -> KEYS .)
    COMMA           reduce using rule 160 (properties -> KEYS .)
    RCURLYBRACKET   reduce using rule 160 (properties -> KEYS .)
    RSQUAREBRACKET  reduce using rule 160 (properties -> KEYS .)


state 93

    (161) properties -> VALUES .

    PLUS            reduce using rule 161 (properties -> VALUES .)
    MINUS           reduce using rule 161 (properties -> VALUES .)
    TIMES           reduce using rule 161 (properties -> VALUES .)
    DIVISION        reduce using rule 161 (properties -> VALUES .)
    SEMICOLON       reduce using rule 161 (properties -> VALUES .)
    RPAREN          reduce using rule 161 (properties -> VALUES .)
    COLON           reduce using rule 161 (properties -> VALUES .)
    COMMA           reduce using rule 161 (properties -> VALUES .)
    RCURLYBRACKET   reduce using rule 161 (properties -> VALUES .)
    RSQUAREBRACKET  reduce using rule 161 (properties -> VALUES .)


state 94

    (52) elifStatement_repeat -> elifStatement elifStatement_repeat .

    STRING          reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INT             reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FOR             reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    WHILE           reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FINAL           reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    LIST            reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VAR             reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IF              reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STR             reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    TRUE            reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FALSE           reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAIN            reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    $end            reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 52 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 95

    (54) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    FOR             reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    WHILE           reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    FINAL           reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    IDENTIFIER      reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    LIST            reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    VAR             reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    IF              reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    INTEGER         reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    FLOAT           reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    STR             reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    BOOLEAN         reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    TRUE            reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    FALSE           reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    MAIN            reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    $end            reduce using rule 54 (elifStatement -> ELSE ifStatement .)
    RCURLYBRACKET   reduce using rule 54 (elifStatement -> ELSE ifStatement .)


state 96

    (55) elifStatement -> ELSE LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (14) class_content_repeat -> . class_content
    (15) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content_repeat           shift and go to state 134
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 97

    (149) declarationExpression -> STRING IDENTIFIER EQUAL . expressionString SEMICOLON
    (151) expressionString -> . STR
    (152) expressionString -> . STR operatorExpressionString expressionString

    STR             shift and go to state 136

    expressionString               shift and go to state 135

state 98

    (150) declarationExpression -> STRING IDENTIFIER SEMICOLON .

    STRING          reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    INT             reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FINAL           reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    IF              reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    STR             reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    MAIN            reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    $end            reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 150 (declarationExpression -> STRING IDENTIFIER SEMICOLON .)


state 99

    (154) declarationExpression -> INT IDENTIFIER EQUAL . expressionInteger SEMICOLON
    (156) expressionInteger -> . number
    (157) expressionInteger -> . number operatorExpression expressionInteger
    (158) expressionInteger -> . IDENTIFIER
    (159) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (86) number -> . FLOAT
    (87) number -> . INTEGER

    IDENTIFIER      shift and go to state 137
    FLOAT           shift and go to state 111
    INTEGER         shift and go to state 112

    expressionInteger              shift and go to state 138
    number                         shift and go to state 139

state 100

    (155) declarationExpression -> INT IDENTIFIER SEMICOLON .

    STRING          reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    INT             reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FINAL           reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    IF              reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    STR             reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    MAIN            reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    $end            reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 155 (declarationExpression -> INT IDENTIFIER SEMICOLON .)


state 101

    (56) forStatement -> FOR LPAREN declarationExpression . SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 140


state 102

    (120) declarationExpression -> datatype . repeatDeclaration SEMICOLON
    (123) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON
    (121) repeatDeclaration -> . IDENTIFIER
    (122) repeatDeclaration -> . IDENTIFIER COMMA repeatDeclaration

    IDENTIFIER      shift and go to state 141

    repeatDeclaration              shift and go to state 52

state 103

    (58) while -> WHILE LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 142


state 104

    (94) conditions -> condition .
    (95) conditions -> condition . condition_connector conditions
    (96) condition_connector -> . AND
    (97) condition_connector -> . OR
    (98) condition_connector -> . AMPERSAND AMPERSAND
    (99) condition_connector -> . PIPELINE PIPELINE

    RPAREN          reduce using rule 94 (conditions -> condition .)
    AND             shift and go to state 144
    OR              shift and go to state 145
    AMPERSAND       shift and go to state 146
    PIPELINE        shift and go to state 147

    condition_connector            shift and go to state 143

state 105

    (88) condition -> IDENTIFIER . condition_operator condition_values
    (81) condition_operator -> . DOUBLEQUAL
    (82) condition_operator -> . LESSTHAN
    (83) condition_operator -> . GREATERTHAN
    (84) condition_operator -> . LESSTHAN EQUAL
    (85) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 149
    LESSTHAN        shift and go to state 150
    GREATERTHAN     shift and go to state 151

    condition_operator             shift and go to state 148

state 106

    (89) condition -> EXMARK . IDENTIFIER condition_operator condition_values

    IDENTIFIER      shift and go to state 152


state 107

    (90) condition -> BOOLEAN . condition_operator BOOLEAN
    (81) condition_operator -> . DOUBLEQUAL
    (82) condition_operator -> . LESSTHAN
    (83) condition_operator -> . GREATERTHAN
    (84) condition_operator -> . LESSTHAN EQUAL
    (85) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 149
    LESSTHAN        shift and go to state 150
    GREATERTHAN     shift and go to state 151

    condition_operator             shift and go to state 153

state 108

    (91) condition -> number . condition_operator number
    (81) condition_operator -> . DOUBLEQUAL
    (82) condition_operator -> . LESSTHAN
    (83) condition_operator -> . GREATERTHAN
    (84) condition_operator -> . LESSTHAN EQUAL
    (85) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 149
    LESSTHAN        shift and go to state 150
    GREATERTHAN     shift and go to state 151

    condition_operator             shift and go to state 154

state 109

    (92) condition -> STR . condition_operator STR
    (81) condition_operator -> . DOUBLEQUAL
    (82) condition_operator -> . LESSTHAN
    (83) condition_operator -> . GREATERTHAN
    (84) condition_operator -> . LESSTHAN EQUAL
    (85) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 149
    LESSTHAN        shift and go to state 150
    GREATERTHAN     shift and go to state 151

    condition_operator             shift and go to state 155

state 110

    (93) condition -> booleanOp . condition_operator booleanOp
    (81) condition_operator -> . DOUBLEQUAL
    (82) condition_operator -> . LESSTHAN
    (83) condition_operator -> . GREATERTHAN
    (84) condition_operator -> . LESSTHAN EQUAL
    (85) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 149
    LESSTHAN        shift and go to state 150
    GREATERTHAN     shift and go to state 151

    condition_operator             shift and go to state 156

state 111

    (86) number -> FLOAT .

    DOUBLEQUAL      reduce using rule 86 (number -> FLOAT .)
    LESSTHAN        reduce using rule 86 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 86 (number -> FLOAT .)
    PLUS            reduce using rule 86 (number -> FLOAT .)
    MINUS           reduce using rule 86 (number -> FLOAT .)
    TIMES           reduce using rule 86 (number -> FLOAT .)
    DIVISION        reduce using rule 86 (number -> FLOAT .)
    SEMICOLON       reduce using rule 86 (number -> FLOAT .)
    AND             reduce using rule 86 (number -> FLOAT .)
    OR              reduce using rule 86 (number -> FLOAT .)
    AMPERSAND       reduce using rule 86 (number -> FLOAT .)
    PIPELINE        reduce using rule 86 (number -> FLOAT .)
    RPAREN          reduce using rule 86 (number -> FLOAT .)


state 112

    (87) number -> INTEGER .

    DOUBLEQUAL      reduce using rule 87 (number -> INTEGER .)
    LESSTHAN        reduce using rule 87 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 87 (number -> INTEGER .)
    PLUS            reduce using rule 87 (number -> INTEGER .)
    MINUS           reduce using rule 87 (number -> INTEGER .)
    TIMES           reduce using rule 87 (number -> INTEGER .)
    DIVISION        reduce using rule 87 (number -> INTEGER .)
    SEMICOLON       reduce using rule 87 (number -> INTEGER .)
    AND             reduce using rule 87 (number -> INTEGER .)
    OR              reduce using rule 87 (number -> INTEGER .)
    AMPERSAND       reduce using rule 87 (number -> INTEGER .)
    PIPELINE        reduce using rule 87 (number -> INTEGER .)
    RPAREN          reduce using rule 87 (number -> INTEGER .)


state 113

    (57) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> FINAL IDENTIFIER EQUAL . STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    STACK           shift and go to state 157


state 114

    (112) expression -> value operatorExpression operatorExpression .

    SEMICOLON       reduce using rule 112 (expression -> value operatorExpression operatorExpression .)
    RPAREN          reduce using rule 112 (expression -> value operatorExpression operatorExpression .)


state 115

    (111) expression -> value operatorExpression expression .

    SEMICOLON       reduce using rule 111 (expression -> value operatorExpression expression .)
    RPAREN          reduce using rule 111 (expression -> value operatorExpression expression .)


state 116

    (124) semanticbool -> BOOL IDENTIFIER EQUAL . booleanOp SEMICOLON
    (125) semanticbool -> BOOL IDENTIFIER EQUAL . booloperations SEMICOLON
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (132) booloperations -> . booloperation
    (133) booloperations -> . booloperation condition_connector booloperations
    (128) booloperation -> . booleanOp condition_connector booleanOp
    (129) booloperation -> . IDENTIFIER condition_connector booleanOp
    (130) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (131) booloperation -> . booleanOp condition_connector IDENTIFIER

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 158

    booleanOp                      shift and go to state 159
    booloperations                 shift and go to state 160
    booloperation                  shift and go to state 161

state 117

    (134) semanticlist -> LIST LESSTHAN DYNAMIC . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 162


state 118

    (135) semanticlist -> LIST LESSTHAN INT . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 163


state 119

    (136) semanticlist -> LIST LESSTHAN STRING . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 164


state 120

    (137) semanticlist -> LIST LESSTHAN BOOL . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 165


state 121

    (138) semanticlist -> LIST LESSTHAN DOUBLE . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 166


state 122

    (25) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 167


state 123

    (53) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 168


state 124

    (16) declarationMain -> datatypeOpt MAIN LPAREN RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 169


state 125

    (100) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (105) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (106) optFunction_argumentsExpression -> . empty
    (41) empty -> .

    LCURLYBRACKET   shift and go to state 171
    RPAREN          reduce using rule 41 (empty -> .)

    optFunction_argumentsExpression shift and go to state 170
    empty                          shift and go to state 172

state 126

    (123) declarationExpression -> datatype IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 173


state 127

    (121) repeatDeclaration -> IDENTIFIER .
    (122) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    SEMICOLON       reduce using rule 121 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 78


state 128

    (122) repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration .

    SEMICOLON       reduce using rule 122 (repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration .)


state 129

    (22) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (42) map_content -> . map_pairs
    (43) map_content -> . empty
    (45) map_pairs -> . map_pair
    (46) map_pairs -> . map_pair COMMA map_pairs
    (41) empty -> .
    (44) map_pair -> . map_key COLON map_value
    (47) map_key -> . value
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   reduce using rule 41 (empty -> .)
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    map_content                    shift and go to state 174
    map_pairs                      shift and go to state 175
    empty                          shift and go to state 176
    map_pair                       shift and go to state 177
    map_key                        shift and go to state 178
    value                          shift and go to state 179
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 130

    (61) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN . LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 180


state 131

    (104) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (103) function_arguments_repeat -> . function_argument
    (104) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (101) function_argument -> . datatype IDENTIFIER
    (102) function_argument -> . empty
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (41) empty -> .
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    COMMA           reduce using rule 41 (empty -> .)
    RPAREN          reduce using rule 41 (empty -> .)
    LCURLYBRACKET   reduce using rule 41 (empty -> .)
    MAP             shift and go to state 36

    function_argument              shift and go to state 82
    function_arguments_repeat      shift and go to state 181
    datatype                       shift and go to state 83
    empty                          shift and go to state 84
    map_identifier                 shift and go to state 88

state 132

    (101) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 101 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 101 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 101 (function_argument -> datatype IDENTIFIER .)


state 133

    (113) asign -> IDENTIFIER EQUAL expression SEMICOLON .

    STRING          reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 113 (asign -> IDENTIFIER EQUAL expression SEMICOLON .)


state 134

    (55) elifStatement -> ELSE LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (15) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   shift and go to state 182
    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content                  shift and go to state 46
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 135

    (149) declarationExpression -> STRING IDENTIFIER EQUAL expressionString . SEMICOLON

    SEMICOLON       shift and go to state 183


state 136

    (151) expressionString -> STR .
    (152) expressionString -> STR . operatorExpressionString expressionString
    (153) operatorExpressionString -> . PLUS

    SEMICOLON       reduce using rule 151 (expressionString -> STR .)
    PLUS            shift and go to state 185

    operatorExpressionString       shift and go to state 184

state 137

    (158) expressionInteger -> IDENTIFIER .
    (159) expressionInteger -> IDENTIFIER . operatorExpression expressionInteger
    (116) operatorExpression -> . PLUS
    (117) operatorExpression -> . MINUS
    (118) operatorExpression -> . TIMES
    (119) operatorExpression -> . DIVISION

    SEMICOLON       reduce using rule 158 (expressionInteger -> IDENTIFIER .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVISION        shift and go to state 69

    operatorExpression             shift and go to state 186

state 138

    (154) declarationExpression -> INT IDENTIFIER EQUAL expressionInteger . SEMICOLON

    SEMICOLON       shift and go to state 187


state 139

    (156) expressionInteger -> number .
    (157) expressionInteger -> number . operatorExpression expressionInteger
    (116) operatorExpression -> . PLUS
    (117) operatorExpression -> . MINUS
    (118) operatorExpression -> . TIMES
    (119) operatorExpression -> . DIVISION

    SEMICOLON       reduce using rule 156 (expressionInteger -> number .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVISION        shift and go to state 69

    operatorExpression             shift and go to state 188

state 140

    (56) forStatement -> FOR LPAREN declarationExpression SEMICOLON . condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (88) condition -> . IDENTIFIER condition_operator condition_values
    (89) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (90) condition -> . BOOLEAN condition_operator BOOLEAN
    (91) condition -> . number condition_operator number
    (92) condition -> . STR condition_operator STR
    (93) condition -> . booleanOp condition_operator booleanOp
    (86) number -> . FLOAT
    (87) number -> . INTEGER
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 105
    EXMARK          shift and go to state 106
    BOOLEAN         shift and go to state 107
    STR             shift and go to state 109
    FLOAT           shift and go to state 111
    INTEGER         shift and go to state 112
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    condition                      shift and go to state 189
    number                         shift and go to state 108
    booleanOp                      shift and go to state 110

state 141

    (123) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON
    (121) repeatDeclaration -> IDENTIFIER .
    (122) repeatDeclaration -> IDENTIFIER . COMMA repeatDeclaration

    EQUAL           shift and go to state 77
    SEMICOLON       reduce using rule 121 (repeatDeclaration -> IDENTIFIER .)
    COMMA           shift and go to state 78


state 142

    (58) while -> WHILE LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 190


state 143

    (95) conditions -> condition condition_connector . conditions
    (94) conditions -> . condition
    (95) conditions -> . condition condition_connector conditions
    (88) condition -> . IDENTIFIER condition_operator condition_values
    (89) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (90) condition -> . BOOLEAN condition_operator BOOLEAN
    (91) condition -> . number condition_operator number
    (92) condition -> . STR condition_operator STR
    (93) condition -> . booleanOp condition_operator booleanOp
    (86) number -> . FLOAT
    (87) number -> . INTEGER
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 105
    EXMARK          shift and go to state 106
    BOOLEAN         shift and go to state 107
    STR             shift and go to state 109
    FLOAT           shift and go to state 111
    INTEGER         shift and go to state 112
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    condition                      shift and go to state 104
    conditions                     shift and go to state 191
    number                         shift and go to state 108
    booleanOp                      shift and go to state 110

state 144

    (96) condition_connector -> AND .

    IDENTIFIER      reduce using rule 96 (condition_connector -> AND .)
    EXMARK          reduce using rule 96 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 96 (condition_connector -> AND .)
    STR             reduce using rule 96 (condition_connector -> AND .)
    FLOAT           reduce using rule 96 (condition_connector -> AND .)
    INTEGER         reduce using rule 96 (condition_connector -> AND .)
    TRUE            reduce using rule 96 (condition_connector -> AND .)
    FALSE           reduce using rule 96 (condition_connector -> AND .)


state 145

    (97) condition_connector -> OR .

    IDENTIFIER      reduce using rule 97 (condition_connector -> OR .)
    EXMARK          reduce using rule 97 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 97 (condition_connector -> OR .)
    STR             reduce using rule 97 (condition_connector -> OR .)
    FLOAT           reduce using rule 97 (condition_connector -> OR .)
    INTEGER         reduce using rule 97 (condition_connector -> OR .)
    TRUE            reduce using rule 97 (condition_connector -> OR .)
    FALSE           reduce using rule 97 (condition_connector -> OR .)


state 146

    (98) condition_connector -> AMPERSAND . AMPERSAND

    AMPERSAND       shift and go to state 192


state 147

    (99) condition_connector -> PIPELINE . PIPELINE

    PIPELINE        shift and go to state 193


state 148

    (88) condition -> IDENTIFIER condition_operator . condition_values
    (76) condition_values -> . negation_values
    (77) condition_values -> . INTEGER
    (78) condition_values -> . FLOAT
    (79) condition_values -> . STR
    (80) condition_values -> . NULL
    (74) negation_values -> . deniable_values
    (75) negation_values -> . EXMARK deniable_values
    (71) deniable_values -> . IDENTIFIER
    (72) deniable_values -> . BOOLEAN
    (73) deniable_values -> . booleanOp
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    INTEGER         shift and go to state 197
    FLOAT           shift and go to state 198
    STR             shift and go to state 199
    NULL            shift and go to state 200
    EXMARK          shift and go to state 202
    IDENTIFIER      shift and go to state 194
    BOOLEAN         shift and go to state 203
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    condition_values               shift and go to state 195
    negation_values                shift and go to state 196
    deniable_values                shift and go to state 201
    booleanOp                      shift and go to state 204

state 149

    (81) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 81 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 81 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 81 (condition_operator -> DOUBLEQUAL .)
    NULL            reduce using rule 81 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 81 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 81 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 81 (condition_operator -> DOUBLEQUAL .)
    TRUE            reduce using rule 81 (condition_operator -> DOUBLEQUAL .)
    FALSE           reduce using rule 81 (condition_operator -> DOUBLEQUAL .)


state 150

    (82) condition_operator -> LESSTHAN .
    (84) condition_operator -> LESSTHAN . EQUAL

    INTEGER         reduce using rule 82 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 82 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 82 (condition_operator -> LESSTHAN .)
    NULL            reduce using rule 82 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 82 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 82 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 82 (condition_operator -> LESSTHAN .)
    TRUE            reduce using rule 82 (condition_operator -> LESSTHAN .)
    FALSE           reduce using rule 82 (condition_operator -> LESSTHAN .)
    EQUAL           shift and go to state 205


state 151

    (83) condition_operator -> GREATERTHAN .
    (85) condition_operator -> GREATERTHAN . EQUAL

    INTEGER         reduce using rule 83 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 83 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 83 (condition_operator -> GREATERTHAN .)
    NULL            reduce using rule 83 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 83 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 83 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 83 (condition_operator -> GREATERTHAN .)
    TRUE            reduce using rule 83 (condition_operator -> GREATERTHAN .)
    FALSE           reduce using rule 83 (condition_operator -> GREATERTHAN .)
    EQUAL           shift and go to state 206


state 152

    (89) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (81) condition_operator -> . DOUBLEQUAL
    (82) condition_operator -> . LESSTHAN
    (83) condition_operator -> . GREATERTHAN
    (84) condition_operator -> . LESSTHAN EQUAL
    (85) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 149
    LESSTHAN        shift and go to state 150
    GREATERTHAN     shift and go to state 151

    condition_operator             shift and go to state 207

state 153

    (90) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 208


state 154

    (91) condition -> number condition_operator . number
    (86) number -> . FLOAT
    (87) number -> . INTEGER

    FLOAT           shift and go to state 111
    INTEGER         shift and go to state 112

    number                         shift and go to state 209

state 155

    (92) condition -> STR condition_operator . STR

    STR             shift and go to state 210


state 156

    (93) condition -> booleanOp condition_operator . booleanOp
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    booleanOp                      shift and go to state 211

state 157

    (57) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> FINAL IDENTIFIER EQUAL STACK . DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    LESSTHAN        shift and go to state 212
    DOT             shift and go to state 213


state 158

    (129) booloperation -> IDENTIFIER . condition_connector booleanOp
    (130) booloperation -> IDENTIFIER . condition_connector IDENTIFIER
    (96) condition_connector -> . AND
    (97) condition_connector -> . OR
    (98) condition_connector -> . AMPERSAND AMPERSAND
    (99) condition_connector -> . PIPELINE PIPELINE

    AND             shift and go to state 144
    OR              shift and go to state 145
    AMPERSAND       shift and go to state 146
    PIPELINE        shift and go to state 147

    condition_connector            shift and go to state 214

state 159

    (124) semanticbool -> BOOL IDENTIFIER EQUAL booleanOp . SEMICOLON
    (128) booloperation -> booleanOp . condition_connector booleanOp
    (131) booloperation -> booleanOp . condition_connector IDENTIFIER
    (96) condition_connector -> . AND
    (97) condition_connector -> . OR
    (98) condition_connector -> . AMPERSAND AMPERSAND
    (99) condition_connector -> . PIPELINE PIPELINE

    SEMICOLON       shift and go to state 215
    AND             shift and go to state 144
    OR              shift and go to state 145
    AMPERSAND       shift and go to state 146
    PIPELINE        shift and go to state 147

    condition_connector            shift and go to state 216

state 160

    (125) semanticbool -> BOOL IDENTIFIER EQUAL booloperations . SEMICOLON

    SEMICOLON       shift and go to state 217


state 161

    (132) booloperations -> booloperation .
    (133) booloperations -> booloperation . condition_connector booloperations
    (96) condition_connector -> . AND
    (97) condition_connector -> . OR
    (98) condition_connector -> . AMPERSAND AMPERSAND
    (99) condition_connector -> . PIPELINE PIPELINE

    SEMICOLON       reduce using rule 132 (booloperations -> booloperation .)
    AND             shift and go to state 144
    OR              shift and go to state 145
    AMPERSAND       shift and go to state 146
    PIPELINE        shift and go to state 147

    condition_connector            shift and go to state 218

state 162

    (134) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 219


state 163

    (135) semanticlist -> LIST LESSTHAN INT GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 220


state 164

    (136) semanticlist -> LIST LESSTHAN STRING GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 221


state 165

    (137) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 222


state 166

    (138) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 223


state 167

    (25) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    MAP             shift and go to state 36

    datatype                       shift and go to state 224
    map_identifier                 shift and go to state 88

state 168

    (53) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 225


state 169

    (16) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (14) class_content_repeat -> . class_content
    (15) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content_repeat           shift and go to state 226
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 170

    (100) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 227


state 171

    (105) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (108) optFunction_arguments -> . optFunction_argument
    (109) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (107) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 230

    optFunction_arguments          shift and go to state 228
    optFunction_argument           shift and go to state 229

state 172

    (106) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 106 (optFunction_argumentsExpression -> empty .)


state 173

    (123) declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .

    STRING          reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAIN            reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 123 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)


state 174

    (22) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 231


state 175

    (42) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 42 (map_content -> map_pairs .)


state 176

    (43) map_content -> empty .

    RCURLYBRACKET   reduce using rule 43 (map_content -> empty .)


state 177

    (45) map_pairs -> map_pair .
    (46) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 45 (map_pairs -> map_pair .)
    COMMA           shift and go to state 232


state 178

    (44) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 233


state 179

    (47) map_key -> value .

    COLON           reduce using rule 47 (map_key -> value .)


state 180

    (61) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET . RETURN expression SEMICOLON RCURLYBRACKET

    RETURN          shift and go to state 234


state 181

    (104) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    RPAREN          reduce using rule 104 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    LCURLYBRACKET   reduce using rule 104 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 182

    (55) elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 55 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 183

    (149) declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .

    STRING          reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    INT             reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FOR             reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    WHILE           reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FINAL           reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    IDENTIFIER      reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    BOOL            reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    LIST            reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    DOUBLE          reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    DYNAMIC         reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    VOID            reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    VAR             reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    MAP             reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    IF              reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    INTEGER         reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FLOAT           reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    STR             reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    BOOLEAN         reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    TRUE            reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FALSE           reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    MAIN            reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    $end            reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    SEMICOLON       reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    RCURLYBRACKET   reduce using rule 149 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)


state 184

    (152) expressionString -> STR operatorExpressionString . expressionString
    (151) expressionString -> . STR
    (152) expressionString -> . STR operatorExpressionString expressionString

    STR             shift and go to state 136

    expressionString               shift and go to state 235

state 185

    (153) operatorExpressionString -> PLUS .

    STR             reduce using rule 153 (operatorExpressionString -> PLUS .)


state 186

    (159) expressionInteger -> IDENTIFIER operatorExpression . expressionInteger
    (156) expressionInteger -> . number
    (157) expressionInteger -> . number operatorExpression expressionInteger
    (158) expressionInteger -> . IDENTIFIER
    (159) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (86) number -> . FLOAT
    (87) number -> . INTEGER

    IDENTIFIER      shift and go to state 137
    FLOAT           shift and go to state 111
    INTEGER         shift and go to state 112

    expressionInteger              shift and go to state 236
    number                         shift and go to state 139

state 187

    (154) declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .

    STRING          reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    INT             reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FOR             reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    WHILE           reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FINAL           reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    IDENTIFIER      reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    BOOL            reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    LIST            reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    DOUBLE          reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    DYNAMIC         reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    VOID            reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    VAR             reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    MAP             reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    IF              reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    INTEGER         reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FLOAT           reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    STR             reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    BOOLEAN         reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    TRUE            reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FALSE           reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    MAIN            reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    $end            reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    SEMICOLON       reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    RCURLYBRACKET   reduce using rule 154 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)


state 188

    (157) expressionInteger -> number operatorExpression . expressionInteger
    (156) expressionInteger -> . number
    (157) expressionInteger -> . number operatorExpression expressionInteger
    (158) expressionInteger -> . IDENTIFIER
    (159) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (86) number -> . FLOAT
    (87) number -> . INTEGER

    IDENTIFIER      shift and go to state 137
    FLOAT           shift and go to state 111
    INTEGER         shift and go to state 112

    number                         shift and go to state 139
    expressionInteger              shift and go to state 237

state 189

    (56) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition . SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 238


state 190

    (58) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (14) class_content_repeat -> . class_content
    (15) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content_repeat           shift and go to state 239
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 191

    (95) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 95 (conditions -> condition condition_connector conditions .)


state 192

    (98) condition_connector -> AMPERSAND AMPERSAND .

    IDENTIFIER      reduce using rule 98 (condition_connector -> AMPERSAND AMPERSAND .)
    EXMARK          reduce using rule 98 (condition_connector -> AMPERSAND AMPERSAND .)
    BOOLEAN         reduce using rule 98 (condition_connector -> AMPERSAND AMPERSAND .)
    STR             reduce using rule 98 (condition_connector -> AMPERSAND AMPERSAND .)
    FLOAT           reduce using rule 98 (condition_connector -> AMPERSAND AMPERSAND .)
    INTEGER         reduce using rule 98 (condition_connector -> AMPERSAND AMPERSAND .)
    TRUE            reduce using rule 98 (condition_connector -> AMPERSAND AMPERSAND .)
    FALSE           reduce using rule 98 (condition_connector -> AMPERSAND AMPERSAND .)


state 193

    (99) condition_connector -> PIPELINE PIPELINE .

    IDENTIFIER      reduce using rule 99 (condition_connector -> PIPELINE PIPELINE .)
    EXMARK          reduce using rule 99 (condition_connector -> PIPELINE PIPELINE .)
    BOOLEAN         reduce using rule 99 (condition_connector -> PIPELINE PIPELINE .)
    STR             reduce using rule 99 (condition_connector -> PIPELINE PIPELINE .)
    FLOAT           reduce using rule 99 (condition_connector -> PIPELINE PIPELINE .)
    INTEGER         reduce using rule 99 (condition_connector -> PIPELINE PIPELINE .)
    TRUE            reduce using rule 99 (condition_connector -> PIPELINE PIPELINE .)
    FALSE           reduce using rule 99 (condition_connector -> PIPELINE PIPELINE .)


state 194

    (71) deniable_values -> IDENTIFIER .

    AND             reduce using rule 71 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 71 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 71 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 71 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 71 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 71 (deniable_values -> IDENTIFIER .)


state 195

    (88) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 88 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 88 (condition -> IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 88 (condition -> IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 88 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 88 (condition -> IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 88 (condition -> IDENTIFIER condition_operator condition_values .)


state 196

    (76) condition_values -> negation_values .

    AND             reduce using rule 76 (condition_values -> negation_values .)
    OR              reduce using rule 76 (condition_values -> negation_values .)
    AMPERSAND       reduce using rule 76 (condition_values -> negation_values .)
    PIPELINE        reduce using rule 76 (condition_values -> negation_values .)
    RPAREN          reduce using rule 76 (condition_values -> negation_values .)
    SEMICOLON       reduce using rule 76 (condition_values -> negation_values .)


state 197

    (77) condition_values -> INTEGER .

    AND             reduce using rule 77 (condition_values -> INTEGER .)
    OR              reduce using rule 77 (condition_values -> INTEGER .)
    AMPERSAND       reduce using rule 77 (condition_values -> INTEGER .)
    PIPELINE        reduce using rule 77 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 77 (condition_values -> INTEGER .)
    SEMICOLON       reduce using rule 77 (condition_values -> INTEGER .)


state 198

    (78) condition_values -> FLOAT .

    AND             reduce using rule 78 (condition_values -> FLOAT .)
    OR              reduce using rule 78 (condition_values -> FLOAT .)
    AMPERSAND       reduce using rule 78 (condition_values -> FLOAT .)
    PIPELINE        reduce using rule 78 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 78 (condition_values -> FLOAT .)
    SEMICOLON       reduce using rule 78 (condition_values -> FLOAT .)


state 199

    (79) condition_values -> STR .

    AND             reduce using rule 79 (condition_values -> STR .)
    OR              reduce using rule 79 (condition_values -> STR .)
    AMPERSAND       reduce using rule 79 (condition_values -> STR .)
    PIPELINE        reduce using rule 79 (condition_values -> STR .)
    RPAREN          reduce using rule 79 (condition_values -> STR .)
    SEMICOLON       reduce using rule 79 (condition_values -> STR .)


state 200

    (80) condition_values -> NULL .

    AND             reduce using rule 80 (condition_values -> NULL .)
    OR              reduce using rule 80 (condition_values -> NULL .)
    AMPERSAND       reduce using rule 80 (condition_values -> NULL .)
    PIPELINE        reduce using rule 80 (condition_values -> NULL .)
    RPAREN          reduce using rule 80 (condition_values -> NULL .)
    SEMICOLON       reduce using rule 80 (condition_values -> NULL .)


state 201

    (74) negation_values -> deniable_values .

    AND             reduce using rule 74 (negation_values -> deniable_values .)
    OR              reduce using rule 74 (negation_values -> deniable_values .)
    AMPERSAND       reduce using rule 74 (negation_values -> deniable_values .)
    PIPELINE        reduce using rule 74 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 74 (negation_values -> deniable_values .)
    SEMICOLON       reduce using rule 74 (negation_values -> deniable_values .)


state 202

    (75) negation_values -> EXMARK . deniable_values
    (71) deniable_values -> . IDENTIFIER
    (72) deniable_values -> . BOOLEAN
    (73) deniable_values -> . booleanOp
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 194
    BOOLEAN         shift and go to state 203
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    deniable_values                shift and go to state 240
    booleanOp                      shift and go to state 204

state 203

    (72) deniable_values -> BOOLEAN .

    AND             reduce using rule 72 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 72 (deniable_values -> BOOLEAN .)
    AMPERSAND       reduce using rule 72 (deniable_values -> BOOLEAN .)
    PIPELINE        reduce using rule 72 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 72 (deniable_values -> BOOLEAN .)
    SEMICOLON       reduce using rule 72 (deniable_values -> BOOLEAN .)


state 204

    (73) deniable_values -> booleanOp .

    AND             reduce using rule 73 (deniable_values -> booleanOp .)
    OR              reduce using rule 73 (deniable_values -> booleanOp .)
    AMPERSAND       reduce using rule 73 (deniable_values -> booleanOp .)
    PIPELINE        reduce using rule 73 (deniable_values -> booleanOp .)
    RPAREN          reduce using rule 73 (deniable_values -> booleanOp .)
    SEMICOLON       reduce using rule 73 (deniable_values -> booleanOp .)


state 205

    (84) condition_operator -> LESSTHAN EQUAL .

    INTEGER         reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)
    FLOAT           reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)
    STR             reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)
    NULL            reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)
    EXMARK          reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)
    IDENTIFIER      reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)
    BOOLEAN         reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)
    TRUE            reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)
    FALSE           reduce using rule 84 (condition_operator -> LESSTHAN EQUAL .)


state 206

    (85) condition_operator -> GREATERTHAN EQUAL .

    INTEGER         reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)
    FLOAT           reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)
    STR             reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)
    NULL            reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)
    EXMARK          reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)
    IDENTIFIER      reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)
    BOOLEAN         reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)
    TRUE            reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)
    FALSE           reduce using rule 85 (condition_operator -> GREATERTHAN EQUAL .)


state 207

    (89) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (76) condition_values -> . negation_values
    (77) condition_values -> . INTEGER
    (78) condition_values -> . FLOAT
    (79) condition_values -> . STR
    (80) condition_values -> . NULL
    (74) negation_values -> . deniable_values
    (75) negation_values -> . EXMARK deniable_values
    (71) deniable_values -> . IDENTIFIER
    (72) deniable_values -> . BOOLEAN
    (73) deniable_values -> . booleanOp
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    INTEGER         shift and go to state 197
    FLOAT           shift and go to state 198
    STR             shift and go to state 199
    NULL            shift and go to state 200
    EXMARK          shift and go to state 202
    IDENTIFIER      shift and go to state 194
    BOOLEAN         shift and go to state 203
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    condition_values               shift and go to state 241
    negation_values                shift and go to state 196
    deniable_values                shift and go to state 201
    booleanOp                      shift and go to state 204

state 208

    (90) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 90 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 90 (condition -> BOOLEAN condition_operator BOOLEAN .)
    AMPERSAND       reduce using rule 90 (condition -> BOOLEAN condition_operator BOOLEAN .)
    PIPELINE        reduce using rule 90 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 90 (condition -> BOOLEAN condition_operator BOOLEAN .)
    SEMICOLON       reduce using rule 90 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 209

    (91) condition -> number condition_operator number .

    AND             reduce using rule 91 (condition -> number condition_operator number .)
    OR              reduce using rule 91 (condition -> number condition_operator number .)
    AMPERSAND       reduce using rule 91 (condition -> number condition_operator number .)
    PIPELINE        reduce using rule 91 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 91 (condition -> number condition_operator number .)
    SEMICOLON       reduce using rule 91 (condition -> number condition_operator number .)


state 210

    (92) condition -> STR condition_operator STR .

    AND             reduce using rule 92 (condition -> STR condition_operator STR .)
    OR              reduce using rule 92 (condition -> STR condition_operator STR .)
    AMPERSAND       reduce using rule 92 (condition -> STR condition_operator STR .)
    PIPELINE        reduce using rule 92 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 92 (condition -> STR condition_operator STR .)
    SEMICOLON       reduce using rule 92 (condition -> STR condition_operator STR .)


state 211

    (93) condition -> booleanOp condition_operator booleanOp .

    AND             reduce using rule 93 (condition -> booleanOp condition_operator booleanOp .)
    OR              reduce using rule 93 (condition -> booleanOp condition_operator booleanOp .)
    AMPERSAND       reduce using rule 93 (condition -> booleanOp condition_operator booleanOp .)
    PIPELINE        reduce using rule 93 (condition -> booleanOp condition_operator booleanOp .)
    RPAREN          reduce using rule 93 (condition -> booleanOp condition_operator booleanOp .)
    SEMICOLON       reduce using rule 93 (condition -> booleanOp condition_operator booleanOp .)


state 212

    (57) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    MAP             shift and go to state 36

    datatype                       shift and go to state 242
    map_identifier                 shift and go to state 88

state 213

    (60) stack -> FINAL IDENTIFIER EQUAL STACK DOT . OF LPAREN IDENTIFIER RPAREN SEMICOLON

    OF              shift and go to state 243


state 214

    (129) booloperation -> IDENTIFIER condition_connector . booleanOp
    (130) booloperation -> IDENTIFIER condition_connector . IDENTIFIER
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 244
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    booleanOp                      shift and go to state 245

state 215

    (124) semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .

    STRING          reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    INT             reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    FOR             reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    WHILE           reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    FINAL           reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    IDENTIFIER      reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    BOOL            reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    LIST            reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    DOUBLE          reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    DYNAMIC         reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    VOID            reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    VAR             reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    MAP             reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    IF              reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    INTEGER         reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    FLOAT           reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    STR             reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    BOOLEAN         reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    TRUE            reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    FALSE           reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    MAIN            reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    $end            reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    RCURLYBRACKET   reduce using rule 124 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)


state 216

    (128) booloperation -> booleanOp condition_connector . booleanOp
    (131) booloperation -> booleanOp condition_connector . IDENTIFIER
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 247
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    booleanOp                      shift and go to state 246

state 217

    (125) semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .

    STRING          reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    INT             reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    FOR             reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    WHILE           reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    FINAL           reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    IDENTIFIER      reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    BOOL            reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    LIST            reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    DOUBLE          reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    DYNAMIC         reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    VOID            reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    VAR             reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    MAP             reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    IF              reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    INTEGER         reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    FLOAT           reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    STR             reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    BOOLEAN         reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    TRUE            reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    FALSE           reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    MAIN            reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    $end            reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    RCURLYBRACKET   reduce using rule 125 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)


state 218

    (133) booloperations -> booloperation condition_connector . booloperations
    (132) booloperations -> . booloperation
    (133) booloperations -> . booloperation condition_connector booloperations
    (128) booloperation -> . booleanOp condition_connector booleanOp
    (129) booloperation -> . IDENTIFIER condition_connector booleanOp
    (130) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (131) booloperation -> . booleanOp condition_connector IDENTIFIER
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 158
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    booloperation                  shift and go to state 161
    booloperations                 shift and go to state 248
    booleanOp                      shift and go to state 249

state 219

    (134) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 250


state 220

    (135) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 251


state 221

    (136) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 252


state 222

    (137) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 253


state 223

    (138) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 254


state 224

    (25) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 255


state 225

    (53) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (14) class_content_repeat -> . class_content
    (15) class_content_repeat -> . class_content_repeat class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content_repeat           shift and go to state 256
    class_content                  shift and go to state 4
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 226

    (16) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (15) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   shift and go to state 257
    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content                  shift and go to state 46
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 227

    (100) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 258


state 228

    (105) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 259


state 229

    (108) optFunction_arguments -> optFunction_argument .
    (109) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 108 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 260


state 230

    (107) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    MAP             shift and go to state 36

    datatype                       shift and go to state 261
    map_identifier                 shift and go to state 88

state 231

    (22) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 262


state 232

    (46) map_pairs -> map_pair COMMA . map_pairs
    (45) map_pairs -> . map_pair
    (46) map_pairs -> . map_pair COMMA map_pairs
    (44) map_pair -> . map_key COLON map_value
    (47) map_key -> . value
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    map_pair                       shift and go to state 177
    map_pairs                      shift and go to state 263
    map_key                        shift and go to state 178
    value                          shift and go to state 179
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 233

    (44) map_pair -> map_key COLON . map_value
    (48) map_value -> . value
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    map_value                      shift and go to state 264
    value                          shift and go to state 265
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 234

    (61) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN . expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 266
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 235

    (152) expressionString -> STR operatorExpressionString expressionString .

    SEMICOLON       reduce using rule 152 (expressionString -> STR operatorExpressionString expressionString .)


state 236

    (159) expressionInteger -> IDENTIFIER operatorExpression expressionInteger .

    SEMICOLON       reduce using rule 159 (expressionInteger -> IDENTIFIER operatorExpression expressionInteger .)


state 237

    (157) expressionInteger -> number operatorExpression expressionInteger .

    SEMICOLON       reduce using rule 157 (expressionInteger -> number operatorExpression expressionInteger .)


state 238

    (56) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON . expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 267
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 239

    (58) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (15) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   shift and go to state 268
    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content                  shift and go to state 46
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 240

    (75) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 75 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 75 (negation_values -> EXMARK deniable_values .)
    AMPERSAND       reduce using rule 75 (negation_values -> EXMARK deniable_values .)
    PIPELINE        reduce using rule 75 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 75 (negation_values -> EXMARK deniable_values .)
    SEMICOLON       reduce using rule 75 (negation_values -> EXMARK deniable_values .)


state 241

    (89) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 89 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 89 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 89 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 89 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 89 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 89 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 242

    (57) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN RPAREN SEMICOLON

    GREATERTHAN     shift and go to state 269


state 243

    (60) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF . LPAREN IDENTIFIER RPAREN SEMICOLON

    LPAREN          shift and go to state 270


state 244

    (130) booloperation -> IDENTIFIER condition_connector IDENTIFIER .

    AND             reduce using rule 130 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    OR              reduce using rule 130 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    AMPERSAND       reduce using rule 130 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    PIPELINE        reduce using rule 130 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    SEMICOLON       reduce using rule 130 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)


state 245

    (129) booloperation -> IDENTIFIER condition_connector booleanOp .

    AND             reduce using rule 129 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    OR              reduce using rule 129 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    AMPERSAND       reduce using rule 129 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    PIPELINE        reduce using rule 129 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    SEMICOLON       reduce using rule 129 (booloperation -> IDENTIFIER condition_connector booleanOp .)


state 246

    (128) booloperation -> booleanOp condition_connector booleanOp .

    AND             reduce using rule 128 (booloperation -> booleanOp condition_connector booleanOp .)
    OR              reduce using rule 128 (booloperation -> booleanOp condition_connector booleanOp .)
    AMPERSAND       reduce using rule 128 (booloperation -> booleanOp condition_connector booleanOp .)
    PIPELINE        reduce using rule 128 (booloperation -> booleanOp condition_connector booleanOp .)
    SEMICOLON       reduce using rule 128 (booloperation -> booleanOp condition_connector booleanOp .)


state 247

    (131) booloperation -> booleanOp condition_connector IDENTIFIER .

    AND             reduce using rule 131 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    OR              reduce using rule 131 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    AMPERSAND       reduce using rule 131 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    PIPELINE        reduce using rule 131 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    SEMICOLON       reduce using rule 131 (booloperation -> booleanOp condition_connector IDENTIFIER .)


state 248

    (133) booloperations -> booloperation condition_connector booloperations .

    SEMICOLON       reduce using rule 133 (booloperations -> booloperation condition_connector booloperations .)


state 249

    (128) booloperation -> booleanOp . condition_connector booleanOp
    (131) booloperation -> booleanOp . condition_connector IDENTIFIER
    (96) condition_connector -> . AND
    (97) condition_connector -> . OR
    (98) condition_connector -> . AMPERSAND AMPERSAND
    (99) condition_connector -> . PIPELINE PIPELINE

    AND             shift and go to state 144
    OR              shift and go to state 145
    AMPERSAND       shift and go to state 146
    PIPELINE        shift and go to state 147

    condition_connector            shift and go to state 216

state 250

    (134) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 271


state 251

    (135) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 272


state 252

    (136) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 273


state 253

    (137) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 274


state 254

    (138) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 275


state 255

    (25) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 25 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    MAIN            reduce using rule 25 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 25 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 25 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 256

    (53) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (15) class_content_repeat -> class_content_repeat . class_content
    (5) class_content -> . map
    (6) class_content -> . ifElseStatement
    (7) class_content -> . function_lambda
    (8) class_content -> . declarationExpression
    (9) class_content -> . forStatement
    (10) class_content -> . while
    (11) class_content -> . stack
    (12) class_content -> . inferedReturnFunction
    (13) class_content -> . expression SEMICOLON
    (19) class_content -> . semanticbool
    (20) class_content -> . semanticlist
    (21) class_content -> . asign
    (22) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (49) ifElseStatement -> . ifStatement
    (50) ifElseStatement -> . ifStatement elifStatement_repeat
    (100) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (120) declarationExpression -> . datatype repeatDeclaration SEMICOLON
    (123) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (149) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (150) declarationExpression -> . STRING IDENTIFIER SEMICOLON
    (154) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (155) declarationExpression -> . INT IDENTIFIER SEMICOLON
    (56) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (58) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (57) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (60) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (61) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (124) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (125) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (134) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (135) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (136) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (137) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (138) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (113) asign -> . IDENTIFIER EQUAL expression SEMICOLON
    (23) map_identifier -> . MAP
    (24) map_identifier -> . MAP map_type_specified
    (53) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (26) datatype -> . INT
    (27) datatype -> . STRING
    (28) datatype -> . BOOL
    (29) datatype -> . DOUBLE
    (30) datatype -> . DYNAMIC
    (31) datatype -> . VOID
    (32) datatype -> . map_identifier
    (33) datatype -> . VAR
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    RCURLYBRACKET   shift and go to state 276
    STRING          shift and go to state 23
    INT             shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 26
    FINAL           shift and go to state 27
    IDENTIFIER      shift and go to state 21
    BOOL            shift and go to state 29
    LIST            shift and go to state 31
    MAP             shift and go to state 36
    IF              shift and go to state 37
    DOUBLE          shift and go to state 33
    DYNAMIC         shift and go to state 32
    VOID            shift and go to state 34
    VAR             shift and go to state 35
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    class_content                  shift and go to state 46
    map                            shift and go to state 6
    ifElseStatement                shift and go to state 7
    function_lambda                shift and go to state 8
    declarationExpression          shift and go to state 9
    forStatement                   shift and go to state 10
    while                          shift and go to state 11
    stack                          shift and go to state 12
    inferedReturnFunction          shift and go to state 13
    expression                     shift and go to state 14
    semanticbool                   shift and go to state 15
    semanticlist                   shift and go to state 16
    asign                          shift and go to state 17
    map_identifier                 shift and go to state 20
    ifStatement                    shift and go to state 22
    datatype                       shift and go to state 48
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 257

    (16) declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    STRING          reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 16 (declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 258

    (100) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 277


state 259

    (105) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 105 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 260

    (109) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (108) optFunction_arguments -> . optFunction_argument
    (109) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (107) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 230

    optFunction_argument           shift and go to state 229
    optFunction_arguments          shift and go to state 278

state 261

    (107) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 279


state 262

    (22) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    STRING          reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INT             reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FOR             reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    WHILE           reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FINAL           reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOL            reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    LIST            reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VOID            reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VAR             reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAP             reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IF              reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INTEGER         reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FLOAT           reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STR             reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    TRUE            reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FALSE           reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAIN            reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    $end            reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 22 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 263

    (46) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 46 (map_pairs -> map_pair COMMA map_pairs .)


state 264

    (44) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 44 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 44 (map_pair -> map_key COLON map_value .)


state 265

    (48) map_value -> value .

    COMMA           reduce using rule 48 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 48 (map_value -> value .)


state 266

    (61) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression . SEMICOLON RCURLYBRACKET

    SEMICOLON       shift and go to state 280


state 267

    (56) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression . RPAREN LCURLYBRACKET RCURLYBRACKET

    RPAREN          shift and go to state 281


state 268

    (58) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    STRING          reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 58 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 269

    (57) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN opt_value RPAREN SEMICOLON
    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 282


state 270

    (60) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN . IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 283


state 271

    (134) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelist RSQUAREBRACKET SEMICOLON
    (139) insidelist -> . value
    (140) insidelist -> . value COMMA insidelist
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    insidelist                     shift and go to state 284
    value                          shift and go to state 285
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 272

    (135) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistint RSQUAREBRACKET SEMICOLON
    (141) insidelistint -> . INTEGER
    (142) insidelistint -> . INTEGER COMMA insidelistint

    INTEGER         shift and go to state 287

    insidelistint                  shift and go to state 286

state 273

    (136) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insideliststr RSQUAREBRACKET SEMICOLON
    (143) insideliststr -> . STR
    (144) insideliststr -> . STR COMMA insideliststr

    STR             shift and go to state 289

    insideliststr                  shift and go to state 288

state 274

    (137) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistbool RSQUAREBRACKET SEMICOLON
    (145) insidelistbool -> . booleanOp
    (146) insidelistbool -> . booleanOp COMMA insidelistbool
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    insidelistbool                 shift and go to state 290
    booleanOp                      shift and go to state 291

state 275

    (138) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistdouble RSQUAREBRACKET SEMICOLON
    (147) insidelistdouble -> . FLOAT
    (148) insidelistdouble -> . FLOAT COMMA insidelistdouble

    FLOAT           shift and go to state 293

    insidelistdouble               shift and go to state 292

state 276

    (53) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAIN            reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 53 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 277

    (100) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (110) expression -> . value
    (111) expression -> . value operatorExpression expression
    (112) expression -> . value operatorExpression operatorExpression
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 294
    value                          shift and go to state 28
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 278

    (109) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 109 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 279

    (107) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 107 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 107 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 280

    (61) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 295


state 281

    (56) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN . LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 296


state 282

    (57) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . opt_value RPAREN SEMICOLON
    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . RPAREN SEMICOLON
    (69) opt_value -> . value
    (70) opt_value -> . empty
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (41) empty -> .
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 298
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

  ! RPAREN          [ reduce using rule 41 (empty -> .) ]

    opt_value                      shift and go to state 297
    value                          shift and go to state 299
    empty                          shift and go to state 300
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 283

    (60) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER . RPAREN SEMICOLON

    RPAREN          shift and go to state 301


state 284

    (134) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 302


state 285

    (139) insidelist -> value .
    (140) insidelist -> value . COMMA insidelist

    RSQUAREBRACKET  reduce using rule 139 (insidelist -> value .)
    COMMA           shift and go to state 303


state 286

    (135) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 304


state 287

    (141) insidelistint -> INTEGER .
    (142) insidelistint -> INTEGER . COMMA insidelistint

    RSQUAREBRACKET  reduce using rule 141 (insidelistint -> INTEGER .)
    COMMA           shift and go to state 305


state 288

    (136) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 306


state 289

    (143) insideliststr -> STR .
    (144) insideliststr -> STR . COMMA insideliststr

    RSQUAREBRACKET  reduce using rule 143 (insideliststr -> STR .)
    COMMA           shift and go to state 307


state 290

    (137) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 308


state 291

    (145) insidelistbool -> booleanOp .
    (146) insidelistbool -> booleanOp . COMMA insidelistbool

    RSQUAREBRACKET  reduce using rule 145 (insidelistbool -> booleanOp .)
    COMMA           shift and go to state 309


state 292

    (138) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 310


state 293

    (147) insidelistdouble -> FLOAT .
    (148) insidelistdouble -> FLOAT . COMMA insidelistdouble

    RSQUAREBRACKET  reduce using rule 147 (insidelistdouble -> FLOAT .)
    COMMA           shift and go to state 311


state 294

    (100) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 312


state 295

    (61) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .

    STRING          reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INT             reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FOR             reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    WHILE           reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FINAL           reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOL            reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    LIST            reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DOUBLE          reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DYNAMIC         reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VOID            reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VAR             reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAP             reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IF              reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INTEGER         reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FLOAT           reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STR             reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOLEAN         reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    TRUE            reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FALSE           reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAIN            reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    $end            reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 61 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)


state 296

    (56) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 313


state 297

    (57) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value . RPAREN SEMICOLON

    RPAREN          shift and go to state 314


state 298

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 315


state 299

    (69) opt_value -> value .

    RPAREN          reduce using rule 69 (opt_value -> value .)


state 300

    (70) opt_value -> empty .

    RPAREN          reduce using rule 70 (opt_value -> empty .)


state 301

    (60) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 316


state 302

    (134) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 317


state 303

    (140) insidelist -> value COMMA . insidelist
    (139) insidelist -> . value
    (140) insidelist -> . value COMMA insidelist
    (62) value -> . INTEGER
    (63) value -> . FLOAT
    (64) value -> . STR
    (65) value -> . BOOLEAN
    (66) value -> . IDENTIFIER
    (67) value -> . booleanOp
    (68) value -> . propertiesAccess
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE
    (162) propertiesAccess -> . IDENTIFIER DOT properties

    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 39
    STR             shift and go to state 40
    BOOLEAN         shift and go to state 41
    IDENTIFIER      shift and go to state 89
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    value                          shift and go to state 285
    insidelist                     shift and go to state 318
    booleanOp                      shift and go to state 30
    propertiesAccess               shift and go to state 42

state 304

    (135) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 319


state 305

    (142) insidelistint -> INTEGER COMMA . insidelistint
    (141) insidelistint -> . INTEGER
    (142) insidelistint -> . INTEGER COMMA insidelistint

    INTEGER         shift and go to state 287

    insidelistint                  shift and go to state 320

state 306

    (136) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 321


state 307

    (144) insideliststr -> STR COMMA . insideliststr
    (143) insideliststr -> . STR
    (144) insideliststr -> . STR COMMA insideliststr

    STR             shift and go to state 289

    insideliststr                  shift and go to state 322

state 308

    (137) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 323


state 309

    (146) insidelistbool -> booleanOp COMMA . insidelistbool
    (145) insidelistbool -> . booleanOp
    (146) insidelistbool -> . booleanOp COMMA insidelistbool
    (126) booleanOp -> . TRUE
    (127) booleanOp -> . FALSE

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    booleanOp                      shift and go to state 291
    insidelistbool                 shift and go to state 324

state 310

    (138) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 325


state 311

    (148) insidelistdouble -> FLOAT COMMA . insidelistdouble
    (147) insidelistdouble -> . FLOAT
    (148) insidelistdouble -> . FLOAT COMMA insidelistdouble

    FLOAT           shift and go to state 293

    insidelistdouble               shift and go to state 326

state 312

    (100) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    STRING          reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INT             reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FOR             reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    WHILE           reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FINAL           reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOL            reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    LIST            reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DOUBLE          reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DYNAMIC         reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VOID            reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VAR             reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAP             reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IF              reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INTEGER         reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FLOAT           reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STR             reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOLEAN         reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    TRUE            reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FALSE           reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAIN            reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    $end            reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 100 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)


state 313

    (56) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .

    STRING          reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FOR             reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    WHILE           reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FINAL           reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    LIST            reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VAR             reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IF              reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INTEGER         reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FLOAT           reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STR             reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOLEAN         reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    TRUE            reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FALSE           reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAIN            reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    $end            reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 56 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)


state 314

    (57) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 327


state 315

    (59) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .

    STRING          reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STR             reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAIN            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 59 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)


state 316

    (60) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .

    STRING          reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INT             reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FOR             reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    WHILE           reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FINAL           reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOL            reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    LIST            reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VOID            reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VAR             reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAP             reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IF              reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INTEGER         reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STR             reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    TRUE            reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FALSE           reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAIN            reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    $end            reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 60 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)


state 317

    (134) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 134 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)


state 318

    (140) insidelist -> value COMMA insidelist .

    RSQUAREBRACKET  reduce using rule 140 (insidelist -> value COMMA insidelist .)


state 319

    (135) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 135 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)


state 320

    (142) insidelistint -> INTEGER COMMA insidelistint .

    RSQUAREBRACKET  reduce using rule 142 (insidelistint -> INTEGER COMMA insidelistint .)


state 321

    (136) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 136 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)


state 322

    (144) insideliststr -> STR COMMA insideliststr .

    RSQUAREBRACKET  reduce using rule 144 (insideliststr -> STR COMMA insideliststr .)


state 323

    (137) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 137 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)


state 324

    (146) insidelistbool -> booleanOp COMMA insidelistbool .

    RSQUAREBRACKET  reduce using rule 146 (insidelistbool -> booleanOp COMMA insidelistbool .)


state 325

    (138) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    MAIN            reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 138 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)


state 326

    (148) insidelistdouble -> FLOAT COMMA insidelistdouble .

    RSQUAREBRACKET  reduce using rule 148 (insidelistdouble -> FLOAT COMMA insidelistdouble .)


state 327

    (57) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .

    STRING          reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INT             reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FOR             reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    WHILE           reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FINAL           reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOL            reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    LIST            reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VOID            reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VAR             reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAP             reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IF              reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STR             reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    TRUE            reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FALSE           reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAIN            reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    $end            reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 57 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 20 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 23 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 24 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 29 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 282 resolved as shift
