Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    APOSTROPHE
    ASYNC
    AWAIT
    CATCH
    CLOSE
    COMMENT
    DOLLAR
    DOUBQUOTMARK
    EXIT
    FILE
    IMPORT
    IN
    IS
    ITERABLE
    LIST
    LSQUAREBRACKET
    MAIN
    METHOD
    NOTEQUAL
    OPENWRITE
    PRINT
    READLINESYNC
    RSQUAREBRACKET
    SET
    TRY
    WHILE
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> class_content_repeat
Rule 2     class_content -> map
Rule 3     class_content -> ifElseStatement
Rule 4     class_content -> function_lambda
Rule 5     class_content -> declarationExpression
Rule 6     class_content -> inferedReturnFunction
Rule 7     class_content_repeat -> class_content
Rule 8     class_content_repeat -> class_content_repeat class_content
Rule 9     map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 10    map_identifier -> MAP
Rule 11    map_identifier -> MAP map_type_specified
Rule 12    map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 13    datatype -> returnType
Rule 14    datatype -> VAR
Rule 15    returnType -> INT
Rule 16    returnType -> STRING
Rule 17    returnType -> BOOL
Rule 18    returnType -> DOUBLE
Rule 19    returnType -> DYNAMIC
Rule 20    returnType -> VOID
Rule 21    returnType -> map_identifier
Rule 22    empty -> <empty>
Rule 23    map_content -> map_pairs
Rule 24    map_content -> empty
Rule 25    map_pair -> map_key COLON map_value
Rule 26    map_pairs -> map_pair
Rule 27    map_pairs -> map_pair COMMA map_pairs
Rule 28    map_key -> value
Rule 29    map_value -> value
Rule 30    ifElseStatement -> ifStatement
Rule 31    ifElseStatement -> ifStatement elifStatement_repeat
Rule 32    elifStatement_repeat -> elifStatement
Rule 33    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 34    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 35    elifStatement -> ELSE ifStatement
Rule 36    elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 37    forStatement -> FOR LPAREN declarationExpression conditions SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 38    taskStatement -> IDENTIFIER PLUS PLUS
Rule 39    taskStatement -> IDENTIFIER MINUS MINUS
Rule 40    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
Rule 41    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 42    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
Rule 43    value -> INTEGER
Rule 44    value -> FLOAT
Rule 45    value -> STR
Rule 46    value -> BOOLEAN
Rule 47    value -> IDENTIFIER
Rule 48    opt_value -> value
Rule 49    opt_value -> empty
Rule 50    deniable_values -> IDENTIFIER
Rule 51    deniable_values -> BOOLEAN
Rule 52    negation_values -> deniable_values
Rule 53    negation_values -> EXMARK deniable_values
Rule 54    condition_values -> negation_values
Rule 55    condition_values -> INTEGER
Rule 56    condition_values -> FLOAT
Rule 57    condition_values -> STR
Rule 58    condition_operator -> DOUBLEQUAL
Rule 59    condition_operator -> LESSTHAN
Rule 60    condition_operator -> GREATERTHAN
Rule 61    number -> FLOAT
Rule 62    number -> INTEGER
Rule 63    condition -> IDENTIFIER condition_operator condition_values
Rule 64    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 65    condition -> BOOLEAN condition_operator BOOLEAN
Rule 66    condition -> number condition_operator number
Rule 67    condition -> STR condition_operator STR
Rule 68    conditions -> condition
Rule 69    conditions -> condition condition_connector conditions
Rule 70    condition_connector -> AND
Rule 71    condition_connector -> OR
Rule 72    function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 73    function_argument -> datatype IDENTIFIER
Rule 74    function_argument -> empty
Rule 75    function_arguments_repeat -> function_argument
Rule 76    function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 77    optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 78    optFunction_argumentsExpression -> empty
Rule 79    optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 80    optFunction_arguments -> optFunction_argument
Rule 81    optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 82    expression -> operableTypes operatorExpression operableTypes
Rule 83    expression -> value
Rule 84    operableTypes -> IDENTIFIER
Rule 85    operableTypes -> number
Rule 86    operatorExpression -> PLUS
Rule 87    operatorExpression -> MINUS
Rule 88    operatorExpression -> TIMES
Rule 89    operatorExpression -> DIVISION
Rule 90    declarationExpression -> datatype IDENTIFIER SEMICOLON
Rule 91    declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 70
APOSTROPHE           : 
ASYNC                : 
AWAIT                : 
BOOL                 : 17
BOOLEAN              : 46 51 65 65
CATCH                : 
CLOSE                : 
COLON                : 25
COMMA                : 12 27 76 81
COMMENT              : 
DIVISION             : 89
DOLLAR               : 
DOT                  : 41
DOUBLE               : 18
DOUBLEQUAL           : 58
DOUBQUOTMARK         : 
DYNAMIC              : 19
ELSE                 : 35 36
EQUAL                : 9 40 41 72 91
EXIT                 : 
EXMARK               : 53 64
FILE                 : 
FINAL                : 40 41
FLOAT                : 44 56 61
FOR                  : 37
GREATERTHAN          : 12 40 60 72
IDENTIFIER           : 9 38 39 40 41 41 42 47 50 63 64 72 73 79 84 90 91
IF                   : 34
IMPORT               : 
IN                   : 
INT                  : 15
INTEGER              : 43 55 62
IS                   : 
ITERABLE             : 
LCURLYBRACKET        : 9 34 36 37 42 77
LESSTHAN             : 12 40 59
LIST                 : 
LPAREN               : 34 37 40 41 42 72
LSQUAREBRACKET       : 
MAIN                 : 
MAP                  : 10 11
METHOD               : 
MINUS                : 39 39 87
NOTEQUAL             : 
OF                   : 41
OPENWRITE            : 
OR                   : 71
PLUS                 : 38 38 86
PRINT                : 
RCURLYBRACKET        : 9 34 36 37 42 77
READLINESYNC         : 
REQUIRED             : 79
RETURN               : 42
RPAREN               : 34 37 40 41 42 72
RSQUAREBRACKET       : 
SEMICOLON            : 9 37 40 41 42 72 90 91
SET                  : 
STACK                : 40 41
STR                  : 45 57 67 67
STRING               : 16
TIMES                : 88
TRY                  : 
VAR                  : 14
VOID                 : 20
WHILE                : 
WRITE                : 
error                : 

Nonterminals, with rules where they appear

class                : 0
class_content        : 7 8
class_content_repeat : 1 8 34 36 37
condition            : 68 69
condition_connector  : 69
condition_operator   : 63 64 65 66 67
condition_values     : 63 64
conditions           : 34 37 69
datatype             : 12 12 40 72 73 79 90 91
declarationExpression : 5 37
deniable_values      : 52 53
elifStatement        : 32 33
elifStatement_repeat : 31 33
empty                : 24 49 74 78
expression           : 42 72 91
forStatement         : 
function_argument    : 75 76
function_arguments_repeat : 42 72 76
function_lambda      : 4
ifElseStatement      : 3
ifStatement          : 30 31 35
inferedReturnFunction : 6
map                  : 2
map_content          : 9
map_identifier       : 9 21
map_key              : 25
map_pair             : 26 27
map_pairs            : 23 27
map_type_specified   : 11
map_value            : 25
negation_values      : 54
number               : 66 66 85
operableTypes        : 82 82
operatorExpression   : 82
optFunction_argument : 80 81
optFunction_arguments : 77 81
optFunction_argumentsExpression : 72
opt_value            : 40
returnType           : 13
stack                : 
taskStatement        : 37
value                : 28 29 48 83

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . class_content_repeat
    (7) class_content_repeat -> . class_content
    (8) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . inferedReturnFunction
    (9) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (30) ifElseStatement -> . ifStatement
    (31) ifElseStatement -> . ifStatement elifStatement_repeat
    (72) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (91) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (42) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified
    (34) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier

    IDENTIFIER      shift and go to state 10
    MAP             shift and go to state 13
    IF              shift and go to state 14
    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22

    class                          shift and go to state 1
    class_content_repeat           shift and go to state 2
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    inferedReturnFunction          shift and go to state 8
    map_identifier                 shift and go to state 9
    ifStatement                    shift and go to state 11
    datatype                       shift and go to state 12
    returnType                     shift and go to state 15

state 1

    (0) S' -> class .



state 2

    (1) class -> class_content_repeat .
    (8) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . inferedReturnFunction
    (9) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (30) ifElseStatement -> . ifStatement
    (31) ifElseStatement -> . ifStatement elifStatement_repeat
    (72) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (91) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (42) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified
    (34) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier

    $end            reduce using rule 1 (class -> class_content_repeat .)
    IDENTIFIER      shift and go to state 10
    MAP             shift and go to state 13
    IF              shift and go to state 14
    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22

    class_content                  shift and go to state 23
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    inferedReturnFunction          shift and go to state 8
    map_identifier                 shift and go to state 9
    ifStatement                    shift and go to state 11
    datatype                       shift and go to state 12
    returnType                     shift and go to state 15

state 3

    (7) class_content_repeat -> class_content .

    IDENTIFIER      reduce using rule 7 (class_content_repeat -> class_content .)
    MAP             reduce using rule 7 (class_content_repeat -> class_content .)
    IF              reduce using rule 7 (class_content_repeat -> class_content .)
    VAR             reduce using rule 7 (class_content_repeat -> class_content .)
    INT             reduce using rule 7 (class_content_repeat -> class_content .)
    STRING          reduce using rule 7 (class_content_repeat -> class_content .)
    BOOL            reduce using rule 7 (class_content_repeat -> class_content .)
    DOUBLE          reduce using rule 7 (class_content_repeat -> class_content .)
    DYNAMIC         reduce using rule 7 (class_content_repeat -> class_content .)
    VOID            reduce using rule 7 (class_content_repeat -> class_content .)
    $end            reduce using rule 7 (class_content_repeat -> class_content .)
    RCURLYBRACKET   reduce using rule 7 (class_content_repeat -> class_content .)


state 4

    (2) class_content -> map .

    IDENTIFIER      reduce using rule 2 (class_content -> map .)
    MAP             reduce using rule 2 (class_content -> map .)
    IF              reduce using rule 2 (class_content -> map .)
    VAR             reduce using rule 2 (class_content -> map .)
    INT             reduce using rule 2 (class_content -> map .)
    STRING          reduce using rule 2 (class_content -> map .)
    BOOL            reduce using rule 2 (class_content -> map .)
    DOUBLE          reduce using rule 2 (class_content -> map .)
    DYNAMIC         reduce using rule 2 (class_content -> map .)
    VOID            reduce using rule 2 (class_content -> map .)
    $end            reduce using rule 2 (class_content -> map .)
    RCURLYBRACKET   reduce using rule 2 (class_content -> map .)


state 5

    (3) class_content -> ifElseStatement .

    IDENTIFIER      reduce using rule 3 (class_content -> ifElseStatement .)
    MAP             reduce using rule 3 (class_content -> ifElseStatement .)
    IF              reduce using rule 3 (class_content -> ifElseStatement .)
    VAR             reduce using rule 3 (class_content -> ifElseStatement .)
    INT             reduce using rule 3 (class_content -> ifElseStatement .)
    STRING          reduce using rule 3 (class_content -> ifElseStatement .)
    BOOL            reduce using rule 3 (class_content -> ifElseStatement .)
    DOUBLE          reduce using rule 3 (class_content -> ifElseStatement .)
    DYNAMIC         reduce using rule 3 (class_content -> ifElseStatement .)
    VOID            reduce using rule 3 (class_content -> ifElseStatement .)
    $end            reduce using rule 3 (class_content -> ifElseStatement .)
    RCURLYBRACKET   reduce using rule 3 (class_content -> ifElseStatement .)


state 6

    (4) class_content -> function_lambda .

    IDENTIFIER      reduce using rule 4 (class_content -> function_lambda .)
    MAP             reduce using rule 4 (class_content -> function_lambda .)
    IF              reduce using rule 4 (class_content -> function_lambda .)
    VAR             reduce using rule 4 (class_content -> function_lambda .)
    INT             reduce using rule 4 (class_content -> function_lambda .)
    STRING          reduce using rule 4 (class_content -> function_lambda .)
    BOOL            reduce using rule 4 (class_content -> function_lambda .)
    DOUBLE          reduce using rule 4 (class_content -> function_lambda .)
    DYNAMIC         reduce using rule 4 (class_content -> function_lambda .)
    VOID            reduce using rule 4 (class_content -> function_lambda .)
    $end            reduce using rule 4 (class_content -> function_lambda .)
    RCURLYBRACKET   reduce using rule 4 (class_content -> function_lambda .)


state 7

    (5) class_content -> declarationExpression .

    IDENTIFIER      reduce using rule 5 (class_content -> declarationExpression .)
    MAP             reduce using rule 5 (class_content -> declarationExpression .)
    IF              reduce using rule 5 (class_content -> declarationExpression .)
    VAR             reduce using rule 5 (class_content -> declarationExpression .)
    INT             reduce using rule 5 (class_content -> declarationExpression .)
    STRING          reduce using rule 5 (class_content -> declarationExpression .)
    BOOL            reduce using rule 5 (class_content -> declarationExpression .)
    DOUBLE          reduce using rule 5 (class_content -> declarationExpression .)
    DYNAMIC         reduce using rule 5 (class_content -> declarationExpression .)
    VOID            reduce using rule 5 (class_content -> declarationExpression .)
    $end            reduce using rule 5 (class_content -> declarationExpression .)
    RCURLYBRACKET   reduce using rule 5 (class_content -> declarationExpression .)


state 8

    (6) class_content -> inferedReturnFunction .

    IDENTIFIER      reduce using rule 6 (class_content -> inferedReturnFunction .)
    MAP             reduce using rule 6 (class_content -> inferedReturnFunction .)
    IF              reduce using rule 6 (class_content -> inferedReturnFunction .)
    VAR             reduce using rule 6 (class_content -> inferedReturnFunction .)
    INT             reduce using rule 6 (class_content -> inferedReturnFunction .)
    STRING          reduce using rule 6 (class_content -> inferedReturnFunction .)
    BOOL            reduce using rule 6 (class_content -> inferedReturnFunction .)
    DOUBLE          reduce using rule 6 (class_content -> inferedReturnFunction .)
    DYNAMIC         reduce using rule 6 (class_content -> inferedReturnFunction .)
    VOID            reduce using rule 6 (class_content -> inferedReturnFunction .)
    $end            reduce using rule 6 (class_content -> inferedReturnFunction .)
    RCURLYBRACKET   reduce using rule 6 (class_content -> inferedReturnFunction .)


state 9

    (9) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (21) returnType -> map_identifier .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 24

  ! IDENTIFIER      [ reduce using rule 21 (returnType -> map_identifier .) ]


state 10

    (42) inferedReturnFunction -> IDENTIFIER . LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    LPAREN          shift and go to state 25


state 11

    (30) ifElseStatement -> ifStatement .
    (31) ifElseStatement -> ifStatement . elifStatement_repeat
    (32) elifStatement_repeat -> . elifStatement
    (33) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (35) elifStatement -> . ELSE ifStatement
    (36) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    IDENTIFIER      reduce using rule 30 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 30 (ifElseStatement -> ifStatement .)
    IF              reduce using rule 30 (ifElseStatement -> ifStatement .)
    VAR             reduce using rule 30 (ifElseStatement -> ifStatement .)
    INT             reduce using rule 30 (ifElseStatement -> ifStatement .)
    STRING          reduce using rule 30 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 30 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 30 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 30 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 30 (ifElseStatement -> ifStatement .)
    $end            reduce using rule 30 (ifElseStatement -> ifStatement .)
    RCURLYBRACKET   reduce using rule 30 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 28

    elifStatement_repeat           shift and go to state 26
    elifStatement                  shift and go to state 27

state 12

    (72) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) declarationExpression -> datatype . IDENTIFIER SEMICOLON
    (91) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 29


state 13

    (10) map_identifier -> MAP .
    (11) map_identifier -> MAP . map_type_specified
    (12) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 10 (map_identifier -> MAP .)
    COMMA           reduce using rule 10 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 10 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 31

    map_type_specified             shift and go to state 30

state 14

    (34) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 32


state 15

    (13) datatype -> returnType .

    IDENTIFIER      reduce using rule 13 (datatype -> returnType .)
    COMMA           reduce using rule 13 (datatype -> returnType .)
    GREATERTHAN     reduce using rule 13 (datatype -> returnType .)


state 16

    (14) datatype -> VAR .

    IDENTIFIER      reduce using rule 14 (datatype -> VAR .)
    COMMA           reduce using rule 14 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 14 (datatype -> VAR .)


state 17

    (15) returnType -> INT .

    IDENTIFIER      reduce using rule 15 (returnType -> INT .)
    COMMA           reduce using rule 15 (returnType -> INT .)
    GREATERTHAN     reduce using rule 15 (returnType -> INT .)


state 18

    (16) returnType -> STRING .

    IDENTIFIER      reduce using rule 16 (returnType -> STRING .)
    COMMA           reduce using rule 16 (returnType -> STRING .)
    GREATERTHAN     reduce using rule 16 (returnType -> STRING .)


state 19

    (17) returnType -> BOOL .

    IDENTIFIER      reduce using rule 17 (returnType -> BOOL .)
    COMMA           reduce using rule 17 (returnType -> BOOL .)
    GREATERTHAN     reduce using rule 17 (returnType -> BOOL .)


state 20

    (18) returnType -> DOUBLE .

    IDENTIFIER      reduce using rule 18 (returnType -> DOUBLE .)
    COMMA           reduce using rule 18 (returnType -> DOUBLE .)
    GREATERTHAN     reduce using rule 18 (returnType -> DOUBLE .)


state 21

    (19) returnType -> DYNAMIC .

    IDENTIFIER      reduce using rule 19 (returnType -> DYNAMIC .)
    COMMA           reduce using rule 19 (returnType -> DYNAMIC .)
    GREATERTHAN     reduce using rule 19 (returnType -> DYNAMIC .)


state 22

    (20) returnType -> VOID .

    IDENTIFIER      reduce using rule 20 (returnType -> VOID .)
    COMMA           reduce using rule 20 (returnType -> VOID .)
    GREATERTHAN     reduce using rule 20 (returnType -> VOID .)


state 23

    (8) class_content_repeat -> class_content_repeat class_content .

    IDENTIFIER      reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    MAP             reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    IF              reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    VAR             reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    INT             reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    STRING          reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    BOOL            reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    DOUBLE          reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    DYNAMIC         reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    VOID            reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    $end            reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)
    RCURLYBRACKET   reduce using rule 8 (class_content_repeat -> class_content_repeat class_content .)


state 24

    (9) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 33


state 25

    (42) inferedReturnFunction -> IDENTIFIER LPAREN . function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (75) function_arguments_repeat -> . function_argument
    (76) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (73) function_argument -> . datatype IDENTIFIER
    (74) function_argument -> . empty
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (22) empty -> .
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 16
    COMMA           reduce using rule 22 (empty -> .)
    RPAREN          reduce using rule 22 (empty -> .)
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22
    MAP             shift and go to state 13

    function_arguments_repeat      shift and go to state 34
    function_argument              shift and go to state 35
    datatype                       shift and go to state 36
    empty                          shift and go to state 37
    returnType                     shift and go to state 15
    map_identifier                 shift and go to state 38

state 26

    (31) ifElseStatement -> ifStatement elifStatement_repeat .

    IDENTIFIER      reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IF              reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VAR             reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INT             reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STRING          reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    $end            reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 31 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 27

    (32) elifStatement_repeat -> elifStatement .
    (33) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (32) elifStatement_repeat -> . elifStatement
    (33) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (35) elifStatement -> . ELSE ifStatement
    (36) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    IDENTIFIER      reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    IF              reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    VAR             reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    INT             reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    STRING          reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    $end            reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    RCURLYBRACKET   reduce using rule 32 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 28

    elifStatement                  shift and go to state 27
    elifStatement_repeat           shift and go to state 39

state 28

    (35) elifStatement -> ELSE . ifStatement
    (36) elifStatement -> ELSE . LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (34) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 41
    IF              shift and go to state 14

    ifStatement                    shift and go to state 40

state 29

    (72) function_lambda -> datatype IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) declarationExpression -> datatype IDENTIFIER . SEMICOLON
    (91) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON

    LPAREN          shift and go to state 42
    SEMICOLON       shift and go to state 44
    EQUAL           shift and go to state 43


state 30

    (11) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 11 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 11 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 11 (map_identifier -> MAP map_type_specified .)


state 31

    (12) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22
    MAP             shift and go to state 13

    datatype                       shift and go to state 45
    returnType                     shift and go to state 15
    map_identifier                 shift and go to state 38

state 32

    (34) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (68) conditions -> . condition
    (69) conditions -> . condition condition_connector conditions
    (63) condition -> . IDENTIFIER condition_operator condition_values
    (64) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (65) condition -> . BOOLEAN condition_operator BOOLEAN
    (66) condition -> . number condition_operator number
    (67) condition -> . STR condition_operator STR
    (61) number -> . FLOAT
    (62) number -> . INTEGER

    IDENTIFIER      shift and go to state 48
    EXMARK          shift and go to state 49
    BOOLEAN         shift and go to state 50
    STR             shift and go to state 52
    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54

    conditions                     shift and go to state 46
    condition                      shift and go to state 47
    number                         shift and go to state 51

state 33

    (9) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 55


state 34

    (42) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat . RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    RPAREN          shift and go to state 56


state 35

    (75) function_arguments_repeat -> function_argument .
    (76) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    RPAREN          reduce using rule 75 (function_arguments_repeat -> function_argument .)
    LCURLYBRACKET   reduce using rule 75 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 57


state 36

    (73) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 58


state 37

    (74) function_argument -> empty .

    COMMA           reduce using rule 74 (function_argument -> empty .)
    RPAREN          reduce using rule 74 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 74 (function_argument -> empty .)


state 38

    (21) returnType -> map_identifier .

    IDENTIFIER      reduce using rule 21 (returnType -> map_identifier .)
    COMMA           reduce using rule 21 (returnType -> map_identifier .)
    GREATERTHAN     reduce using rule 21 (returnType -> map_identifier .)


state 39

    (33) elifStatement_repeat -> elifStatement elifStatement_repeat .

    IDENTIFIER      reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IF              reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VAR             reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INT             reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STRING          reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    $end            reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 33 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 40

    (35) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    IDENTIFIER      reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    IF              reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    VAR             reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    $end            reduce using rule 35 (elifStatement -> ELSE ifStatement .)
    RCURLYBRACKET   reduce using rule 35 (elifStatement -> ELSE ifStatement .)


state 41

    (36) elifStatement -> ELSE LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (7) class_content_repeat -> . class_content
    (8) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . inferedReturnFunction
    (9) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (30) ifElseStatement -> . ifStatement
    (31) ifElseStatement -> . ifStatement elifStatement_repeat
    (72) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (91) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (42) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified
    (34) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier

    IDENTIFIER      shift and go to state 10
    MAP             shift and go to state 13
    IF              shift and go to state 14
    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22

    class_content_repeat           shift and go to state 59
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    inferedReturnFunction          shift and go to state 8
    map_identifier                 shift and go to state 9
    ifStatement                    shift and go to state 11
    datatype                       shift and go to state 12
    returnType                     shift and go to state 15

state 42

    (72) function_lambda -> datatype IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (75) function_arguments_repeat -> . function_argument
    (76) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (73) function_argument -> . datatype IDENTIFIER
    (74) function_argument -> . empty
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (22) empty -> .
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 16
    COMMA           reduce using rule 22 (empty -> .)
    LCURLYBRACKET   reduce using rule 22 (empty -> .)
    RPAREN          reduce using rule 22 (empty -> .)
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22
    MAP             shift and go to state 13

    datatype                       shift and go to state 36
    function_arguments_repeat      shift and go to state 60
    function_argument              shift and go to state 35
    empty                          shift and go to state 37
    returnType                     shift and go to state 15
    map_identifier                 shift and go to state 38

state 43

    (91) declarationExpression -> datatype IDENTIFIER EQUAL . expression SEMICOLON
    (82) expression -> . operableTypes operatorExpression operableTypes
    (83) expression -> . value
    (84) operableTypes -> . IDENTIFIER
    (85) operableTypes -> . number
    (43) value -> . INTEGER
    (44) value -> . FLOAT
    (45) value -> . STR
    (46) value -> . BOOLEAN
    (47) value -> . IDENTIFIER
    (61) number -> . FLOAT
    (62) number -> . INTEGER

    IDENTIFIER      shift and go to state 61
    INTEGER         shift and go to state 66
    FLOAT           shift and go to state 67
    STR             shift and go to state 68
    BOOLEAN         shift and go to state 69

    expression                     shift and go to state 62
    operableTypes                  shift and go to state 63
    value                          shift and go to state 64
    number                         shift and go to state 65

state 44

    (90) declarationExpression -> datatype IDENTIFIER SEMICOLON .

    IDENTIFIER      reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    IF              reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    INT             reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    $end            reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 90 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)


state 45

    (12) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 70


state 46

    (34) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 71


state 47

    (68) conditions -> condition .
    (69) conditions -> condition . condition_connector conditions
    (70) condition_connector -> . AND
    (71) condition_connector -> . OR

    RPAREN          reduce using rule 68 (conditions -> condition .)
    AND             shift and go to state 73
    OR              shift and go to state 74

    condition_connector            shift and go to state 72

state 48

    (63) condition -> IDENTIFIER . condition_operator condition_values
    (58) condition_operator -> . DOUBLEQUAL
    (59) condition_operator -> . LESSTHAN
    (60) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 76
    LESSTHAN        shift and go to state 77
    GREATERTHAN     shift and go to state 78

    condition_operator             shift and go to state 75

state 49

    (64) condition -> EXMARK . IDENTIFIER condition_operator condition_values

    IDENTIFIER      shift and go to state 79


state 50

    (65) condition -> BOOLEAN . condition_operator BOOLEAN
    (58) condition_operator -> . DOUBLEQUAL
    (59) condition_operator -> . LESSTHAN
    (60) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 76
    LESSTHAN        shift and go to state 77
    GREATERTHAN     shift and go to state 78

    condition_operator             shift and go to state 80

state 51

    (66) condition -> number . condition_operator number
    (58) condition_operator -> . DOUBLEQUAL
    (59) condition_operator -> . LESSTHAN
    (60) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 76
    LESSTHAN        shift and go to state 77
    GREATERTHAN     shift and go to state 78

    condition_operator             shift and go to state 81

state 52

    (67) condition -> STR . condition_operator STR
    (58) condition_operator -> . DOUBLEQUAL
    (59) condition_operator -> . LESSTHAN
    (60) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 76
    LESSTHAN        shift and go to state 77
    GREATERTHAN     shift and go to state 78

    condition_operator             shift and go to state 82

state 53

    (61) number -> FLOAT .

    DOUBLEQUAL      reduce using rule 61 (number -> FLOAT .)
    LESSTHAN        reduce using rule 61 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 61 (number -> FLOAT .)
    AND             reduce using rule 61 (number -> FLOAT .)
    OR              reduce using rule 61 (number -> FLOAT .)
    RPAREN          reduce using rule 61 (number -> FLOAT .)
    SEMICOLON       reduce using rule 61 (number -> FLOAT .)


state 54

    (62) number -> INTEGER .

    DOUBLEQUAL      reduce using rule 62 (number -> INTEGER .)
    LESSTHAN        reduce using rule 62 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 62 (number -> INTEGER .)
    AND             reduce using rule 62 (number -> INTEGER .)
    OR              reduce using rule 62 (number -> INTEGER .)
    RPAREN          reduce using rule 62 (number -> INTEGER .)
    SEMICOLON       reduce using rule 62 (number -> INTEGER .)


state 55

    (9) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (23) map_content -> . map_pairs
    (24) map_content -> . empty
    (26) map_pairs -> . map_pair
    (27) map_pairs -> . map_pair COMMA map_pairs
    (22) empty -> .
    (25) map_pair -> . map_key COLON map_value
    (28) map_key -> . value
    (43) value -> . INTEGER
    (44) value -> . FLOAT
    (45) value -> . STR
    (46) value -> . BOOLEAN
    (47) value -> . IDENTIFIER

    RCURLYBRACKET   reduce using rule 22 (empty -> .)
    INTEGER         shift and go to state 90
    FLOAT           shift and go to state 91
    STR             shift and go to state 68
    BOOLEAN         shift and go to state 69
    IDENTIFIER      shift and go to state 83

    map_content                    shift and go to state 84
    map_pairs                      shift and go to state 85
    empty                          shift and go to state 86
    map_pair                       shift and go to state 87
    map_key                        shift and go to state 88
    value                          shift and go to state 89

state 56

    (42) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN . LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 92


state 57

    (76) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (75) function_arguments_repeat -> . function_argument
    (76) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (73) function_argument -> . datatype IDENTIFIER
    (74) function_argument -> . empty
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (22) empty -> .
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 16
    COMMA           reduce using rule 22 (empty -> .)
    RPAREN          reduce using rule 22 (empty -> .)
    LCURLYBRACKET   reduce using rule 22 (empty -> .)
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22
    MAP             shift and go to state 13

    function_argument              shift and go to state 35
    function_arguments_repeat      shift and go to state 93
    datatype                       shift and go to state 36
    empty                          shift and go to state 37
    returnType                     shift and go to state 15
    map_identifier                 shift and go to state 38

state 58

    (73) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 73 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 73 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 73 (function_argument -> datatype IDENTIFIER .)


state 59

    (36) elifStatement -> ELSE LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (8) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . inferedReturnFunction
    (9) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (30) ifElseStatement -> . ifStatement
    (31) ifElseStatement -> . ifStatement elifStatement_repeat
    (72) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (91) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (42) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified
    (34) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier

    RCURLYBRACKET   shift and go to state 94
    IDENTIFIER      shift and go to state 10
    MAP             shift and go to state 13
    IF              shift and go to state 14
    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22

    class_content                  shift and go to state 23
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    inferedReturnFunction          shift and go to state 8
    map_identifier                 shift and go to state 9
    ifStatement                    shift and go to state 11
    datatype                       shift and go to state 12
    returnType                     shift and go to state 15

state 60

    (72) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (77) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (78) optFunction_argumentsExpression -> . empty
    (22) empty -> .

    LCURLYBRACKET   shift and go to state 96
    RPAREN          reduce using rule 22 (empty -> .)

    optFunction_argumentsExpression shift and go to state 95
    empty                          shift and go to state 97

state 61

    (84) operableTypes -> IDENTIFIER .
    (47) value -> IDENTIFIER .

    PLUS            reduce using rule 84 (operableTypes -> IDENTIFIER .)
    MINUS           reduce using rule 84 (operableTypes -> IDENTIFIER .)
    TIMES           reduce using rule 84 (operableTypes -> IDENTIFIER .)
    DIVISION        reduce using rule 84 (operableTypes -> IDENTIFIER .)
    SEMICOLON       reduce using rule 47 (value -> IDENTIFIER .)


state 62

    (91) declarationExpression -> datatype IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 98


state 63

    (82) expression -> operableTypes . operatorExpression operableTypes
    (86) operatorExpression -> . PLUS
    (87) operatorExpression -> . MINUS
    (88) operatorExpression -> . TIMES
    (89) operatorExpression -> . DIVISION

    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVISION        shift and go to state 103

    operatorExpression             shift and go to state 99

state 64

    (83) expression -> value .

    SEMICOLON       reduce using rule 83 (expression -> value .)


state 65

    (85) operableTypes -> number .

    PLUS            reduce using rule 85 (operableTypes -> number .)
    MINUS           reduce using rule 85 (operableTypes -> number .)
    TIMES           reduce using rule 85 (operableTypes -> number .)
    DIVISION        reduce using rule 85 (operableTypes -> number .)
    SEMICOLON       reduce using rule 85 (operableTypes -> number .)


state 66

    (43) value -> INTEGER .
    (62) number -> INTEGER .

    SEMICOLON       reduce using rule 43 (value -> INTEGER .)
    PLUS            reduce using rule 62 (number -> INTEGER .)
    MINUS           reduce using rule 62 (number -> INTEGER .)
    TIMES           reduce using rule 62 (number -> INTEGER .)
    DIVISION        reduce using rule 62 (number -> INTEGER .)


state 67

    (44) value -> FLOAT .
    (61) number -> FLOAT .

    SEMICOLON       reduce using rule 44 (value -> FLOAT .)
    PLUS            reduce using rule 61 (number -> FLOAT .)
    MINUS           reduce using rule 61 (number -> FLOAT .)
    TIMES           reduce using rule 61 (number -> FLOAT .)
    DIVISION        reduce using rule 61 (number -> FLOAT .)


state 68

    (45) value -> STR .

    SEMICOLON       reduce using rule 45 (value -> STR .)
    COLON           reduce using rule 45 (value -> STR .)
    COMMA           reduce using rule 45 (value -> STR .)
    RCURLYBRACKET   reduce using rule 45 (value -> STR .)


state 69

    (46) value -> BOOLEAN .

    SEMICOLON       reduce using rule 46 (value -> BOOLEAN .)
    COLON           reduce using rule 46 (value -> BOOLEAN .)
    COMMA           reduce using rule 46 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 46 (value -> BOOLEAN .)


state 70

    (12) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22
    MAP             shift and go to state 13

    datatype                       shift and go to state 104
    returnType                     shift and go to state 15
    map_identifier                 shift and go to state 38

state 71

    (34) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 105


state 72

    (69) conditions -> condition condition_connector . conditions
    (68) conditions -> . condition
    (69) conditions -> . condition condition_connector conditions
    (63) condition -> . IDENTIFIER condition_operator condition_values
    (64) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (65) condition -> . BOOLEAN condition_operator BOOLEAN
    (66) condition -> . number condition_operator number
    (67) condition -> . STR condition_operator STR
    (61) number -> . FLOAT
    (62) number -> . INTEGER

    IDENTIFIER      shift and go to state 48
    EXMARK          shift and go to state 49
    BOOLEAN         shift and go to state 50
    STR             shift and go to state 52
    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54

    condition                      shift and go to state 47
    conditions                     shift and go to state 106
    number                         shift and go to state 51

state 73

    (70) condition_connector -> AND .

    IDENTIFIER      reduce using rule 70 (condition_connector -> AND .)
    EXMARK          reduce using rule 70 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 70 (condition_connector -> AND .)
    STR             reduce using rule 70 (condition_connector -> AND .)
    FLOAT           reduce using rule 70 (condition_connector -> AND .)
    INTEGER         reduce using rule 70 (condition_connector -> AND .)


state 74

    (71) condition_connector -> OR .

    IDENTIFIER      reduce using rule 71 (condition_connector -> OR .)
    EXMARK          reduce using rule 71 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 71 (condition_connector -> OR .)
    STR             reduce using rule 71 (condition_connector -> OR .)
    FLOAT           reduce using rule 71 (condition_connector -> OR .)
    INTEGER         reduce using rule 71 (condition_connector -> OR .)


state 75

    (63) condition -> IDENTIFIER condition_operator . condition_values
    (54) condition_values -> . negation_values
    (55) condition_values -> . INTEGER
    (56) condition_values -> . FLOAT
    (57) condition_values -> . STR
    (52) negation_values -> . deniable_values
    (53) negation_values -> . EXMARK deniable_values
    (50) deniable_values -> . IDENTIFIER
    (51) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 110
    FLOAT           shift and go to state 111
    STR             shift and go to state 112
    EXMARK          shift and go to state 114
    IDENTIFIER      shift and go to state 107
    BOOLEAN         shift and go to state 115

    condition_values               shift and go to state 108
    negation_values                shift and go to state 109
    deniable_values                shift and go to state 113

state 76

    (58) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 58 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 58 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 58 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 58 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 58 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 58 (condition_operator -> DOUBLEQUAL .)


state 77

    (59) condition_operator -> LESSTHAN .

    INTEGER         reduce using rule 59 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 59 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 59 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 59 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 59 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 59 (condition_operator -> LESSTHAN .)


state 78

    (60) condition_operator -> GREATERTHAN .

    INTEGER         reduce using rule 60 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 60 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 60 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 60 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 60 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 60 (condition_operator -> GREATERTHAN .)


state 79

    (64) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (58) condition_operator -> . DOUBLEQUAL
    (59) condition_operator -> . LESSTHAN
    (60) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 76
    LESSTHAN        shift and go to state 77
    GREATERTHAN     shift and go to state 78

    condition_operator             shift and go to state 116

state 80

    (65) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 117


state 81

    (66) condition -> number condition_operator . number
    (61) number -> . FLOAT
    (62) number -> . INTEGER

    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54

    number                         shift and go to state 118

state 82

    (67) condition -> STR condition_operator . STR

    STR             shift and go to state 119


state 83

    (47) value -> IDENTIFIER .

    COLON           reduce using rule 47 (value -> IDENTIFIER .)
    COMMA           reduce using rule 47 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 47 (value -> IDENTIFIER .)


state 84

    (9) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 120


state 85

    (23) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 23 (map_content -> map_pairs .)


state 86

    (24) map_content -> empty .

    RCURLYBRACKET   reduce using rule 24 (map_content -> empty .)


state 87

    (26) map_pairs -> map_pair .
    (27) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 26 (map_pairs -> map_pair .)
    COMMA           shift and go to state 121


state 88

    (25) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 122


state 89

    (28) map_key -> value .

    COLON           reduce using rule 28 (map_key -> value .)


state 90

    (43) value -> INTEGER .

    COLON           reduce using rule 43 (value -> INTEGER .)
    COMMA           reduce using rule 43 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 43 (value -> INTEGER .)


state 91

    (44) value -> FLOAT .

    COLON           reduce using rule 44 (value -> FLOAT .)
    COMMA           reduce using rule 44 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 44 (value -> FLOAT .)


state 92

    (42) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET . RETURN expression SEMICOLON RCURLYBRACKET

    RETURN          shift and go to state 123


state 93

    (76) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    RPAREN          reduce using rule 76 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    LCURLYBRACKET   reduce using rule 76 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 94

    (36) elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 36 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 95

    (72) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 124


state 96

    (77) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (80) optFunction_arguments -> . optFunction_argument
    (81) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (79) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 127

    optFunction_arguments          shift and go to state 125
    optFunction_argument           shift and go to state 126

state 97

    (78) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 78 (optFunction_argumentsExpression -> empty .)


state 98

    (91) declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .

    IDENTIFIER      reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 91 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)


state 99

    (82) expression -> operableTypes operatorExpression . operableTypes
    (84) operableTypes -> . IDENTIFIER
    (85) operableTypes -> . number
    (61) number -> . FLOAT
    (62) number -> . INTEGER

    IDENTIFIER      shift and go to state 129
    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54

    operableTypes                  shift and go to state 128
    number                         shift and go to state 65

state 100

    (86) operatorExpression -> PLUS .

    IDENTIFIER      reduce using rule 86 (operatorExpression -> PLUS .)
    FLOAT           reduce using rule 86 (operatorExpression -> PLUS .)
    INTEGER         reduce using rule 86 (operatorExpression -> PLUS .)


state 101

    (87) operatorExpression -> MINUS .

    IDENTIFIER      reduce using rule 87 (operatorExpression -> MINUS .)
    FLOAT           reduce using rule 87 (operatorExpression -> MINUS .)
    INTEGER         reduce using rule 87 (operatorExpression -> MINUS .)


state 102

    (88) operatorExpression -> TIMES .

    IDENTIFIER      reduce using rule 88 (operatorExpression -> TIMES .)
    FLOAT           reduce using rule 88 (operatorExpression -> TIMES .)
    INTEGER         reduce using rule 88 (operatorExpression -> TIMES .)


state 103

    (89) operatorExpression -> DIVISION .

    IDENTIFIER      reduce using rule 89 (operatorExpression -> DIVISION .)
    FLOAT           reduce using rule 89 (operatorExpression -> DIVISION .)
    INTEGER         reduce using rule 89 (operatorExpression -> DIVISION .)


state 104

    (12) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 130


state 105

    (34) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (7) class_content_repeat -> . class_content
    (8) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . inferedReturnFunction
    (9) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (30) ifElseStatement -> . ifStatement
    (31) ifElseStatement -> . ifStatement elifStatement_repeat
    (72) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (91) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (42) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified
    (34) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier

    IDENTIFIER      shift and go to state 10
    MAP             shift and go to state 13
    IF              shift and go to state 14
    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22

    class_content_repeat           shift and go to state 131
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    inferedReturnFunction          shift and go to state 8
    map_identifier                 shift and go to state 9
    ifStatement                    shift and go to state 11
    datatype                       shift and go to state 12
    returnType                     shift and go to state 15

state 106

    (69) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 69 (conditions -> condition condition_connector conditions .)


state 107

    (50) deniable_values -> IDENTIFIER .

    AND             reduce using rule 50 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 50 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 50 (deniable_values -> IDENTIFIER .)


state 108

    (63) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 63 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 63 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 63 (condition -> IDENTIFIER condition_operator condition_values .)


state 109

    (54) condition_values -> negation_values .

    AND             reduce using rule 54 (condition_values -> negation_values .)
    OR              reduce using rule 54 (condition_values -> negation_values .)
    RPAREN          reduce using rule 54 (condition_values -> negation_values .)


state 110

    (55) condition_values -> INTEGER .

    AND             reduce using rule 55 (condition_values -> INTEGER .)
    OR              reduce using rule 55 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 55 (condition_values -> INTEGER .)


state 111

    (56) condition_values -> FLOAT .

    AND             reduce using rule 56 (condition_values -> FLOAT .)
    OR              reduce using rule 56 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 56 (condition_values -> FLOAT .)


state 112

    (57) condition_values -> STR .

    AND             reduce using rule 57 (condition_values -> STR .)
    OR              reduce using rule 57 (condition_values -> STR .)
    RPAREN          reduce using rule 57 (condition_values -> STR .)


state 113

    (52) negation_values -> deniable_values .

    AND             reduce using rule 52 (negation_values -> deniable_values .)
    OR              reduce using rule 52 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 52 (negation_values -> deniable_values .)


state 114

    (53) negation_values -> EXMARK . deniable_values
    (50) deniable_values -> . IDENTIFIER
    (51) deniable_values -> . BOOLEAN

    IDENTIFIER      shift and go to state 107
    BOOLEAN         shift and go to state 115

    deniable_values                shift and go to state 132

state 115

    (51) deniable_values -> BOOLEAN .

    AND             reduce using rule 51 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 51 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 51 (deniable_values -> BOOLEAN .)


state 116

    (64) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (54) condition_values -> . negation_values
    (55) condition_values -> . INTEGER
    (56) condition_values -> . FLOAT
    (57) condition_values -> . STR
    (52) negation_values -> . deniable_values
    (53) negation_values -> . EXMARK deniable_values
    (50) deniable_values -> . IDENTIFIER
    (51) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 110
    FLOAT           shift and go to state 111
    STR             shift and go to state 112
    EXMARK          shift and go to state 114
    IDENTIFIER      shift and go to state 107
    BOOLEAN         shift and go to state 115

    condition_values               shift and go to state 133
    negation_values                shift and go to state 109
    deniable_values                shift and go to state 113

state 117

    (65) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 65 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 65 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 65 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 118

    (66) condition -> number condition_operator number .

    AND             reduce using rule 66 (condition -> number condition_operator number .)
    OR              reduce using rule 66 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 66 (condition -> number condition_operator number .)


state 119

    (67) condition -> STR condition_operator STR .

    AND             reduce using rule 67 (condition -> STR condition_operator STR .)
    OR              reduce using rule 67 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 67 (condition -> STR condition_operator STR .)


state 120

    (9) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 134


state 121

    (27) map_pairs -> map_pair COMMA . map_pairs
    (26) map_pairs -> . map_pair
    (27) map_pairs -> . map_pair COMMA map_pairs
    (25) map_pair -> . map_key COLON map_value
    (28) map_key -> . value
    (43) value -> . INTEGER
    (44) value -> . FLOAT
    (45) value -> . STR
    (46) value -> . BOOLEAN
    (47) value -> . IDENTIFIER

    INTEGER         shift and go to state 90
    FLOAT           shift and go to state 91
    STR             shift and go to state 68
    BOOLEAN         shift and go to state 69
    IDENTIFIER      shift and go to state 83

    map_pair                       shift and go to state 87
    map_pairs                      shift and go to state 135
    map_key                        shift and go to state 88
    value                          shift and go to state 89

state 122

    (25) map_pair -> map_key COLON . map_value
    (29) map_value -> . value
    (43) value -> . INTEGER
    (44) value -> . FLOAT
    (45) value -> . STR
    (46) value -> . BOOLEAN
    (47) value -> . IDENTIFIER

    INTEGER         shift and go to state 90
    FLOAT           shift and go to state 91
    STR             shift and go to state 68
    BOOLEAN         shift and go to state 69
    IDENTIFIER      shift and go to state 83

    map_value                      shift and go to state 136
    value                          shift and go to state 137

state 123

    (42) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN . expression SEMICOLON RCURLYBRACKET
    (82) expression -> . operableTypes operatorExpression operableTypes
    (83) expression -> . value
    (84) operableTypes -> . IDENTIFIER
    (85) operableTypes -> . number
    (43) value -> . INTEGER
    (44) value -> . FLOAT
    (45) value -> . STR
    (46) value -> . BOOLEAN
    (47) value -> . IDENTIFIER
    (61) number -> . FLOAT
    (62) number -> . INTEGER

    IDENTIFIER      shift and go to state 61
    INTEGER         shift and go to state 66
    FLOAT           shift and go to state 67
    STR             shift and go to state 68
    BOOLEAN         shift and go to state 69

    expression                     shift and go to state 138
    operableTypes                  shift and go to state 63
    value                          shift and go to state 64
    number                         shift and go to state 65

state 124

    (72) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 139


state 125

    (77) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 140


state 126

    (80) optFunction_arguments -> optFunction_argument .
    (81) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 80 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 141


state 127

    (79) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22
    MAP             shift and go to state 13

    datatype                       shift and go to state 142
    returnType                     shift and go to state 15
    map_identifier                 shift and go to state 38

state 128

    (82) expression -> operableTypes operatorExpression operableTypes .

    SEMICOLON       reduce using rule 82 (expression -> operableTypes operatorExpression operableTypes .)


state 129

    (84) operableTypes -> IDENTIFIER .

    SEMICOLON       reduce using rule 84 (operableTypes -> IDENTIFIER .)


state 130

    (12) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 12 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 12 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 12 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 131

    (34) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (8) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . inferedReturnFunction
    (9) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (30) ifElseStatement -> . ifStatement
    (31) ifElseStatement -> . ifStatement elifStatement_repeat
    (72) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (91) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (42) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (10) map_identifier -> . MAP
    (11) map_identifier -> . MAP map_type_specified
    (34) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (13) datatype -> . returnType
    (14) datatype -> . VAR
    (15) returnType -> . INT
    (16) returnType -> . STRING
    (17) returnType -> . BOOL
    (18) returnType -> . DOUBLE
    (19) returnType -> . DYNAMIC
    (20) returnType -> . VOID
    (21) returnType -> . map_identifier

    RCURLYBRACKET   shift and go to state 143
    IDENTIFIER      shift and go to state 10
    MAP             shift and go to state 13
    IF              shift and go to state 14
    VAR             shift and go to state 16
    INT             shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    DOUBLE          shift and go to state 20
    DYNAMIC         shift and go to state 21
    VOID            shift and go to state 22

    class_content                  shift and go to state 23
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    inferedReturnFunction          shift and go to state 8
    map_identifier                 shift and go to state 9
    ifStatement                    shift and go to state 11
    datatype                       shift and go to state 12
    returnType                     shift and go to state 15

state 132

    (53) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 53 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 53 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 53 (negation_values -> EXMARK deniable_values .)


state 133

    (64) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 64 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 64 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 64 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 134

    (9) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    IDENTIFIER      reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAP             reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IF              reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VAR             reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INT             reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STRING          reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOL            reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VOID            reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    $end            reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 9 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 135

    (27) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 27 (map_pairs -> map_pair COMMA map_pairs .)


state 136

    (25) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 25 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 25 (map_pair -> map_key COLON map_value .)


state 137

    (29) map_value -> value .

    COMMA           reduce using rule 29 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 29 (map_value -> value .)


state 138

    (42) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression . SEMICOLON RCURLYBRACKET

    SEMICOLON       shift and go to state 144


state 139

    (72) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 145


state 140

    (77) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 77 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 141

    (81) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (80) optFunction_arguments -> . optFunction_argument
    (81) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (79) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 127

    optFunction_argument           shift and go to state 126
    optFunction_arguments          shift and go to state 146

state 142

    (79) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 147


state 143

    (34) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 34 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 144

    (42) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 148


state 145

    (72) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (82) expression -> . operableTypes operatorExpression operableTypes
    (83) expression -> . value
    (84) operableTypes -> . IDENTIFIER
    (85) operableTypes -> . number
    (43) value -> . INTEGER
    (44) value -> . FLOAT
    (45) value -> . STR
    (46) value -> . BOOLEAN
    (47) value -> . IDENTIFIER
    (61) number -> . FLOAT
    (62) number -> . INTEGER

    IDENTIFIER      shift and go to state 61
    INTEGER         shift and go to state 66
    FLOAT           shift and go to state 67
    STR             shift and go to state 68
    BOOLEAN         shift and go to state 69

    expression                     shift and go to state 149
    operableTypes                  shift and go to state 63
    value                          shift and go to state 64
    number                         shift and go to state 65

state 146

    (81) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 81 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 147

    (79) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 79 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 79 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 148

    (42) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .

    IDENTIFIER      reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAP             reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IF              reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VAR             reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INT             reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STRING          reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOL            reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DOUBLE          reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DYNAMIC         reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VOID            reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    $end            reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 42 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)


state 149

    (72) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 150


state 150

    (72) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    IDENTIFIER      reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAP             reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IF              reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VAR             reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INT             reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STRING          reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOL            reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DOUBLE          reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DYNAMIC         reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VOID            reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    $end            reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 72 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 9 resolved as shift
