Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    APOSTROPHE
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CLOSE
    COMMENT
    COMMENTMULTI
    CONST
    CONTINUE
    DEFAULT
    DEFERRED
    DO
    DOLLAR
    DOUBQUOTMARK
    ENUM
    EXIT
    EXPORT
    EXTENSION
    EXTERNAL
    FACTORY
    FILE
    FUNCTION
    GET
    IMPLEMENTS
    IMPORT
    IN
    IS
    ITERABLE
    LIBRARY
    METHOD
    NOTEQUAL
    OPENWRITE
    READLINESYNC
    SET
    TRY
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> class_content_repeat
Rule 2     class -> declarationMain class_content_repeat
Rule 3     class -> class_content_repeat declarationMain
Rule 4     class -> declarationMain
Rule 5     class_content -> map
Rule 6     class_content -> ifElseStatement
Rule 7     class_content -> function_lambda
Rule 8     class_content -> declarationExpression
Rule 9     class_content -> forStatement
Rule 10    class_content -> while
Rule 11    class_content -> stack
Rule 12    class_content -> inferedReturnFunction
Rule 13    class_content -> expression SEMICOLON
Rule 14    class_content -> print
Rule 15    class_content_repeat -> class_content
Rule 16    class_content_repeat -> class_content_repeat class_content
Rule 17    declarationMain -> datatypeOpt MAIN LPAREN RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 18    datatypeOpt -> datatype
Rule 19    datatypeOpt -> empty
Rule 20    class_content -> semanticbool
Rule 21    class_content -> semanticlist
Rule 22    class_content -> asign
Rule 23    class_content -> assert
Rule 24    map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 25    map_identifier -> MAP
Rule 26    map_identifier -> MAP map_type_specified
Rule 27    map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 28    datatype -> INT
Rule 29    datatype -> STRING
Rule 30    datatype -> BOOL
Rule 31    datatype -> DOUBLE
Rule 32    datatype -> DYNAMIC
Rule 33    datatype -> VOID
Rule 34    datatype -> map_identifier
Rule 35    datatype -> VAR
Rule 36    returnType -> INT
Rule 37    returnType -> STRING
Rule 38    returnType -> BOOL
Rule 39    returnType -> DOUBLE
Rule 40    returnType -> DYNAMIC
Rule 41    returnType -> VOID
Rule 42    returnType -> map_identifier
Rule 43    print -> PRINT LPAREN value RPAREN SEMICOLON
Rule 44    empty -> <empty>
Rule 45    map_content -> map_pairs
Rule 46    map_content -> empty
Rule 47    map_pair -> map_key COLON map_value
Rule 48    map_pairs -> map_pair
Rule 49    map_pairs -> map_pair COMMA map_pairs
Rule 50    map_key -> value
Rule 51    map_value -> value
Rule 52    ifElseStatement -> ifStatement
Rule 53    ifElseStatement -> ifStatement elifStatement_repeat
Rule 54    elifStatement_repeat -> elifStatement
Rule 55    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 56    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 57    elifStatement -> ELSE ifStatement
Rule 58    elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 59    forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 60    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
Rule 61    while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 62    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
Rule 63    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 64    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
Rule 65    value -> INTEGER
Rule 66    value -> FLOAT
Rule 67    value -> STR
Rule 68    value -> BOOLEAN
Rule 69    value -> IDENTIFIER
Rule 70    value -> booleanOp
Rule 71    value -> propertiesAccess
Rule 72    opt_value -> value
Rule 73    opt_value -> empty
Rule 74    deniable_values -> IDENTIFIER
Rule 75    deniable_values -> BOOLEAN
Rule 76    deniable_values -> booleanOp
Rule 77    negation_values -> deniable_values
Rule 78    negation_values -> EXMARK deniable_values
Rule 79    condition_values -> negation_values
Rule 80    condition_values -> INTEGER
Rule 81    condition_values -> FLOAT
Rule 82    condition_values -> STR
Rule 83    condition_values -> NULL
Rule 84    condition_operator -> DOUBLEQUAL
Rule 85    condition_operator -> LESSTHAN
Rule 86    condition_operator -> GREATERTHAN
Rule 87    condition_operator -> LESSTHAN EQUAL
Rule 88    condition_operator -> GREATERTHAN EQUAL
Rule 89    condition_operator -> EXMARK EQUAL
Rule 90    number -> FLOAT
Rule 91    number -> INTEGER
Rule 92    condition -> IDENTIFIER condition_operator condition_values
Rule 93    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 94    condition -> BOOLEAN condition_operator BOOLEAN
Rule 95    condition -> number condition_operator number
Rule 96    condition -> STR condition_operator STR
Rule 97    condition -> booleanOp condition_operator booleanOp
Rule 98    condition -> negation_values
Rule 99    conditions -> condition
Rule 100   conditions -> condition condition_connector conditions
Rule 101   condition_connector -> AND
Rule 102   condition_connector -> OR
Rule 103   condition_connector -> AMPERSAND AMPERSAND
Rule 104   condition_connector -> PIPELINE PIPELINE
Rule 105   function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 106   function_argument -> datatype IDENTIFIER
Rule 107   function_argument -> empty
Rule 108   function_arguments_repeat -> function_argument
Rule 109   function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 110   optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 111   optFunction_argumentsExpression -> empty
Rule 112   optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 113   optFunction_arguments -> optFunction_argument
Rule 114   optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 115   expression -> value
Rule 116   expression -> value operatorExpression expression
Rule 117   expression -> value operatorExpression operatorExpression
Rule 118   asign -> IDENTIFIER EQUAL expression SEMICOLON
Rule 119   asign -> IDENTIFIER operatorExpression EQUAL expression SEMICOLON
Rule 120   assert -> ASSERT LPAREN conditions RPAREN SEMICOLON
Rule 121   operableTypes -> IDENTIFIER
Rule 122   operableTypes -> number
Rule 123   operatorExpression -> PLUS
Rule 124   operatorExpression -> MINUS
Rule 125   operatorExpression -> TIMES
Rule 126   operatorExpression -> DIVISION
Rule 127   operatorExpression -> REST
Rule 128   declarationExpression -> datatype repeatDeclaration SEMICOLON
Rule 129   repeatDeclaration -> IDENTIFIER
Rule 130   repeatDeclaration -> IDENTIFIER COMMA repeatDeclaration
Rule 131   declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON
Rule 132   declarationExpression -> datatype IDENTIFIER EQUAL LPAREN datatype RPAREN IDENTIFIER SEMICOLON
Rule 133   declarationExpression -> FINAL IDENTIFIER EQUAL expression SEMICOLON
Rule 134   semanticbool -> BOOL IDENTIFIER EQUAL conditions SEMICOLON
Rule 135   booleanOp -> TRUE
Rule 136   booleanOp -> FALSE
Rule 137   booloperation -> booleanOp condition_connector booleanOp
Rule 138   booloperation -> IDENTIFIER condition_connector booleanOp
Rule 139   booloperation -> IDENTIFIER condition_connector IDENTIFIER
Rule 140   booloperation -> booleanOp condition_connector IDENTIFIER
Rule 141   booloperations -> booloperation
Rule 142   booloperations -> booloperation condition_connector booloperations
Rule 143   semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
Rule 144   semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
Rule 145   semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
Rule 146   semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
Rule 147   semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
Rule 148   insidelist -> value
Rule 149   insidelist -> value COMMA insidelist
Rule 150   insidelistint -> INTEGER
Rule 151   insidelistint -> INTEGER COMMA insidelistint
Rule 152   insideliststr -> STR
Rule 153   insideliststr -> STR COMMA insideliststr
Rule 154   insidelistbool -> booleanOp
Rule 155   insidelistbool -> booleanOp COMMA insidelistbool
Rule 156   insidelistdouble -> FLOAT
Rule 157   insidelistdouble -> FLOAT COMMA insidelistdouble
Rule 158   addlistInt -> IDENTIFIER DOT ADD LPAREN INTEGER RPAREN SEMICOLON
Rule 159   addlistStr -> IDENTIFIER DOT ADD LPAREN STR RPAREN SEMICOLON
Rule 160   addlistBool -> IDENTIFIER DOT ADD LPAREN booleanOp RPAREN SEMICOLON
Rule 161   addlistFloat -> IDENTIFIER DOT ADD LPAREN FLOAT RPAREN SEMICOLON
Rule 162   declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON
Rule 163   declarationExpression -> STRING IDENTIFIER SEMICOLON
Rule 164   expressionString -> STR
Rule 165   expressionString -> STR operatorExpressionString expressionString
Rule 166   operatorExpressionString -> PLUS
Rule 167   declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON
Rule 168   declarationExpression -> INT IDENTIFIER SEMICOLON
Rule 169   expressionInteger -> number
Rule 170   expressionInteger -> number operatorExpression expressionInteger
Rule 171   expressionInteger -> IDENTIFIER
Rule 172   expressionInteger -> IDENTIFIER operatorExpression expressionInteger
Rule 173   properties -> KEYS
Rule 174   properties -> VALUES
Rule 175   propertiesAccess -> IDENTIFIER DOT properties

Terminals, with rules where they appear

ABSTRACT             : 
AMPERSAND            : 103 103
AND                  : 101
APOSTROPHE           : 
ASSERT               : 120
ASYNC                : 
AWAIT                : 
BOOL                 : 30 38 134 146
BOOLEAN              : 68 75 94 94
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
CLOSE                : 
COLON                : 47
COMMA                : 27 49 109 114 130 149 151 153 155 157
COMMENT              : 
COMMENTMULTI         : 
CONST                : 
CONTINUE             : 
DEFAULT              : 
DEFERRED             : 
DIVISION             : 126
DO                   : 
DOLLAR               : 
DOT                  : 63 158 159 160 161 175
DOUBLE               : 31 39 147
DOUBLEQUAL           : 84
DOUBQUOTMARK         : 
DYNAMIC              : 32 40 143
ELSE                 : 57 58
ENUM                 : 
EQUAL                : 24 60 62 63 87 88 89 105 118 119 131 132 133 134 143 144 145 146 147 162 167
EXIT                 : 
EXMARK               : 78 89 93
EXPORT               : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 136
FILE                 : 
FINAL                : 60 62 63 133
FLOAT                : 66 81 90 156 157 161
FOR                  : 59
FUNCTION             : 
GET                  : 
GREATERTHAN          : 27 60 62 86 88 105 143 144 145 146 147
IDENTIFIER           : 24 60 62 63 63 64 69 74 92 93 105 106 112 118 119 121 129 130 131 132 132 133 134 138 139 139 140 143 144 145 146 147 158 159 160 161 162 163 167 168 171 172 175
IF                   : 56
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INT                  : 28 36 144 167 168
INTEGER              : 65 80 91 150 151 158
IS                   : 
ITERABLE             : 
KEYS                 : 173
LCURLYBRACKET        : 17 24 56 58 59 61 64 110
LESSTHAN             : 27 60 62 85 87 143 144 145 146 147
LIBRARY              : 
LIST                 : 143 144 145 146 147
LPAREN               : 17 43 56 59 60 61 62 63 64 105 120 132 158 159 160 161
LSQUAREBRACKET       : 143 144 145 146 147
MAIN                 : 17
MAP                  : 25 26
METHOD               : 
MINUS                : 124
NOTEQUAL             : 
NULL                 : 83
OF                   : 63
OPENWRITE            : 
OR                   : 102
PIPELINE             : 104 104
PLUS                 : 123 166
PRINT                : 43
RCURLYBRACKET        : 17 24 56 58 59 61 64 110
READLINESYNC         : 
REQUIRED             : 112
REST                 : 127
RETURN               : 64
RPAREN               : 17 43 56 59 60 61 62 63 64 105 120 132 158 159 160 161
RSQUAREBRACKET       : 143 144 145 146 147
SEMICOLON            : 13 24 43 59 59 60 62 63 64 105 118 119 120 128 131 132 133 134 143 144 145 146 147 158 159 160 161 162 163 167 168
SET                  : 
STACK                : 60 62 63
STR                  : 67 82 96 96 152 153 159 164 165
STRING               : 29 37 145 162 163
TIMES                : 125
TRUE                 : 135
TRY                  : 
VALUES               : 174
VAR                  : 35
VOID                 : 33 41
WHILE                : 61
WRITE                : 
error                : 

Nonterminals, with rules where they appear

ADD                  : 158 159 160 161
addlistBool          : 
addlistFloat         : 
addlistInt           : 
addlistStr           : 
asign                : 22
assert               : 23
booleanOp            : 70 76 97 97 137 137 138 140 154 155 160
booloperation        : 141 142
booloperations       : 142
class                : 0
class_content        : 15 16
class_content_repeat : 1 2 3 16 17 56 58 61
condition            : 59 99 100
condition_connector  : 100 137 138 139 140 142
condition_operator   : 92 93 94 95 96 97
condition_values     : 92 93
conditions           : 56 61 100 120 134
datatype             : 18 27 27 60 62 105 106 112 128 131 132 132
datatypeOpt          : 17
declarationExpression : 8 59
declarationMain      : 2 3 4
deniable_values      : 77 78
elifStatement        : 54 55
elifStatement_repeat : 53 55
empty                : 19 46 73 107 111
expression           : 13 59 64 105 116 118 119 131 133
expressionInteger    : 167 170 172
expressionString     : 162 165
forStatement         : 9
function_argument    : 108 109
function_arguments_repeat : 64 105 109
function_lambda      : 7
ifElseStatement      : 6
ifStatement          : 52 53 57
inferedReturnFunction : 12
insidelist           : 143 149
insidelistbool       : 146 155
insidelistdouble     : 147 157
insidelistint        : 144 151
insideliststr        : 145 153
map                  : 5
map_content          : 24
map_identifier       : 24 34 42
map_key              : 47
map_pair             : 48 49
map_pairs            : 45 49
map_type_specified   : 26
map_value            : 47
negation_values      : 79 98
number               : 95 95 122 169 170
operableTypes        : 
operatorExpression   : 116 117 117 119 170 172
operatorExpressionString : 165
optFunction_argument : 113 114
optFunction_arguments : 110 114
optFunction_argumentsExpression : 105
opt_value            : 60
print                : 14
properties           : 175
propertiesAccess     : 71
repeatDeclaration    : 128 130
returnType           : 
semanticbool         : 20
semanticlist         : 21
stack                : 11
value                : 43 50 51 72 115 116 117 148 149
while                : 10

