Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APOSTROPHE
    ASYNC
    AWAIT
    CATCH
    CLOSE
    COMMENT
    DO
    DOLLAR
    DOUBQUOTMARK
    EXIT
    FILE
    IMPORT
    IN
    IS
    ITERABLE
    MAIN
    METHOD
    NOTEQUAL
    OPENWRITE
    PRINT
    READLINESYNC
    SET
    TRY
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> class_content_repeat
Rule 2     class_content -> map
Rule 3     class_content -> ifElseStatement
Rule 4     class_content -> function_lambda
Rule 5     class_content -> declarationExpression
Rule 6     class_content -> forStatement
Rule 7     class_content -> while
Rule 8     class_content -> stack
Rule 9     class_content -> inferedReturnFunction
Rule 10    class_content -> expression SEMICOLON
Rule 11    class_content_repeat -> class_content
Rule 12    class_content_repeat -> class_content_repeat class_content
Rule 13    class_content -> semanticbool
Rule 14    class_content -> semanticlist
Rule 15    map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 16    map_identifier -> MAP
Rule 17    map_identifier -> MAP map_type_specified
Rule 18    map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 19    datatype -> returnType
Rule 20    datatype -> VAR
Rule 21    returnType -> INT
Rule 22    returnType -> STRING
Rule 23    returnType -> BOOL
Rule 24    returnType -> DOUBLE
Rule 25    returnType -> DYNAMIC
Rule 26    returnType -> VOID
Rule 27    returnType -> map_identifier
Rule 28    empty -> <empty>
Rule 29    map_content -> map_pairs
Rule 30    map_content -> empty
Rule 31    map_pair -> map_key COLON map_value
Rule 32    map_pairs -> map_pair
Rule 33    map_pairs -> map_pair COMMA map_pairs
Rule 34    map_key -> value
Rule 35    map_value -> value
Rule 36    ifElseStatement -> ifStatement
Rule 37    ifElseStatement -> ifStatement elifStatement_repeat
Rule 38    elifStatement_repeat -> elifStatement
Rule 39    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 40    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 41    elifStatement -> ELSE ifStatement
Rule 42    elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 43    forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 44    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
Rule 45    while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 46    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
Rule 47    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 48    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
Rule 49    value -> INTEGER
Rule 50    value -> FLOAT
Rule 51    value -> STR
Rule 52    value -> BOOLEAN
Rule 53    value -> IDENTIFIER
Rule 54    value -> booleanOp
Rule 55    opt_value -> value
Rule 56    opt_value -> empty
Rule 57    deniable_values -> IDENTIFIER
Rule 58    deniable_values -> BOOLEAN
Rule 59    deniable_values -> booleanOp
Rule 60    negation_values -> deniable_values
Rule 61    negation_values -> EXMARK deniable_values
Rule 62    condition_values -> negation_values
Rule 63    condition_values -> INTEGER
Rule 64    condition_values -> FLOAT
Rule 65    condition_values -> STR
Rule 66    condition_operator -> DOUBLEQUAL
Rule 67    condition_operator -> LESSTHAN
Rule 68    condition_operator -> GREATERTHAN
Rule 69    condition_operator -> LESSTHAN EQUAL
Rule 70    condition_operator -> GREATERTHAN EQUAL
Rule 71    number -> FLOAT
Rule 72    number -> INTEGER
Rule 73    condition -> IDENTIFIER condition_operator condition_values
Rule 74    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 75    condition -> BOOLEAN condition_operator BOOLEAN
Rule 76    condition -> number condition_operator number
Rule 77    condition -> STR condition_operator STR
Rule 78    condition -> booleanOp condition_operator booleanOp
Rule 79    conditions -> condition
Rule 80    conditions -> condition condition_connector conditions
Rule 81    condition_connector -> AND
Rule 82    condition_connector -> OR
Rule 83    condition_connector -> AMPERSAND AMPERSAND
Rule 84    condition_connector -> PIPELINE PIPELINE
Rule 85    function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 86    function_argument -> datatype IDENTIFIER
Rule 87    function_argument -> empty
Rule 88    function_arguments_repeat -> function_argument
Rule 89    function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 90    optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 91    optFunction_argumentsExpression -> empty
Rule 92    optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 93    optFunction_arguments -> optFunction_argument
Rule 94    optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 95    expression -> operableTypes operatorExpression operableTypes
Rule 96    expression -> value
Rule 97    expression -> operableTypes operatorExpression operatorExpression
Rule 98    operableTypes -> IDENTIFIER
Rule 99    operableTypes -> number
Rule 100   operatorExpression -> PLUS
Rule 101   operatorExpression -> MINUS
Rule 102   operatorExpression -> TIMES
Rule 103   operatorExpression -> DIVISION
Rule 104   declarationExpression -> datatype IDENTIFIER SEMICOLON
Rule 105   declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON
Rule 106   semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
Rule 107   semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON
Rule 108   booleanOp -> TRUE
Rule 109   booleanOp -> FALSE
Rule 110   booloperation -> booleanOp condition_connector booleanOp
Rule 111   booloperation -> IDENTIFIER condition_connector booleanOp
Rule 112   booloperation -> IDENTIFIER condition_connector IDENTIFIER
Rule 113   booloperation -> booleanOp condition_connector IDENTIFIER
Rule 114   booloperations -> booloperation
Rule 115   booloperations -> booloperation condition_connector booloperations
Rule 116   semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
Rule 117   semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
Rule 118   semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
Rule 119   semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
Rule 120   semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
Rule 121   insidelist -> value
Rule 122   insidelist -> value COMMA insidelist
Rule 123   insidelistint -> INTEGER
Rule 124   insidelistint -> INTEGER COMMA insidelistint
Rule 125   insideliststr -> STR
Rule 126   insideliststr -> STR COMMA insideliststr
Rule 127   insidelistbool -> booleanOp
Rule 128   insidelistbool -> booleanOp COMMA insidelistbool
Rule 129   insidelistdouble -> FLOAT
Rule 130   insidelistdouble -> FLOAT COMMA insidelistdouble
Rule 131   declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON
Rule 132   expressionString -> STR
Rule 133   expressionString -> STR operatorExpressionString expressionString
Rule 134   operatorExpressionString -> PLUS
Rule 135   declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON
Rule 136   expressionInteger -> number
Rule 137   expressionInteger -> number operatorExpression expressionInteger
Rule 138   expressionInteger -> IDENTIFIER
Rule 139   expressionInteger -> IDENTIFIER operatorExpression expressionInteger

Terminals, with rules where they appear

AMPERSAND            : 83 83
AND                  : 81
APOSTROPHE           : 
ASYNC                : 
AWAIT                : 
BOOL                 : 23 106 107 119
BOOLEAN              : 52 58 75 75
CATCH                : 
CLOSE                : 
COLON                : 31
COMMA                : 18 33 89 94 122 124 126 128 130
COMMENT              : 
DIVISION             : 103
DO                   : 
DOLLAR               : 
DOT                  : 47
DOUBLE               : 24 120
DOUBLEQUAL           : 66
DOUBQUOTMARK         : 
DYNAMIC              : 25 116
ELSE                 : 41 42
EQUAL                : 15 44 46 47 69 70 85 105 106 107 116 117 118 119 120 131 135
EXIT                 : 
EXMARK               : 61 74
FALSE                : 109
FILE                 : 
FINAL                : 44 46 47
FLOAT                : 50 64 71 129 130
FOR                  : 43
GREATERTHAN          : 18 44 46 68 70 85 116 117 118 119 120
IDENTIFIER           : 15 44 46 47 47 48 53 57 73 74 85 86 92 98 104 105 106 107 111 112 112 113 116 117 118 119 120 131 135 138 139
IF                   : 40
IMPORT               : 
IN                   : 
INT                  : 21 117 135
INTEGER              : 49 63 72 123 124
IS                   : 
ITERABLE             : 
LCURLYBRACKET        : 15 40 42 43 45 48 90
LESSTHAN             : 18 44 46 67 69 116 117 118 119 120
LIST                 : 116 117 118 119 120
LPAREN               : 40 43 44 45 46 47 48 85
LSQUAREBRACKET       : 116 117 118 119 120
MAIN                 : 
MAP                  : 16 17
METHOD               : 
MINUS                : 101
NOTEQUAL             : 
OF                   : 47
OPENWRITE            : 
OR                   : 82
PIPELINE             : 84 84
PLUS                 : 100 134
PRINT                : 
RCURLYBRACKET        : 15 40 42 43 45 48 90
READLINESYNC         : 
REQUIRED             : 92
RETURN               : 48
RPAREN               : 40 43 44 45 46 47 48 85
RSQUAREBRACKET       : 116 117 118 119 120
SEMICOLON            : 10 15 43 43 44 46 47 48 85 104 105 106 107 116 117 118 119 120 131 135
SET                  : 
STACK                : 44 46 47
STR                  : 51 65 77 77 125 126 132 133
STRING               : 22 118 131
TIMES                : 102
TRUE                 : 108
TRY                  : 
VAR                  : 20
VOID                 : 26
WHILE                : 45
WRITE                : 
error                : 

Nonterminals, with rules where they appear

booleanOp            : 54 59 78 78 106 110 110 111 113 127 128
booloperation        : 114 115
booloperations       : 107 115
class                : 0
class_content        : 11 12
class_content_repeat : 1 12 40 42 45
condition            : 43 79 80
condition_connector  : 80 110 111 112 113 115
condition_operator   : 73 74 75 76 77 78
condition_values     : 73 74
conditions           : 40 45 80
datatype             : 18 18 44 46 85 86 92 104 105
declarationExpression : 5 43
deniable_values      : 60 61
elifStatement        : 38 39
elifStatement_repeat : 37 39
empty                : 30 56 87 91
expression           : 10 43 48 85 105
expressionInteger    : 135 137 139
expressionString     : 131 133
forStatement         : 6
function_argument    : 88 89
function_arguments_repeat : 48 85 89
function_lambda      : 4
ifElseStatement      : 3
ifStatement          : 36 37 41
inferedReturnFunction : 9
insidelist           : 116 122
insidelistbool       : 119 128
insidelistdouble     : 120 130
insidelistint        : 117 124
insideliststr        : 118 126
map                  : 2
map_content          : 15
map_identifier       : 15 27
map_key              : 31
map_pair             : 32 33
map_pairs            : 29 33
map_type_specified   : 17
map_value            : 31
negation_values      : 62
number               : 76 76 99 136 137
operableTypes        : 95 95 97
operatorExpression   : 95 97 97 137 139
operatorExpressionString : 133
optFunction_argument : 93 94
optFunction_arguments : 90 94
optFunction_argumentsExpression : 85
opt_value            : 44
returnType           : 19
semanticbool         : 13
semanticlist         : 14
stack                : 8
value                : 34 35 55 96 121 122
while                : 7

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . class_content_repeat
    (11) class_content_repeat -> . class_content
    (12) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . semanticbool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (85) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (106) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (116) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    STRING          shift and go to state 19
    INT             shift and go to state 20
    FOR             shift and go to state 21
    WHILE           shift and go to state 22
    FINAL           shift and go to state 23
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 26
    LIST            shift and go to state 28
    MAP             shift and go to state 31
    IF              shift and go to state 32
    VAR             shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    class                          shift and go to state 1
    class_content_repeat           shift and go to state 2
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    semanticbool                   shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    booleanOp                      shift and go to state 27
    returnType                     shift and go to state 33
    number                         shift and go to state 35

state 1

    (0) S' -> class .



state 2

    (1) class -> class_content_repeat .
    (12) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . semanticbool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (85) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (106) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (116) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    $end            reduce using rule 1 (class -> class_content_repeat .)
    STRING          shift and go to state 19
    INT             shift and go to state 20
    FOR             shift and go to state 21
    WHILE           shift and go to state 22
    FINAL           shift and go to state 23
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 26
    LIST            shift and go to state 28
    MAP             shift and go to state 31
    IF              shift and go to state 32
    VAR             shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    class_content                  shift and go to state 43
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    semanticbool                   shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    booleanOp                      shift and go to state 27
    returnType                     shift and go to state 33
    number                         shift and go to state 35

state 3

    (11) class_content_repeat -> class_content .

    STRING          reduce using rule 11 (class_content_repeat -> class_content .)
    INT             reduce using rule 11 (class_content_repeat -> class_content .)
    FOR             reduce using rule 11 (class_content_repeat -> class_content .)
    WHILE           reduce using rule 11 (class_content_repeat -> class_content .)
    FINAL           reduce using rule 11 (class_content_repeat -> class_content .)
    IDENTIFIER      reduce using rule 11 (class_content_repeat -> class_content .)
    BOOL            reduce using rule 11 (class_content_repeat -> class_content .)
    LIST            reduce using rule 11 (class_content_repeat -> class_content .)
    MAP             reduce using rule 11 (class_content_repeat -> class_content .)
    IF              reduce using rule 11 (class_content_repeat -> class_content .)
    VAR             reduce using rule 11 (class_content_repeat -> class_content .)
    INTEGER         reduce using rule 11 (class_content_repeat -> class_content .)
    FLOAT           reduce using rule 11 (class_content_repeat -> class_content .)
    STR             reduce using rule 11 (class_content_repeat -> class_content .)
    BOOLEAN         reduce using rule 11 (class_content_repeat -> class_content .)
    DOUBLE          reduce using rule 11 (class_content_repeat -> class_content .)
    DYNAMIC         reduce using rule 11 (class_content_repeat -> class_content .)
    VOID            reduce using rule 11 (class_content_repeat -> class_content .)
    TRUE            reduce using rule 11 (class_content_repeat -> class_content .)
    FALSE           reduce using rule 11 (class_content_repeat -> class_content .)
    $end            reduce using rule 11 (class_content_repeat -> class_content .)
    RCURLYBRACKET   reduce using rule 11 (class_content_repeat -> class_content .)


state 4

    (2) class_content -> map .

    STRING          reduce using rule 2 (class_content -> map .)
    INT             reduce using rule 2 (class_content -> map .)
    FOR             reduce using rule 2 (class_content -> map .)
    WHILE           reduce using rule 2 (class_content -> map .)
    FINAL           reduce using rule 2 (class_content -> map .)
    IDENTIFIER      reduce using rule 2 (class_content -> map .)
    BOOL            reduce using rule 2 (class_content -> map .)
    LIST            reduce using rule 2 (class_content -> map .)
    MAP             reduce using rule 2 (class_content -> map .)
    IF              reduce using rule 2 (class_content -> map .)
    VAR             reduce using rule 2 (class_content -> map .)
    INTEGER         reduce using rule 2 (class_content -> map .)
    FLOAT           reduce using rule 2 (class_content -> map .)
    STR             reduce using rule 2 (class_content -> map .)
    BOOLEAN         reduce using rule 2 (class_content -> map .)
    DOUBLE          reduce using rule 2 (class_content -> map .)
    DYNAMIC         reduce using rule 2 (class_content -> map .)
    VOID            reduce using rule 2 (class_content -> map .)
    TRUE            reduce using rule 2 (class_content -> map .)
    FALSE           reduce using rule 2 (class_content -> map .)
    $end            reduce using rule 2 (class_content -> map .)
    RCURLYBRACKET   reduce using rule 2 (class_content -> map .)


state 5

    (3) class_content -> ifElseStatement .

    STRING          reduce using rule 3 (class_content -> ifElseStatement .)
    INT             reduce using rule 3 (class_content -> ifElseStatement .)
    FOR             reduce using rule 3 (class_content -> ifElseStatement .)
    WHILE           reduce using rule 3 (class_content -> ifElseStatement .)
    FINAL           reduce using rule 3 (class_content -> ifElseStatement .)
    IDENTIFIER      reduce using rule 3 (class_content -> ifElseStatement .)
    BOOL            reduce using rule 3 (class_content -> ifElseStatement .)
    LIST            reduce using rule 3 (class_content -> ifElseStatement .)
    MAP             reduce using rule 3 (class_content -> ifElseStatement .)
    IF              reduce using rule 3 (class_content -> ifElseStatement .)
    VAR             reduce using rule 3 (class_content -> ifElseStatement .)
    INTEGER         reduce using rule 3 (class_content -> ifElseStatement .)
    FLOAT           reduce using rule 3 (class_content -> ifElseStatement .)
    STR             reduce using rule 3 (class_content -> ifElseStatement .)
    BOOLEAN         reduce using rule 3 (class_content -> ifElseStatement .)
    DOUBLE          reduce using rule 3 (class_content -> ifElseStatement .)
    DYNAMIC         reduce using rule 3 (class_content -> ifElseStatement .)
    VOID            reduce using rule 3 (class_content -> ifElseStatement .)
    TRUE            reduce using rule 3 (class_content -> ifElseStatement .)
    FALSE           reduce using rule 3 (class_content -> ifElseStatement .)
    $end            reduce using rule 3 (class_content -> ifElseStatement .)
    RCURLYBRACKET   reduce using rule 3 (class_content -> ifElseStatement .)


state 6

    (4) class_content -> function_lambda .

    STRING          reduce using rule 4 (class_content -> function_lambda .)
    INT             reduce using rule 4 (class_content -> function_lambda .)
    FOR             reduce using rule 4 (class_content -> function_lambda .)
    WHILE           reduce using rule 4 (class_content -> function_lambda .)
    FINAL           reduce using rule 4 (class_content -> function_lambda .)
    IDENTIFIER      reduce using rule 4 (class_content -> function_lambda .)
    BOOL            reduce using rule 4 (class_content -> function_lambda .)
    LIST            reduce using rule 4 (class_content -> function_lambda .)
    MAP             reduce using rule 4 (class_content -> function_lambda .)
    IF              reduce using rule 4 (class_content -> function_lambda .)
    VAR             reduce using rule 4 (class_content -> function_lambda .)
    INTEGER         reduce using rule 4 (class_content -> function_lambda .)
    FLOAT           reduce using rule 4 (class_content -> function_lambda .)
    STR             reduce using rule 4 (class_content -> function_lambda .)
    BOOLEAN         reduce using rule 4 (class_content -> function_lambda .)
    DOUBLE          reduce using rule 4 (class_content -> function_lambda .)
    DYNAMIC         reduce using rule 4 (class_content -> function_lambda .)
    VOID            reduce using rule 4 (class_content -> function_lambda .)
    TRUE            reduce using rule 4 (class_content -> function_lambda .)
    FALSE           reduce using rule 4 (class_content -> function_lambda .)
    $end            reduce using rule 4 (class_content -> function_lambda .)
    RCURLYBRACKET   reduce using rule 4 (class_content -> function_lambda .)


state 7

    (5) class_content -> declarationExpression .

    STRING          reduce using rule 5 (class_content -> declarationExpression .)
    INT             reduce using rule 5 (class_content -> declarationExpression .)
    FOR             reduce using rule 5 (class_content -> declarationExpression .)
    WHILE           reduce using rule 5 (class_content -> declarationExpression .)
    FINAL           reduce using rule 5 (class_content -> declarationExpression .)
    IDENTIFIER      reduce using rule 5 (class_content -> declarationExpression .)
    BOOL            reduce using rule 5 (class_content -> declarationExpression .)
    LIST            reduce using rule 5 (class_content -> declarationExpression .)
    MAP             reduce using rule 5 (class_content -> declarationExpression .)
    IF              reduce using rule 5 (class_content -> declarationExpression .)
    VAR             reduce using rule 5 (class_content -> declarationExpression .)
    INTEGER         reduce using rule 5 (class_content -> declarationExpression .)
    FLOAT           reduce using rule 5 (class_content -> declarationExpression .)
    STR             reduce using rule 5 (class_content -> declarationExpression .)
    BOOLEAN         reduce using rule 5 (class_content -> declarationExpression .)
    DOUBLE          reduce using rule 5 (class_content -> declarationExpression .)
    DYNAMIC         reduce using rule 5 (class_content -> declarationExpression .)
    VOID            reduce using rule 5 (class_content -> declarationExpression .)
    TRUE            reduce using rule 5 (class_content -> declarationExpression .)
    FALSE           reduce using rule 5 (class_content -> declarationExpression .)
    $end            reduce using rule 5 (class_content -> declarationExpression .)
    RCURLYBRACKET   reduce using rule 5 (class_content -> declarationExpression .)


state 8

    (6) class_content -> forStatement .

    STRING          reduce using rule 6 (class_content -> forStatement .)
    INT             reduce using rule 6 (class_content -> forStatement .)
    FOR             reduce using rule 6 (class_content -> forStatement .)
    WHILE           reduce using rule 6 (class_content -> forStatement .)
    FINAL           reduce using rule 6 (class_content -> forStatement .)
    IDENTIFIER      reduce using rule 6 (class_content -> forStatement .)
    BOOL            reduce using rule 6 (class_content -> forStatement .)
    LIST            reduce using rule 6 (class_content -> forStatement .)
    MAP             reduce using rule 6 (class_content -> forStatement .)
    IF              reduce using rule 6 (class_content -> forStatement .)
    VAR             reduce using rule 6 (class_content -> forStatement .)
    INTEGER         reduce using rule 6 (class_content -> forStatement .)
    FLOAT           reduce using rule 6 (class_content -> forStatement .)
    STR             reduce using rule 6 (class_content -> forStatement .)
    BOOLEAN         reduce using rule 6 (class_content -> forStatement .)
    DOUBLE          reduce using rule 6 (class_content -> forStatement .)
    DYNAMIC         reduce using rule 6 (class_content -> forStatement .)
    VOID            reduce using rule 6 (class_content -> forStatement .)
    TRUE            reduce using rule 6 (class_content -> forStatement .)
    FALSE           reduce using rule 6 (class_content -> forStatement .)
    $end            reduce using rule 6 (class_content -> forStatement .)
    RCURLYBRACKET   reduce using rule 6 (class_content -> forStatement .)


state 9

    (7) class_content -> while .

    STRING          reduce using rule 7 (class_content -> while .)
    INT             reduce using rule 7 (class_content -> while .)
    FOR             reduce using rule 7 (class_content -> while .)
    WHILE           reduce using rule 7 (class_content -> while .)
    FINAL           reduce using rule 7 (class_content -> while .)
    IDENTIFIER      reduce using rule 7 (class_content -> while .)
    BOOL            reduce using rule 7 (class_content -> while .)
    LIST            reduce using rule 7 (class_content -> while .)
    MAP             reduce using rule 7 (class_content -> while .)
    IF              reduce using rule 7 (class_content -> while .)
    VAR             reduce using rule 7 (class_content -> while .)
    INTEGER         reduce using rule 7 (class_content -> while .)
    FLOAT           reduce using rule 7 (class_content -> while .)
    STR             reduce using rule 7 (class_content -> while .)
    BOOLEAN         reduce using rule 7 (class_content -> while .)
    DOUBLE          reduce using rule 7 (class_content -> while .)
    DYNAMIC         reduce using rule 7 (class_content -> while .)
    VOID            reduce using rule 7 (class_content -> while .)
    TRUE            reduce using rule 7 (class_content -> while .)
    FALSE           reduce using rule 7 (class_content -> while .)
    $end            reduce using rule 7 (class_content -> while .)
    RCURLYBRACKET   reduce using rule 7 (class_content -> while .)


state 10

    (8) class_content -> stack .

    STRING          reduce using rule 8 (class_content -> stack .)
    INT             reduce using rule 8 (class_content -> stack .)
    FOR             reduce using rule 8 (class_content -> stack .)
    WHILE           reduce using rule 8 (class_content -> stack .)
    FINAL           reduce using rule 8 (class_content -> stack .)
    IDENTIFIER      reduce using rule 8 (class_content -> stack .)
    BOOL            reduce using rule 8 (class_content -> stack .)
    LIST            reduce using rule 8 (class_content -> stack .)
    MAP             reduce using rule 8 (class_content -> stack .)
    IF              reduce using rule 8 (class_content -> stack .)
    VAR             reduce using rule 8 (class_content -> stack .)
    INTEGER         reduce using rule 8 (class_content -> stack .)
    FLOAT           reduce using rule 8 (class_content -> stack .)
    STR             reduce using rule 8 (class_content -> stack .)
    BOOLEAN         reduce using rule 8 (class_content -> stack .)
    DOUBLE          reduce using rule 8 (class_content -> stack .)
    DYNAMIC         reduce using rule 8 (class_content -> stack .)
    VOID            reduce using rule 8 (class_content -> stack .)
    TRUE            reduce using rule 8 (class_content -> stack .)
    FALSE           reduce using rule 8 (class_content -> stack .)
    $end            reduce using rule 8 (class_content -> stack .)
    RCURLYBRACKET   reduce using rule 8 (class_content -> stack .)


state 11

    (9) class_content -> inferedReturnFunction .

    STRING          reduce using rule 9 (class_content -> inferedReturnFunction .)
    INT             reduce using rule 9 (class_content -> inferedReturnFunction .)
    FOR             reduce using rule 9 (class_content -> inferedReturnFunction .)
    WHILE           reduce using rule 9 (class_content -> inferedReturnFunction .)
    FINAL           reduce using rule 9 (class_content -> inferedReturnFunction .)
    IDENTIFIER      reduce using rule 9 (class_content -> inferedReturnFunction .)
    BOOL            reduce using rule 9 (class_content -> inferedReturnFunction .)
    LIST            reduce using rule 9 (class_content -> inferedReturnFunction .)
    MAP             reduce using rule 9 (class_content -> inferedReturnFunction .)
    IF              reduce using rule 9 (class_content -> inferedReturnFunction .)
    VAR             reduce using rule 9 (class_content -> inferedReturnFunction .)
    INTEGER         reduce using rule 9 (class_content -> inferedReturnFunction .)
    FLOAT           reduce using rule 9 (class_content -> inferedReturnFunction .)
    STR             reduce using rule 9 (class_content -> inferedReturnFunction .)
    BOOLEAN         reduce using rule 9 (class_content -> inferedReturnFunction .)
    DOUBLE          reduce using rule 9 (class_content -> inferedReturnFunction .)
    DYNAMIC         reduce using rule 9 (class_content -> inferedReturnFunction .)
    VOID            reduce using rule 9 (class_content -> inferedReturnFunction .)
    TRUE            reduce using rule 9 (class_content -> inferedReturnFunction .)
    FALSE           reduce using rule 9 (class_content -> inferedReturnFunction .)
    $end            reduce using rule 9 (class_content -> inferedReturnFunction .)
    RCURLYBRACKET   reduce using rule 9 (class_content -> inferedReturnFunction .)


state 12

    (10) class_content -> expression . SEMICOLON

    SEMICOLON       shift and go to state 44


state 13

    (13) class_content -> semanticbool .

    STRING          reduce using rule 13 (class_content -> semanticbool .)
    INT             reduce using rule 13 (class_content -> semanticbool .)
    FOR             reduce using rule 13 (class_content -> semanticbool .)
    WHILE           reduce using rule 13 (class_content -> semanticbool .)
    FINAL           reduce using rule 13 (class_content -> semanticbool .)
    IDENTIFIER      reduce using rule 13 (class_content -> semanticbool .)
    BOOL            reduce using rule 13 (class_content -> semanticbool .)
    LIST            reduce using rule 13 (class_content -> semanticbool .)
    MAP             reduce using rule 13 (class_content -> semanticbool .)
    IF              reduce using rule 13 (class_content -> semanticbool .)
    VAR             reduce using rule 13 (class_content -> semanticbool .)
    INTEGER         reduce using rule 13 (class_content -> semanticbool .)
    FLOAT           reduce using rule 13 (class_content -> semanticbool .)
    STR             reduce using rule 13 (class_content -> semanticbool .)
    BOOLEAN         reduce using rule 13 (class_content -> semanticbool .)
    DOUBLE          reduce using rule 13 (class_content -> semanticbool .)
    DYNAMIC         reduce using rule 13 (class_content -> semanticbool .)
    VOID            reduce using rule 13 (class_content -> semanticbool .)
    TRUE            reduce using rule 13 (class_content -> semanticbool .)
    FALSE           reduce using rule 13 (class_content -> semanticbool .)
    $end            reduce using rule 13 (class_content -> semanticbool .)
    RCURLYBRACKET   reduce using rule 13 (class_content -> semanticbool .)


state 14

    (14) class_content -> semanticlist .

    STRING          reduce using rule 14 (class_content -> semanticlist .)
    INT             reduce using rule 14 (class_content -> semanticlist .)
    FOR             reduce using rule 14 (class_content -> semanticlist .)
    WHILE           reduce using rule 14 (class_content -> semanticlist .)
    FINAL           reduce using rule 14 (class_content -> semanticlist .)
    IDENTIFIER      reduce using rule 14 (class_content -> semanticlist .)
    BOOL            reduce using rule 14 (class_content -> semanticlist .)
    LIST            reduce using rule 14 (class_content -> semanticlist .)
    MAP             reduce using rule 14 (class_content -> semanticlist .)
    IF              reduce using rule 14 (class_content -> semanticlist .)
    VAR             reduce using rule 14 (class_content -> semanticlist .)
    INTEGER         reduce using rule 14 (class_content -> semanticlist .)
    FLOAT           reduce using rule 14 (class_content -> semanticlist .)
    STR             reduce using rule 14 (class_content -> semanticlist .)
    BOOLEAN         reduce using rule 14 (class_content -> semanticlist .)
    DOUBLE          reduce using rule 14 (class_content -> semanticlist .)
    DYNAMIC         reduce using rule 14 (class_content -> semanticlist .)
    VOID            reduce using rule 14 (class_content -> semanticlist .)
    TRUE            reduce using rule 14 (class_content -> semanticlist .)
    FALSE           reduce using rule 14 (class_content -> semanticlist .)
    $end            reduce using rule 14 (class_content -> semanticlist .)
    RCURLYBRACKET   reduce using rule 14 (class_content -> semanticlist .)


state 15

    (15) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (27) returnType -> map_identifier .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 45

  ! IDENTIFIER      [ reduce using rule 27 (returnType -> map_identifier .) ]


state 16

    (48) inferedReturnFunction -> IDENTIFIER . LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (98) operableTypes -> IDENTIFIER .
    (53) value -> IDENTIFIER .

    LPAREN          shift and go to state 46
    PLUS            reduce using rule 98 (operableTypes -> IDENTIFIER .)
    MINUS           reduce using rule 98 (operableTypes -> IDENTIFIER .)
    TIMES           reduce using rule 98 (operableTypes -> IDENTIFIER .)
    DIVISION        reduce using rule 98 (operableTypes -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (value -> IDENTIFIER .)


state 17

    (36) ifElseStatement -> ifStatement .
    (37) ifElseStatement -> ifStatement . elifStatement_repeat
    (38) elifStatement_repeat -> . elifStatement
    (39) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (41) elifStatement -> . ELSE ifStatement
    (42) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    STRING          reduce using rule 36 (ifElseStatement -> ifStatement .)
    INT             reduce using rule 36 (ifElseStatement -> ifStatement .)
    FOR             reduce using rule 36 (ifElseStatement -> ifStatement .)
    WHILE           reduce using rule 36 (ifElseStatement -> ifStatement .)
    FINAL           reduce using rule 36 (ifElseStatement -> ifStatement .)
    IDENTIFIER      reduce using rule 36 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 36 (ifElseStatement -> ifStatement .)
    LIST            reduce using rule 36 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 36 (ifElseStatement -> ifStatement .)
    IF              reduce using rule 36 (ifElseStatement -> ifStatement .)
    VAR             reduce using rule 36 (ifElseStatement -> ifStatement .)
    INTEGER         reduce using rule 36 (ifElseStatement -> ifStatement .)
    FLOAT           reduce using rule 36 (ifElseStatement -> ifStatement .)
    STR             reduce using rule 36 (ifElseStatement -> ifStatement .)
    BOOLEAN         reduce using rule 36 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 36 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 36 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 36 (ifElseStatement -> ifStatement .)
    TRUE            reduce using rule 36 (ifElseStatement -> ifStatement .)
    FALSE           reduce using rule 36 (ifElseStatement -> ifStatement .)
    $end            reduce using rule 36 (ifElseStatement -> ifStatement .)
    RCURLYBRACKET   reduce using rule 36 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 49

    elifStatement_repeat           shift and go to state 47
    elifStatement                  shift and go to state 48

state 18

    (85) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> datatype . IDENTIFIER SEMICOLON
    (105) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 50


state 19

    (131) declarationExpression -> STRING . IDENTIFIER EQUAL expressionString SEMICOLON
    (22) returnType -> STRING .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 51

  ! IDENTIFIER      [ reduce using rule 22 (returnType -> STRING .) ]


state 20

    (135) declarationExpression -> INT . IDENTIFIER EQUAL expressionInteger SEMICOLON
    (21) returnType -> INT .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 52

  ! IDENTIFIER      [ reduce using rule 21 (returnType -> INT .) ]


state 21

    (43) forStatement -> FOR . LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    LPAREN          shift and go to state 53


state 22

    (45) while -> WHILE . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 54


state 23

    (44) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> FINAL . IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 55


state 24

    (95) expression -> operableTypes . operatorExpression operableTypes
    (97) expression -> operableTypes . operatorExpression operatorExpression
    (100) operatorExpression -> . PLUS
    (101) operatorExpression -> . MINUS
    (102) operatorExpression -> . TIMES
    (103) operatorExpression -> . DIVISION

    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVISION        shift and go to state 60

    operatorExpression             shift and go to state 56

state 25

    (96) expression -> value .

    SEMICOLON       reduce using rule 96 (expression -> value .)
    RPAREN          reduce using rule 96 (expression -> value .)


state 26

    (106) semanticbool -> BOOL . IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> BOOL . IDENTIFIER EQUAL booloperations SEMICOLON
    (23) returnType -> BOOL .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 61

  ! IDENTIFIER      [ reduce using rule 23 (returnType -> BOOL .) ]


state 27

    (54) value -> booleanOp .

    SEMICOLON       reduce using rule 54 (value -> booleanOp .)
    COLON           reduce using rule 54 (value -> booleanOp .)
    COMMA           reduce using rule 54 (value -> booleanOp .)
    RCURLYBRACKET   reduce using rule 54 (value -> booleanOp .)
    RPAREN          reduce using rule 54 (value -> booleanOp .)
    RSQUAREBRACKET  reduce using rule 54 (value -> booleanOp .)


state 28

    (116) semanticlist -> LIST . LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> LIST . LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> LIST . LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> LIST . LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> LIST . LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    LESSTHAN        shift and go to state 62


state 29

    (25) returnType -> DYNAMIC .

    IDENTIFIER      reduce using rule 25 (returnType -> DYNAMIC .)
    COMMA           reduce using rule 25 (returnType -> DYNAMIC .)
    GREATERTHAN     reduce using rule 25 (returnType -> DYNAMIC .)


state 30

    (24) returnType -> DOUBLE .

    IDENTIFIER      reduce using rule 24 (returnType -> DOUBLE .)
    COMMA           reduce using rule 24 (returnType -> DOUBLE .)
    GREATERTHAN     reduce using rule 24 (returnType -> DOUBLE .)


state 31

    (16) map_identifier -> MAP .
    (17) map_identifier -> MAP . map_type_specified
    (18) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 16 (map_identifier -> MAP .)
    COMMA           reduce using rule 16 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 16 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 64

    map_type_specified             shift and go to state 63

state 32

    (40) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 65


state 33

    (19) datatype -> returnType .

    IDENTIFIER      reduce using rule 19 (datatype -> returnType .)
    COMMA           reduce using rule 19 (datatype -> returnType .)
    GREATERTHAN     reduce using rule 19 (datatype -> returnType .)


state 34

    (20) datatype -> VAR .

    IDENTIFIER      reduce using rule 20 (datatype -> VAR .)
    COMMA           reduce using rule 20 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 20 (datatype -> VAR .)


state 35

    (99) operableTypes -> number .

    PLUS            reduce using rule 99 (operableTypes -> number .)
    MINUS           reduce using rule 99 (operableTypes -> number .)
    TIMES           reduce using rule 99 (operableTypes -> number .)
    DIVISION        reduce using rule 99 (operableTypes -> number .)
    SEMICOLON       reduce using rule 99 (operableTypes -> number .)
    RPAREN          reduce using rule 99 (operableTypes -> number .)


state 36

    (49) value -> INTEGER .
    (72) number -> INTEGER .

    SEMICOLON       reduce using rule 49 (value -> INTEGER .)
    RPAREN          reduce using rule 49 (value -> INTEGER .)
    PLUS            reduce using rule 72 (number -> INTEGER .)
    MINUS           reduce using rule 72 (number -> INTEGER .)
    TIMES           reduce using rule 72 (number -> INTEGER .)
    DIVISION        reduce using rule 72 (number -> INTEGER .)


state 37

    (50) value -> FLOAT .
    (71) number -> FLOAT .

    SEMICOLON       reduce using rule 50 (value -> FLOAT .)
    RPAREN          reduce using rule 50 (value -> FLOAT .)
    PLUS            reduce using rule 71 (number -> FLOAT .)
    MINUS           reduce using rule 71 (number -> FLOAT .)
    TIMES           reduce using rule 71 (number -> FLOAT .)
    DIVISION        reduce using rule 71 (number -> FLOAT .)


state 38

    (51) value -> STR .

    SEMICOLON       reduce using rule 51 (value -> STR .)
    COLON           reduce using rule 51 (value -> STR .)
    COMMA           reduce using rule 51 (value -> STR .)
    RCURLYBRACKET   reduce using rule 51 (value -> STR .)
    RPAREN          reduce using rule 51 (value -> STR .)
    RSQUAREBRACKET  reduce using rule 51 (value -> STR .)


state 39

    (52) value -> BOOLEAN .

    SEMICOLON       reduce using rule 52 (value -> BOOLEAN .)
    COLON           reduce using rule 52 (value -> BOOLEAN .)
    COMMA           reduce using rule 52 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 52 (value -> BOOLEAN .)
    RPAREN          reduce using rule 52 (value -> BOOLEAN .)
    RSQUAREBRACKET  reduce using rule 52 (value -> BOOLEAN .)


state 40

    (26) returnType -> VOID .

    IDENTIFIER      reduce using rule 26 (returnType -> VOID .)
    COMMA           reduce using rule 26 (returnType -> VOID .)
    GREATERTHAN     reduce using rule 26 (returnType -> VOID .)


state 41

    (108) booleanOp -> TRUE .

    SEMICOLON       reduce using rule 108 (booleanOp -> TRUE .)
    DOUBLEQUAL      reduce using rule 108 (booleanOp -> TRUE .)
    LESSTHAN        reduce using rule 108 (booleanOp -> TRUE .)
    GREATERTHAN     reduce using rule 108 (booleanOp -> TRUE .)
    AND             reduce using rule 108 (booleanOp -> TRUE .)
    OR              reduce using rule 108 (booleanOp -> TRUE .)
    AMPERSAND       reduce using rule 108 (booleanOp -> TRUE .)
    PIPELINE        reduce using rule 108 (booleanOp -> TRUE .)
    COLON           reduce using rule 108 (booleanOp -> TRUE .)
    RPAREN          reduce using rule 108 (booleanOp -> TRUE .)
    COMMA           reduce using rule 108 (booleanOp -> TRUE .)
    RCURLYBRACKET   reduce using rule 108 (booleanOp -> TRUE .)
    RSQUAREBRACKET  reduce using rule 108 (booleanOp -> TRUE .)


state 42

    (109) booleanOp -> FALSE .

    SEMICOLON       reduce using rule 109 (booleanOp -> FALSE .)
    DOUBLEQUAL      reduce using rule 109 (booleanOp -> FALSE .)
    LESSTHAN        reduce using rule 109 (booleanOp -> FALSE .)
    GREATERTHAN     reduce using rule 109 (booleanOp -> FALSE .)
    AND             reduce using rule 109 (booleanOp -> FALSE .)
    OR              reduce using rule 109 (booleanOp -> FALSE .)
    AMPERSAND       reduce using rule 109 (booleanOp -> FALSE .)
    PIPELINE        reduce using rule 109 (booleanOp -> FALSE .)
    COLON           reduce using rule 109 (booleanOp -> FALSE .)
    RPAREN          reduce using rule 109 (booleanOp -> FALSE .)
    COMMA           reduce using rule 109 (booleanOp -> FALSE .)
    RCURLYBRACKET   reduce using rule 109 (booleanOp -> FALSE .)
    RSQUAREBRACKET  reduce using rule 109 (booleanOp -> FALSE .)


state 43

    (12) class_content_repeat -> class_content_repeat class_content .

    STRING          reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    INT             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    FOR             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    WHILE           reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    FINAL           reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    IDENTIFIER      reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    BOOL            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    LIST            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    MAP             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    IF              reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    VAR             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    INTEGER         reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    FLOAT           reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    STR             reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    BOOLEAN         reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    DOUBLE          reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    DYNAMIC         reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    VOID            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    TRUE            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    FALSE           reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    $end            reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)
    RCURLYBRACKET   reduce using rule 12 (class_content_repeat -> class_content_repeat class_content .)


state 44

    (10) class_content -> expression SEMICOLON .

    STRING          reduce using rule 10 (class_content -> expression SEMICOLON .)
    INT             reduce using rule 10 (class_content -> expression SEMICOLON .)
    FOR             reduce using rule 10 (class_content -> expression SEMICOLON .)
    WHILE           reduce using rule 10 (class_content -> expression SEMICOLON .)
    FINAL           reduce using rule 10 (class_content -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 10 (class_content -> expression SEMICOLON .)
    BOOL            reduce using rule 10 (class_content -> expression SEMICOLON .)
    LIST            reduce using rule 10 (class_content -> expression SEMICOLON .)
    MAP             reduce using rule 10 (class_content -> expression SEMICOLON .)
    IF              reduce using rule 10 (class_content -> expression SEMICOLON .)
    VAR             reduce using rule 10 (class_content -> expression SEMICOLON .)
    INTEGER         reduce using rule 10 (class_content -> expression SEMICOLON .)
    FLOAT           reduce using rule 10 (class_content -> expression SEMICOLON .)
    STR             reduce using rule 10 (class_content -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 10 (class_content -> expression SEMICOLON .)
    DOUBLE          reduce using rule 10 (class_content -> expression SEMICOLON .)
    DYNAMIC         reduce using rule 10 (class_content -> expression SEMICOLON .)
    VOID            reduce using rule 10 (class_content -> expression SEMICOLON .)
    TRUE            reduce using rule 10 (class_content -> expression SEMICOLON .)
    FALSE           reduce using rule 10 (class_content -> expression SEMICOLON .)
    $end            reduce using rule 10 (class_content -> expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 10 (class_content -> expression SEMICOLON .)


state 45

    (15) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 66


state 46

    (48) inferedReturnFunction -> IDENTIFIER LPAREN . function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (88) function_arguments_repeat -> . function_argument
    (89) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (86) function_argument -> . datatype IDENTIFIER
    (87) function_argument -> . empty
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (28) empty -> .
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 34
    COMMA           reduce using rule 28 (empty -> .)
    RPAREN          reduce using rule 28 (empty -> .)
    INT             shift and go to state 71
    STRING          shift and go to state 72
    BOOL            shift and go to state 73
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    MAP             shift and go to state 31

    function_arguments_repeat      shift and go to state 67
    function_argument              shift and go to state 68
    datatype                       shift and go to state 69
    empty                          shift and go to state 70
    returnType                     shift and go to state 33
    map_identifier                 shift and go to state 74

state 47

    (37) ifElseStatement -> ifStatement elifStatement_repeat .

    STRING          reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INT             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FOR             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    WHILE           reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FINAL           reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    LIST            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IF              reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VAR             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STR             reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    TRUE            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FALSE           reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    $end            reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 37 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 48

    (38) elifStatement_repeat -> elifStatement .
    (39) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (38) elifStatement_repeat -> . elifStatement
    (39) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (41) elifStatement -> . ELSE ifStatement
    (42) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    STRING          reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    INT             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    FOR             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    WHILE           reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    FINAL           reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    IDENTIFIER      reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    LIST            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    IF              reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    VAR             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    INTEGER         reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    FLOAT           reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    STR             reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    BOOLEAN         reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    TRUE            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    FALSE           reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    $end            reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    RCURLYBRACKET   reduce using rule 38 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 49

    elifStatement                  shift and go to state 48
    elifStatement_repeat           shift and go to state 75

state 49

    (41) elifStatement -> ELSE . ifStatement
    (42) elifStatement -> ELSE . LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 77
    IF              shift and go to state 32

    ifStatement                    shift and go to state 76

state 50

    (85) function_lambda -> datatype IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> datatype IDENTIFIER . SEMICOLON
    (105) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON

    LPAREN          shift and go to state 78
    SEMICOLON       shift and go to state 80
    EQUAL           shift and go to state 79


state 51

    (131) declarationExpression -> STRING IDENTIFIER . EQUAL expressionString SEMICOLON

    EQUAL           shift and go to state 81


state 52

    (135) declarationExpression -> INT IDENTIFIER . EQUAL expressionInteger SEMICOLON

    EQUAL           shift and go to state 82


state 53

    (43) forStatement -> FOR LPAREN . declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    STRING          shift and go to state 19
    INT             shift and go to state 20
    VAR             shift and go to state 34
    BOOL            shift and go to state 73
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    MAP             shift and go to state 31

    declarationExpression          shift and go to state 83
    datatype                       shift and go to state 84
    returnType                     shift and go to state 33
    map_identifier                 shift and go to state 74

state 54

    (45) while -> WHILE LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (79) conditions -> . condition
    (80) conditions -> . condition condition_connector conditions
    (73) condition -> . IDENTIFIER condition_operator condition_values
    (74) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (75) condition -> . BOOLEAN condition_operator BOOLEAN
    (76) condition -> . number condition_operator number
    (77) condition -> . STR condition_operator STR
    (78) condition -> . booleanOp condition_operator booleanOp
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 87
    EXMARK          shift and go to state 88
    BOOLEAN         shift and go to state 89
    STR             shift and go to state 91
    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    conditions                     shift and go to state 85
    condition                      shift and go to state 86
    number                         shift and go to state 90
    booleanOp                      shift and go to state 92

state 55

    (44) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> FINAL IDENTIFIER . EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    EQUAL           shift and go to state 95


state 56

    (95) expression -> operableTypes operatorExpression . operableTypes
    (97) expression -> operableTypes operatorExpression . operatorExpression
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (100) operatorExpression -> . PLUS
    (101) operatorExpression -> . MINUS
    (102) operatorExpression -> . TIMES
    (103) operatorExpression -> . DIVISION
    (71) number -> . FLOAT
    (72) number -> . INTEGER

    IDENTIFIER      shift and go to state 98
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVISION        shift and go to state 60
    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94

    operableTypes                  shift and go to state 96
    operatorExpression             shift and go to state 97
    number                         shift and go to state 35

state 57

    (100) operatorExpression -> PLUS .

    IDENTIFIER      reduce using rule 100 (operatorExpression -> PLUS .)
    PLUS            reduce using rule 100 (operatorExpression -> PLUS .)
    MINUS           reduce using rule 100 (operatorExpression -> PLUS .)
    TIMES           reduce using rule 100 (operatorExpression -> PLUS .)
    DIVISION        reduce using rule 100 (operatorExpression -> PLUS .)
    FLOAT           reduce using rule 100 (operatorExpression -> PLUS .)
    INTEGER         reduce using rule 100 (operatorExpression -> PLUS .)
    SEMICOLON       reduce using rule 100 (operatorExpression -> PLUS .)
    RPAREN          reduce using rule 100 (operatorExpression -> PLUS .)


state 58

    (101) operatorExpression -> MINUS .

    IDENTIFIER      reduce using rule 101 (operatorExpression -> MINUS .)
    PLUS            reduce using rule 101 (operatorExpression -> MINUS .)
    MINUS           reduce using rule 101 (operatorExpression -> MINUS .)
    TIMES           reduce using rule 101 (operatorExpression -> MINUS .)
    DIVISION        reduce using rule 101 (operatorExpression -> MINUS .)
    FLOAT           reduce using rule 101 (operatorExpression -> MINUS .)
    INTEGER         reduce using rule 101 (operatorExpression -> MINUS .)
    SEMICOLON       reduce using rule 101 (operatorExpression -> MINUS .)
    RPAREN          reduce using rule 101 (operatorExpression -> MINUS .)


state 59

    (102) operatorExpression -> TIMES .

    IDENTIFIER      reduce using rule 102 (operatorExpression -> TIMES .)
    PLUS            reduce using rule 102 (operatorExpression -> TIMES .)
    MINUS           reduce using rule 102 (operatorExpression -> TIMES .)
    TIMES           reduce using rule 102 (operatorExpression -> TIMES .)
    DIVISION        reduce using rule 102 (operatorExpression -> TIMES .)
    FLOAT           reduce using rule 102 (operatorExpression -> TIMES .)
    INTEGER         reduce using rule 102 (operatorExpression -> TIMES .)
    SEMICOLON       reduce using rule 102 (operatorExpression -> TIMES .)
    RPAREN          reduce using rule 102 (operatorExpression -> TIMES .)


state 60

    (103) operatorExpression -> DIVISION .

    IDENTIFIER      reduce using rule 103 (operatorExpression -> DIVISION .)
    PLUS            reduce using rule 103 (operatorExpression -> DIVISION .)
    MINUS           reduce using rule 103 (operatorExpression -> DIVISION .)
    TIMES           reduce using rule 103 (operatorExpression -> DIVISION .)
    DIVISION        reduce using rule 103 (operatorExpression -> DIVISION .)
    FLOAT           reduce using rule 103 (operatorExpression -> DIVISION .)
    INTEGER         reduce using rule 103 (operatorExpression -> DIVISION .)
    SEMICOLON       reduce using rule 103 (operatorExpression -> DIVISION .)
    RPAREN          reduce using rule 103 (operatorExpression -> DIVISION .)


state 61

    (106) semanticbool -> BOOL IDENTIFIER . EQUAL booleanOp SEMICOLON
    (107) semanticbool -> BOOL IDENTIFIER . EQUAL booloperations SEMICOLON

    EQUAL           shift and go to state 99


state 62

    (116) semanticlist -> LIST LESSTHAN . DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> LIST LESSTHAN . INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> LIST LESSTHAN . STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> LIST LESSTHAN . BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> LIST LESSTHAN . DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    DYNAMIC         shift and go to state 100
    INT             shift and go to state 101
    STRING          shift and go to state 102
    BOOL            shift and go to state 103
    DOUBLE          shift and go to state 104


state 63

    (17) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 17 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 17 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 17 (map_identifier -> MAP map_type_specified .)


state 64

    (18) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 34
    INT             shift and go to state 71
    STRING          shift and go to state 72
    BOOL            shift and go to state 73
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    MAP             shift and go to state 31

    datatype                       shift and go to state 105
    returnType                     shift and go to state 33
    map_identifier                 shift and go to state 74

state 65

    (40) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (79) conditions -> . condition
    (80) conditions -> . condition condition_connector conditions
    (73) condition -> . IDENTIFIER condition_operator condition_values
    (74) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (75) condition -> . BOOLEAN condition_operator BOOLEAN
    (76) condition -> . number condition_operator number
    (77) condition -> . STR condition_operator STR
    (78) condition -> . booleanOp condition_operator booleanOp
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 87
    EXMARK          shift and go to state 88
    BOOLEAN         shift and go to state 89
    STR             shift and go to state 91
    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    conditions                     shift and go to state 106
    condition                      shift and go to state 86
    number                         shift and go to state 90
    booleanOp                      shift and go to state 92

state 66

    (15) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 107


state 67

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat . RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    RPAREN          shift and go to state 108


state 68

    (88) function_arguments_repeat -> function_argument .
    (89) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    RPAREN          reduce using rule 88 (function_arguments_repeat -> function_argument .)
    LCURLYBRACKET   reduce using rule 88 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 109


state 69

    (86) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 110


state 70

    (87) function_argument -> empty .

    COMMA           reduce using rule 87 (function_argument -> empty .)
    RPAREN          reduce using rule 87 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 87 (function_argument -> empty .)


state 71

    (21) returnType -> INT .

    IDENTIFIER      reduce using rule 21 (returnType -> INT .)
    COMMA           reduce using rule 21 (returnType -> INT .)
    GREATERTHAN     reduce using rule 21 (returnType -> INT .)


state 72

    (22) returnType -> STRING .

    IDENTIFIER      reduce using rule 22 (returnType -> STRING .)
    COMMA           reduce using rule 22 (returnType -> STRING .)
    GREATERTHAN     reduce using rule 22 (returnType -> STRING .)


state 73

    (23) returnType -> BOOL .

    IDENTIFIER      reduce using rule 23 (returnType -> BOOL .)
    COMMA           reduce using rule 23 (returnType -> BOOL .)
    GREATERTHAN     reduce using rule 23 (returnType -> BOOL .)


state 74

    (27) returnType -> map_identifier .

    IDENTIFIER      reduce using rule 27 (returnType -> map_identifier .)
    COMMA           reduce using rule 27 (returnType -> map_identifier .)
    GREATERTHAN     reduce using rule 27 (returnType -> map_identifier .)


state 75

    (39) elifStatement_repeat -> elifStatement elifStatement_repeat .

    STRING          reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INT             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FOR             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    WHILE           reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FINAL           reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    LIST            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IF              reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VAR             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STR             reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    TRUE            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FALSE           reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    $end            reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 39 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 76

    (41) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    FOR             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    WHILE           reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    FINAL           reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    IDENTIFIER      reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    LIST            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    IF              reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    VAR             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    INTEGER         reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    FLOAT           reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    STR             reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    BOOLEAN         reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    TRUE            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    FALSE           reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    $end            reduce using rule 41 (elifStatement -> ELSE ifStatement .)
    RCURLYBRACKET   reduce using rule 41 (elifStatement -> ELSE ifStatement .)


state 77

    (42) elifStatement -> ELSE LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (11) class_content_repeat -> . class_content
    (12) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . semanticbool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (85) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (106) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (116) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    STRING          shift and go to state 19
    INT             shift and go to state 20
    FOR             shift and go to state 21
    WHILE           shift and go to state 22
    FINAL           shift and go to state 23
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 26
    LIST            shift and go to state 28
    MAP             shift and go to state 31
    IF              shift and go to state 32
    VAR             shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    class_content_repeat           shift and go to state 111
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    semanticbool                   shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    booleanOp                      shift and go to state 27
    returnType                     shift and go to state 33
    number                         shift and go to state 35

state 78

    (85) function_lambda -> datatype IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (88) function_arguments_repeat -> . function_argument
    (89) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (86) function_argument -> . datatype IDENTIFIER
    (87) function_argument -> . empty
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (28) empty -> .
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 34
    COMMA           reduce using rule 28 (empty -> .)
    LCURLYBRACKET   reduce using rule 28 (empty -> .)
    RPAREN          reduce using rule 28 (empty -> .)
    INT             shift and go to state 71
    STRING          shift and go to state 72
    BOOL            shift and go to state 73
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    MAP             shift and go to state 31

    datatype                       shift and go to state 69
    function_arguments_repeat      shift and go to state 112
    function_argument              shift and go to state 68
    empty                          shift and go to state 70
    returnType                     shift and go to state 33
    map_identifier                 shift and go to state 74

state 79

    (105) declarationExpression -> datatype IDENTIFIER EQUAL . expression SEMICOLON
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 113
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    expression                     shift and go to state 114
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    number                         shift and go to state 35
    booleanOp                      shift and go to state 27

state 80

    (104) declarationExpression -> datatype IDENTIFIER SEMICOLON .

    STRING          reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    INT             reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    FINAL           reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    LIST            reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    IF              reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    STR             reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    $end            reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 104 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)


state 81

    (131) declarationExpression -> STRING IDENTIFIER EQUAL . expressionString SEMICOLON
    (132) expressionString -> . STR
    (133) expressionString -> . STR operatorExpressionString expressionString

    STR             shift and go to state 116

    expressionString               shift and go to state 115

state 82

    (135) declarationExpression -> INT IDENTIFIER EQUAL . expressionInteger SEMICOLON
    (136) expressionInteger -> . number
    (137) expressionInteger -> . number operatorExpression expressionInteger
    (138) expressionInteger -> . IDENTIFIER
    (139) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (71) number -> . FLOAT
    (72) number -> . INTEGER

    IDENTIFIER      shift and go to state 117
    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94

    expressionInteger              shift and go to state 118
    number                         shift and go to state 119

state 83

    (43) forStatement -> FOR LPAREN declarationExpression . SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 120


state 84

    (104) declarationExpression -> datatype . IDENTIFIER SEMICOLON
    (105) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 121


state 85

    (45) while -> WHILE LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 122


state 86

    (79) conditions -> condition .
    (80) conditions -> condition . condition_connector conditions
    (81) condition_connector -> . AND
    (82) condition_connector -> . OR
    (83) condition_connector -> . AMPERSAND AMPERSAND
    (84) condition_connector -> . PIPELINE PIPELINE

    RPAREN          reduce using rule 79 (conditions -> condition .)
    AND             shift and go to state 124
    OR              shift and go to state 125
    AMPERSAND       shift and go to state 126
    PIPELINE        shift and go to state 127

    condition_connector            shift and go to state 123

state 87

    (73) condition -> IDENTIFIER . condition_operator condition_values
    (66) condition_operator -> . DOUBLEQUAL
    (67) condition_operator -> . LESSTHAN
    (68) condition_operator -> . GREATERTHAN
    (69) condition_operator -> . LESSTHAN EQUAL
    (70) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 129
    LESSTHAN        shift and go to state 130
    GREATERTHAN     shift and go to state 131

    condition_operator             shift and go to state 128

state 88

    (74) condition -> EXMARK . IDENTIFIER condition_operator condition_values

    IDENTIFIER      shift and go to state 132


state 89

    (75) condition -> BOOLEAN . condition_operator BOOLEAN
    (66) condition_operator -> . DOUBLEQUAL
    (67) condition_operator -> . LESSTHAN
    (68) condition_operator -> . GREATERTHAN
    (69) condition_operator -> . LESSTHAN EQUAL
    (70) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 129
    LESSTHAN        shift and go to state 130
    GREATERTHAN     shift and go to state 131

    condition_operator             shift and go to state 133

state 90

    (76) condition -> number . condition_operator number
    (66) condition_operator -> . DOUBLEQUAL
    (67) condition_operator -> . LESSTHAN
    (68) condition_operator -> . GREATERTHAN
    (69) condition_operator -> . LESSTHAN EQUAL
    (70) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 129
    LESSTHAN        shift and go to state 130
    GREATERTHAN     shift and go to state 131

    condition_operator             shift and go to state 134

state 91

    (77) condition -> STR . condition_operator STR
    (66) condition_operator -> . DOUBLEQUAL
    (67) condition_operator -> . LESSTHAN
    (68) condition_operator -> . GREATERTHAN
    (69) condition_operator -> . LESSTHAN EQUAL
    (70) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 129
    LESSTHAN        shift and go to state 130
    GREATERTHAN     shift and go to state 131

    condition_operator             shift and go to state 135

state 92

    (78) condition -> booleanOp . condition_operator booleanOp
    (66) condition_operator -> . DOUBLEQUAL
    (67) condition_operator -> . LESSTHAN
    (68) condition_operator -> . GREATERTHAN
    (69) condition_operator -> . LESSTHAN EQUAL
    (70) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 129
    LESSTHAN        shift and go to state 130
    GREATERTHAN     shift and go to state 131

    condition_operator             shift and go to state 136

state 93

    (71) number -> FLOAT .

    DOUBLEQUAL      reduce using rule 71 (number -> FLOAT .)
    LESSTHAN        reduce using rule 71 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 71 (number -> FLOAT .)
    SEMICOLON       reduce using rule 71 (number -> FLOAT .)
    RPAREN          reduce using rule 71 (number -> FLOAT .)
    PLUS            reduce using rule 71 (number -> FLOAT .)
    MINUS           reduce using rule 71 (number -> FLOAT .)
    TIMES           reduce using rule 71 (number -> FLOAT .)
    DIVISION        reduce using rule 71 (number -> FLOAT .)
    AND             reduce using rule 71 (number -> FLOAT .)
    OR              reduce using rule 71 (number -> FLOAT .)
    AMPERSAND       reduce using rule 71 (number -> FLOAT .)
    PIPELINE        reduce using rule 71 (number -> FLOAT .)


state 94

    (72) number -> INTEGER .

    DOUBLEQUAL      reduce using rule 72 (number -> INTEGER .)
    LESSTHAN        reduce using rule 72 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 72 (number -> INTEGER .)
    SEMICOLON       reduce using rule 72 (number -> INTEGER .)
    RPAREN          reduce using rule 72 (number -> INTEGER .)
    PLUS            reduce using rule 72 (number -> INTEGER .)
    MINUS           reduce using rule 72 (number -> INTEGER .)
    TIMES           reduce using rule 72 (number -> INTEGER .)
    DIVISION        reduce using rule 72 (number -> INTEGER .)
    AND             reduce using rule 72 (number -> INTEGER .)
    OR              reduce using rule 72 (number -> INTEGER .)
    AMPERSAND       reduce using rule 72 (number -> INTEGER .)
    PIPELINE        reduce using rule 72 (number -> INTEGER .)


state 95

    (44) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> FINAL IDENTIFIER EQUAL . STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    STACK           shift and go to state 137


state 96

    (95) expression -> operableTypes operatorExpression operableTypes .

    SEMICOLON       reduce using rule 95 (expression -> operableTypes operatorExpression operableTypes .)
    RPAREN          reduce using rule 95 (expression -> operableTypes operatorExpression operableTypes .)


state 97

    (97) expression -> operableTypes operatorExpression operatorExpression .

    SEMICOLON       reduce using rule 97 (expression -> operableTypes operatorExpression operatorExpression .)
    RPAREN          reduce using rule 97 (expression -> operableTypes operatorExpression operatorExpression .)


state 98

    (98) operableTypes -> IDENTIFIER .

    SEMICOLON       reduce using rule 98 (operableTypes -> IDENTIFIER .)
    RPAREN          reduce using rule 98 (operableTypes -> IDENTIFIER .)


state 99

    (106) semanticbool -> BOOL IDENTIFIER EQUAL . booleanOp SEMICOLON
    (107) semanticbool -> BOOL IDENTIFIER EQUAL . booloperations SEMICOLON
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE
    (114) booloperations -> . booloperation
    (115) booloperations -> . booloperation condition_connector booloperations
    (110) booloperation -> . booleanOp condition_connector booleanOp
    (111) booloperation -> . IDENTIFIER condition_connector booleanOp
    (112) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (113) booloperation -> . booleanOp condition_connector IDENTIFIER

    TRUE            shift and go to state 41
    FALSE           shift and go to state 42
    IDENTIFIER      shift and go to state 138

    booleanOp                      shift and go to state 139
    booloperations                 shift and go to state 140
    booloperation                  shift and go to state 141

state 100

    (116) semanticlist -> LIST LESSTHAN DYNAMIC . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 142


state 101

    (117) semanticlist -> LIST LESSTHAN INT . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 143


state 102

    (118) semanticlist -> LIST LESSTHAN STRING . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 144


state 103

    (119) semanticlist -> LIST LESSTHAN BOOL . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 145


state 104

    (120) semanticlist -> LIST LESSTHAN DOUBLE . GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    GREATERTHAN     shift and go to state 146


state 105

    (18) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 147


state 106

    (40) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 148


state 107

    (15) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (29) map_content -> . map_pairs
    (30) map_content -> . empty
    (32) map_pairs -> . map_pair
    (33) map_pairs -> . map_pair COMMA map_pairs
    (28) empty -> .
    (31) map_pair -> . map_key COLON map_value
    (34) map_key -> . value
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    RCURLYBRACKET   reduce using rule 28 (empty -> .)
    INTEGER         shift and go to state 156
    FLOAT           shift and go to state 157
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    IDENTIFIER      shift and go to state 149
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    map_content                    shift and go to state 150
    map_pairs                      shift and go to state 151
    empty                          shift and go to state 152
    map_pair                       shift and go to state 153
    map_key                        shift and go to state 154
    value                          shift and go to state 155
    booleanOp                      shift and go to state 27

state 108

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN . LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 158


state 109

    (89) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (88) function_arguments_repeat -> . function_argument
    (89) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (86) function_argument -> . datatype IDENTIFIER
    (87) function_argument -> . empty
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (28) empty -> .
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 34
    COMMA           reduce using rule 28 (empty -> .)
    RPAREN          reduce using rule 28 (empty -> .)
    LCURLYBRACKET   reduce using rule 28 (empty -> .)
    INT             shift and go to state 71
    STRING          shift and go to state 72
    BOOL            shift and go to state 73
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    MAP             shift and go to state 31

    function_argument              shift and go to state 68
    function_arguments_repeat      shift and go to state 159
    datatype                       shift and go to state 69
    empty                          shift and go to state 70
    returnType                     shift and go to state 33
    map_identifier                 shift and go to state 74

state 110

    (86) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 86 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 86 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 86 (function_argument -> datatype IDENTIFIER .)


state 111

    (42) elifStatement -> ELSE LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (12) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . semanticbool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (85) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (106) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (116) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    RCURLYBRACKET   shift and go to state 160
    STRING          shift and go to state 19
    INT             shift and go to state 20
    FOR             shift and go to state 21
    WHILE           shift and go to state 22
    FINAL           shift and go to state 23
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 26
    LIST            shift and go to state 28
    MAP             shift and go to state 31
    IF              shift and go to state 32
    VAR             shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    class_content                  shift and go to state 43
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    semanticbool                   shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    booleanOp                      shift and go to state 27
    returnType                     shift and go to state 33
    number                         shift and go to state 35

state 112

    (85) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (90) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (91) optFunction_argumentsExpression -> . empty
    (28) empty -> .

    LCURLYBRACKET   shift and go to state 162
    RPAREN          reduce using rule 28 (empty -> .)

    optFunction_argumentsExpression shift and go to state 161
    empty                          shift and go to state 163

state 113

    (98) operableTypes -> IDENTIFIER .
    (53) value -> IDENTIFIER .

    PLUS            reduce using rule 98 (operableTypes -> IDENTIFIER .)
    MINUS           reduce using rule 98 (operableTypes -> IDENTIFIER .)
    TIMES           reduce using rule 98 (operableTypes -> IDENTIFIER .)
    DIVISION        reduce using rule 98 (operableTypes -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (value -> IDENTIFIER .)


state 114

    (105) declarationExpression -> datatype IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 164


state 115

    (131) declarationExpression -> STRING IDENTIFIER EQUAL expressionString . SEMICOLON

    SEMICOLON       shift and go to state 165


state 116

    (132) expressionString -> STR .
    (133) expressionString -> STR . operatorExpressionString expressionString
    (134) operatorExpressionString -> . PLUS

    SEMICOLON       reduce using rule 132 (expressionString -> STR .)
    PLUS            shift and go to state 167

    operatorExpressionString       shift and go to state 166

state 117

    (138) expressionInteger -> IDENTIFIER .
    (139) expressionInteger -> IDENTIFIER . operatorExpression expressionInteger
    (100) operatorExpression -> . PLUS
    (101) operatorExpression -> . MINUS
    (102) operatorExpression -> . TIMES
    (103) operatorExpression -> . DIVISION

    SEMICOLON       reduce using rule 138 (expressionInteger -> IDENTIFIER .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVISION        shift and go to state 60

    operatorExpression             shift and go to state 168

state 118

    (135) declarationExpression -> INT IDENTIFIER EQUAL expressionInteger . SEMICOLON

    SEMICOLON       shift and go to state 169


state 119

    (136) expressionInteger -> number .
    (137) expressionInteger -> number . operatorExpression expressionInteger
    (100) operatorExpression -> . PLUS
    (101) operatorExpression -> . MINUS
    (102) operatorExpression -> . TIMES
    (103) operatorExpression -> . DIVISION

    SEMICOLON       reduce using rule 136 (expressionInteger -> number .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVISION        shift and go to state 60

    operatorExpression             shift and go to state 170

state 120

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON . condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (73) condition -> . IDENTIFIER condition_operator condition_values
    (74) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (75) condition -> . BOOLEAN condition_operator BOOLEAN
    (76) condition -> . number condition_operator number
    (77) condition -> . STR condition_operator STR
    (78) condition -> . booleanOp condition_operator booleanOp
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 87
    EXMARK          shift and go to state 88
    BOOLEAN         shift and go to state 89
    STR             shift and go to state 91
    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    condition                      shift and go to state 171
    number                         shift and go to state 90
    booleanOp                      shift and go to state 92

state 121

    (104) declarationExpression -> datatype IDENTIFIER . SEMICOLON
    (105) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON

    SEMICOLON       shift and go to state 80
    EQUAL           shift and go to state 79


state 122

    (45) while -> WHILE LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 172


state 123

    (80) conditions -> condition condition_connector . conditions
    (79) conditions -> . condition
    (80) conditions -> . condition condition_connector conditions
    (73) condition -> . IDENTIFIER condition_operator condition_values
    (74) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (75) condition -> . BOOLEAN condition_operator BOOLEAN
    (76) condition -> . number condition_operator number
    (77) condition -> . STR condition_operator STR
    (78) condition -> . booleanOp condition_operator booleanOp
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 87
    EXMARK          shift and go to state 88
    BOOLEAN         shift and go to state 89
    STR             shift and go to state 91
    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    condition                      shift and go to state 86
    conditions                     shift and go to state 173
    number                         shift and go to state 90
    booleanOp                      shift and go to state 92

state 124

    (81) condition_connector -> AND .

    IDENTIFIER      reduce using rule 81 (condition_connector -> AND .)
    EXMARK          reduce using rule 81 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 81 (condition_connector -> AND .)
    STR             reduce using rule 81 (condition_connector -> AND .)
    FLOAT           reduce using rule 81 (condition_connector -> AND .)
    INTEGER         reduce using rule 81 (condition_connector -> AND .)
    TRUE            reduce using rule 81 (condition_connector -> AND .)
    FALSE           reduce using rule 81 (condition_connector -> AND .)


state 125

    (82) condition_connector -> OR .

    IDENTIFIER      reduce using rule 82 (condition_connector -> OR .)
    EXMARK          reduce using rule 82 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 82 (condition_connector -> OR .)
    STR             reduce using rule 82 (condition_connector -> OR .)
    FLOAT           reduce using rule 82 (condition_connector -> OR .)
    INTEGER         reduce using rule 82 (condition_connector -> OR .)
    TRUE            reduce using rule 82 (condition_connector -> OR .)
    FALSE           reduce using rule 82 (condition_connector -> OR .)


state 126

    (83) condition_connector -> AMPERSAND . AMPERSAND

    AMPERSAND       shift and go to state 174


state 127

    (84) condition_connector -> PIPELINE . PIPELINE

    PIPELINE        shift and go to state 175


state 128

    (73) condition -> IDENTIFIER condition_operator . condition_values
    (62) condition_values -> . negation_values
    (63) condition_values -> . INTEGER
    (64) condition_values -> . FLOAT
    (65) condition_values -> . STR
    (60) negation_values -> . deniable_values
    (61) negation_values -> . EXMARK deniable_values
    (57) deniable_values -> . IDENTIFIER
    (58) deniable_values -> . BOOLEAN
    (59) deniable_values -> . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    INTEGER         shift and go to state 179
    FLOAT           shift and go to state 180
    STR             shift and go to state 181
    EXMARK          shift and go to state 183
    IDENTIFIER      shift and go to state 176
    BOOLEAN         shift and go to state 184
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    condition_values               shift and go to state 177
    negation_values                shift and go to state 178
    deniable_values                shift and go to state 182
    booleanOp                      shift and go to state 185

state 129

    (66) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 66 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 66 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 66 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 66 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 66 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 66 (condition_operator -> DOUBLEQUAL .)
    TRUE            reduce using rule 66 (condition_operator -> DOUBLEQUAL .)
    FALSE           reduce using rule 66 (condition_operator -> DOUBLEQUAL .)


state 130

    (67) condition_operator -> LESSTHAN .
    (69) condition_operator -> LESSTHAN . EQUAL

    INTEGER         reduce using rule 67 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 67 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 67 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 67 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 67 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 67 (condition_operator -> LESSTHAN .)
    TRUE            reduce using rule 67 (condition_operator -> LESSTHAN .)
    FALSE           reduce using rule 67 (condition_operator -> LESSTHAN .)
    EQUAL           shift and go to state 186


state 131

    (68) condition_operator -> GREATERTHAN .
    (70) condition_operator -> GREATERTHAN . EQUAL

    INTEGER         reduce using rule 68 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 68 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 68 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 68 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 68 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 68 (condition_operator -> GREATERTHAN .)
    TRUE            reduce using rule 68 (condition_operator -> GREATERTHAN .)
    FALSE           reduce using rule 68 (condition_operator -> GREATERTHAN .)
    EQUAL           shift and go to state 187


state 132

    (74) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (66) condition_operator -> . DOUBLEQUAL
    (67) condition_operator -> . LESSTHAN
    (68) condition_operator -> . GREATERTHAN
    (69) condition_operator -> . LESSTHAN EQUAL
    (70) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 129
    LESSTHAN        shift and go to state 130
    GREATERTHAN     shift and go to state 131

    condition_operator             shift and go to state 188

state 133

    (75) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 189


state 134

    (76) condition -> number condition_operator . number
    (71) number -> . FLOAT
    (72) number -> . INTEGER

    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94

    number                         shift and go to state 190

state 135

    (77) condition -> STR condition_operator . STR

    STR             shift and go to state 191


state 136

    (78) condition -> booleanOp condition_operator . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    booleanOp                      shift and go to state 192

state 137

    (44) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> FINAL IDENTIFIER EQUAL STACK . DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    LESSTHAN        shift and go to state 193
    DOT             shift and go to state 194


state 138

    (111) booloperation -> IDENTIFIER . condition_connector booleanOp
    (112) booloperation -> IDENTIFIER . condition_connector IDENTIFIER
    (81) condition_connector -> . AND
    (82) condition_connector -> . OR
    (83) condition_connector -> . AMPERSAND AMPERSAND
    (84) condition_connector -> . PIPELINE PIPELINE

    AND             shift and go to state 124
    OR              shift and go to state 125
    AMPERSAND       shift and go to state 126
    PIPELINE        shift and go to state 127

    condition_connector            shift and go to state 195

state 139

    (106) semanticbool -> BOOL IDENTIFIER EQUAL booleanOp . SEMICOLON
    (110) booloperation -> booleanOp . condition_connector booleanOp
    (113) booloperation -> booleanOp . condition_connector IDENTIFIER
    (81) condition_connector -> . AND
    (82) condition_connector -> . OR
    (83) condition_connector -> . AMPERSAND AMPERSAND
    (84) condition_connector -> . PIPELINE PIPELINE

    SEMICOLON       shift and go to state 196
    AND             shift and go to state 124
    OR              shift and go to state 125
    AMPERSAND       shift and go to state 126
    PIPELINE        shift and go to state 127

    condition_connector            shift and go to state 197

state 140

    (107) semanticbool -> BOOL IDENTIFIER EQUAL booloperations . SEMICOLON

    SEMICOLON       shift and go to state 198


state 141

    (114) booloperations -> booloperation .
    (115) booloperations -> booloperation . condition_connector booloperations
    (81) condition_connector -> . AND
    (82) condition_connector -> . OR
    (83) condition_connector -> . AMPERSAND AMPERSAND
    (84) condition_connector -> . PIPELINE PIPELINE

    SEMICOLON       reduce using rule 114 (booloperations -> booloperation .)
    AND             shift and go to state 124
    OR              shift and go to state 125
    AMPERSAND       shift and go to state 126
    PIPELINE        shift and go to state 127

    condition_connector            shift and go to state 199

state 142

    (116) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 200


state 143

    (117) semanticlist -> LIST LESSTHAN INT GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 201


state 144

    (118) semanticlist -> LIST LESSTHAN STRING GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 202


state 145

    (119) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 203


state 146

    (120) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN . IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 204


state 147

    (18) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 34
    INT             shift and go to state 71
    STRING          shift and go to state 72
    BOOL            shift and go to state 73
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    MAP             shift and go to state 31

    datatype                       shift and go to state 205
    returnType                     shift and go to state 33
    map_identifier                 shift and go to state 74

state 148

    (40) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 206


state 149

    (53) value -> IDENTIFIER .

    COLON           reduce using rule 53 (value -> IDENTIFIER .)
    COMMA           reduce using rule 53 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 53 (value -> IDENTIFIER .)
    RSQUAREBRACKET  reduce using rule 53 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (value -> IDENTIFIER .)


state 150

    (15) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 207


state 151

    (29) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 29 (map_content -> map_pairs .)


state 152

    (30) map_content -> empty .

    RCURLYBRACKET   reduce using rule 30 (map_content -> empty .)


state 153

    (32) map_pairs -> map_pair .
    (33) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 32 (map_pairs -> map_pair .)
    COMMA           shift and go to state 208


state 154

    (31) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 209


state 155

    (34) map_key -> value .

    COLON           reduce using rule 34 (map_key -> value .)


state 156

    (49) value -> INTEGER .

    COLON           reduce using rule 49 (value -> INTEGER .)
    COMMA           reduce using rule 49 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 49 (value -> INTEGER .)
    RSQUAREBRACKET  reduce using rule 49 (value -> INTEGER .)
    RPAREN          reduce using rule 49 (value -> INTEGER .)


state 157

    (50) value -> FLOAT .

    COLON           reduce using rule 50 (value -> FLOAT .)
    COMMA           reduce using rule 50 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 50 (value -> FLOAT .)
    RSQUAREBRACKET  reduce using rule 50 (value -> FLOAT .)
    RPAREN          reduce using rule 50 (value -> FLOAT .)


state 158

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET . RETURN expression SEMICOLON RCURLYBRACKET

    RETURN          shift and go to state 210


state 159

    (89) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    RPAREN          reduce using rule 89 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    LCURLYBRACKET   reduce using rule 89 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 160

    (42) elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 42 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 161

    (85) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 211


state 162

    (90) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (93) optFunction_arguments -> . optFunction_argument
    (94) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (92) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 214

    optFunction_arguments          shift and go to state 212
    optFunction_argument           shift and go to state 213

state 163

    (91) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 91 (optFunction_argumentsExpression -> empty .)


state 164

    (105) declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .

    STRING          reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FOR             reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    LIST            reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    TRUE            reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FALSE           reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 105 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)


state 165

    (131) declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .

    STRING          reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    INT             reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FOR             reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    WHILE           reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FINAL           reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    IDENTIFIER      reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    BOOL            reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    LIST            reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    MAP             reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    IF              reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    VAR             reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    INTEGER         reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FLOAT           reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    STR             reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    BOOLEAN         reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    DOUBLE          reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    DYNAMIC         reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    VOID            reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    TRUE            reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    FALSE           reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    $end            reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    SEMICOLON       reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)
    RCURLYBRACKET   reduce using rule 131 (declarationExpression -> STRING IDENTIFIER EQUAL expressionString SEMICOLON .)


state 166

    (133) expressionString -> STR operatorExpressionString . expressionString
    (132) expressionString -> . STR
    (133) expressionString -> . STR operatorExpressionString expressionString

    STR             shift and go to state 116

    expressionString               shift and go to state 215

state 167

    (134) operatorExpressionString -> PLUS .

    STR             reduce using rule 134 (operatorExpressionString -> PLUS .)


state 168

    (139) expressionInteger -> IDENTIFIER operatorExpression . expressionInteger
    (136) expressionInteger -> . number
    (137) expressionInteger -> . number operatorExpression expressionInteger
    (138) expressionInteger -> . IDENTIFIER
    (139) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (71) number -> . FLOAT
    (72) number -> . INTEGER

    IDENTIFIER      shift and go to state 117
    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94

    expressionInteger              shift and go to state 216
    number                         shift and go to state 119

state 169

    (135) declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .

    STRING          reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    INT             reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FOR             reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    WHILE           reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FINAL           reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    IDENTIFIER      reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    BOOL            reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    LIST            reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    MAP             reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    IF              reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    VAR             reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    INTEGER         reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FLOAT           reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    STR             reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    BOOLEAN         reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    DOUBLE          reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    DYNAMIC         reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    VOID            reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    TRUE            reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    FALSE           reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    $end            reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    SEMICOLON       reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)
    RCURLYBRACKET   reduce using rule 135 (declarationExpression -> INT IDENTIFIER EQUAL expressionInteger SEMICOLON .)


state 170

    (137) expressionInteger -> number operatorExpression . expressionInteger
    (136) expressionInteger -> . number
    (137) expressionInteger -> . number operatorExpression expressionInteger
    (138) expressionInteger -> . IDENTIFIER
    (139) expressionInteger -> . IDENTIFIER operatorExpression expressionInteger
    (71) number -> . FLOAT
    (72) number -> . INTEGER

    IDENTIFIER      shift and go to state 117
    FLOAT           shift and go to state 93
    INTEGER         shift and go to state 94

    number                         shift and go to state 119
    expressionInteger              shift and go to state 217

state 171

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition . SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET

    SEMICOLON       shift and go to state 218


state 172

    (45) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (11) class_content_repeat -> . class_content
    (12) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . semanticbool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (85) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (106) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (116) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    STRING          shift and go to state 19
    INT             shift and go to state 20
    FOR             shift and go to state 21
    WHILE           shift and go to state 22
    FINAL           shift and go to state 23
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 26
    LIST            shift and go to state 28
    MAP             shift and go to state 31
    IF              shift and go to state 32
    VAR             shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    class_content_repeat           shift and go to state 219
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    semanticbool                   shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    booleanOp                      shift and go to state 27
    returnType                     shift and go to state 33
    number                         shift and go to state 35

state 173

    (80) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 80 (conditions -> condition condition_connector conditions .)


state 174

    (83) condition_connector -> AMPERSAND AMPERSAND .

    IDENTIFIER      reduce using rule 83 (condition_connector -> AMPERSAND AMPERSAND .)
    EXMARK          reduce using rule 83 (condition_connector -> AMPERSAND AMPERSAND .)
    BOOLEAN         reduce using rule 83 (condition_connector -> AMPERSAND AMPERSAND .)
    STR             reduce using rule 83 (condition_connector -> AMPERSAND AMPERSAND .)
    FLOAT           reduce using rule 83 (condition_connector -> AMPERSAND AMPERSAND .)
    INTEGER         reduce using rule 83 (condition_connector -> AMPERSAND AMPERSAND .)
    TRUE            reduce using rule 83 (condition_connector -> AMPERSAND AMPERSAND .)
    FALSE           reduce using rule 83 (condition_connector -> AMPERSAND AMPERSAND .)


state 175

    (84) condition_connector -> PIPELINE PIPELINE .

    IDENTIFIER      reduce using rule 84 (condition_connector -> PIPELINE PIPELINE .)
    EXMARK          reduce using rule 84 (condition_connector -> PIPELINE PIPELINE .)
    BOOLEAN         reduce using rule 84 (condition_connector -> PIPELINE PIPELINE .)
    STR             reduce using rule 84 (condition_connector -> PIPELINE PIPELINE .)
    FLOAT           reduce using rule 84 (condition_connector -> PIPELINE PIPELINE .)
    INTEGER         reduce using rule 84 (condition_connector -> PIPELINE PIPELINE .)
    TRUE            reduce using rule 84 (condition_connector -> PIPELINE PIPELINE .)
    FALSE           reduce using rule 84 (condition_connector -> PIPELINE PIPELINE .)


state 176

    (57) deniable_values -> IDENTIFIER .

    AND             reduce using rule 57 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 57 (deniable_values -> IDENTIFIER .)
    AMPERSAND       reduce using rule 57 (deniable_values -> IDENTIFIER .)
    PIPELINE        reduce using rule 57 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 57 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 57 (deniable_values -> IDENTIFIER .)


state 177

    (73) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 73 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 73 (condition -> IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 73 (condition -> IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 73 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 73 (condition -> IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 73 (condition -> IDENTIFIER condition_operator condition_values .)


state 178

    (62) condition_values -> negation_values .

    AND             reduce using rule 62 (condition_values -> negation_values .)
    OR              reduce using rule 62 (condition_values -> negation_values .)
    AMPERSAND       reduce using rule 62 (condition_values -> negation_values .)
    PIPELINE        reduce using rule 62 (condition_values -> negation_values .)
    RPAREN          reduce using rule 62 (condition_values -> negation_values .)
    SEMICOLON       reduce using rule 62 (condition_values -> negation_values .)


state 179

    (63) condition_values -> INTEGER .

    AND             reduce using rule 63 (condition_values -> INTEGER .)
    OR              reduce using rule 63 (condition_values -> INTEGER .)
    AMPERSAND       reduce using rule 63 (condition_values -> INTEGER .)
    PIPELINE        reduce using rule 63 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 63 (condition_values -> INTEGER .)
    SEMICOLON       reduce using rule 63 (condition_values -> INTEGER .)


state 180

    (64) condition_values -> FLOAT .

    AND             reduce using rule 64 (condition_values -> FLOAT .)
    OR              reduce using rule 64 (condition_values -> FLOAT .)
    AMPERSAND       reduce using rule 64 (condition_values -> FLOAT .)
    PIPELINE        reduce using rule 64 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 64 (condition_values -> FLOAT .)
    SEMICOLON       reduce using rule 64 (condition_values -> FLOAT .)


state 181

    (65) condition_values -> STR .

    AND             reduce using rule 65 (condition_values -> STR .)
    OR              reduce using rule 65 (condition_values -> STR .)
    AMPERSAND       reduce using rule 65 (condition_values -> STR .)
    PIPELINE        reduce using rule 65 (condition_values -> STR .)
    RPAREN          reduce using rule 65 (condition_values -> STR .)
    SEMICOLON       reduce using rule 65 (condition_values -> STR .)


state 182

    (60) negation_values -> deniable_values .

    AND             reduce using rule 60 (negation_values -> deniable_values .)
    OR              reduce using rule 60 (negation_values -> deniable_values .)
    AMPERSAND       reduce using rule 60 (negation_values -> deniable_values .)
    PIPELINE        reduce using rule 60 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 60 (negation_values -> deniable_values .)
    SEMICOLON       reduce using rule 60 (negation_values -> deniable_values .)


state 183

    (61) negation_values -> EXMARK . deniable_values
    (57) deniable_values -> . IDENTIFIER
    (58) deniable_values -> . BOOLEAN
    (59) deniable_values -> . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 176
    BOOLEAN         shift and go to state 184
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    deniable_values                shift and go to state 220
    booleanOp                      shift and go to state 185

state 184

    (58) deniable_values -> BOOLEAN .

    AND             reduce using rule 58 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 58 (deniable_values -> BOOLEAN .)
    AMPERSAND       reduce using rule 58 (deniable_values -> BOOLEAN .)
    PIPELINE        reduce using rule 58 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 58 (deniable_values -> BOOLEAN .)
    SEMICOLON       reduce using rule 58 (deniable_values -> BOOLEAN .)


state 185

    (59) deniable_values -> booleanOp .

    AND             reduce using rule 59 (deniable_values -> booleanOp .)
    OR              reduce using rule 59 (deniable_values -> booleanOp .)
    AMPERSAND       reduce using rule 59 (deniable_values -> booleanOp .)
    PIPELINE        reduce using rule 59 (deniable_values -> booleanOp .)
    RPAREN          reduce using rule 59 (deniable_values -> booleanOp .)
    SEMICOLON       reduce using rule 59 (deniable_values -> booleanOp .)


state 186

    (69) condition_operator -> LESSTHAN EQUAL .

    INTEGER         reduce using rule 69 (condition_operator -> LESSTHAN EQUAL .)
    FLOAT           reduce using rule 69 (condition_operator -> LESSTHAN EQUAL .)
    STR             reduce using rule 69 (condition_operator -> LESSTHAN EQUAL .)
    EXMARK          reduce using rule 69 (condition_operator -> LESSTHAN EQUAL .)
    IDENTIFIER      reduce using rule 69 (condition_operator -> LESSTHAN EQUAL .)
    BOOLEAN         reduce using rule 69 (condition_operator -> LESSTHAN EQUAL .)
    TRUE            reduce using rule 69 (condition_operator -> LESSTHAN EQUAL .)
    FALSE           reduce using rule 69 (condition_operator -> LESSTHAN EQUAL .)


state 187

    (70) condition_operator -> GREATERTHAN EQUAL .

    INTEGER         reduce using rule 70 (condition_operator -> GREATERTHAN EQUAL .)
    FLOAT           reduce using rule 70 (condition_operator -> GREATERTHAN EQUAL .)
    STR             reduce using rule 70 (condition_operator -> GREATERTHAN EQUAL .)
    EXMARK          reduce using rule 70 (condition_operator -> GREATERTHAN EQUAL .)
    IDENTIFIER      reduce using rule 70 (condition_operator -> GREATERTHAN EQUAL .)
    BOOLEAN         reduce using rule 70 (condition_operator -> GREATERTHAN EQUAL .)
    TRUE            reduce using rule 70 (condition_operator -> GREATERTHAN EQUAL .)
    FALSE           reduce using rule 70 (condition_operator -> GREATERTHAN EQUAL .)


state 188

    (74) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (62) condition_values -> . negation_values
    (63) condition_values -> . INTEGER
    (64) condition_values -> . FLOAT
    (65) condition_values -> . STR
    (60) negation_values -> . deniable_values
    (61) negation_values -> . EXMARK deniable_values
    (57) deniable_values -> . IDENTIFIER
    (58) deniable_values -> . BOOLEAN
    (59) deniable_values -> . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    INTEGER         shift and go to state 179
    FLOAT           shift and go to state 180
    STR             shift and go to state 181
    EXMARK          shift and go to state 183
    IDENTIFIER      shift and go to state 176
    BOOLEAN         shift and go to state 184
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    condition_values               shift and go to state 221
    negation_values                shift and go to state 178
    deniable_values                shift and go to state 182
    booleanOp                      shift and go to state 185

state 189

    (75) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 75 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 75 (condition -> BOOLEAN condition_operator BOOLEAN .)
    AMPERSAND       reduce using rule 75 (condition -> BOOLEAN condition_operator BOOLEAN .)
    PIPELINE        reduce using rule 75 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 75 (condition -> BOOLEAN condition_operator BOOLEAN .)
    SEMICOLON       reduce using rule 75 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 190

    (76) condition -> number condition_operator number .

    AND             reduce using rule 76 (condition -> number condition_operator number .)
    OR              reduce using rule 76 (condition -> number condition_operator number .)
    AMPERSAND       reduce using rule 76 (condition -> number condition_operator number .)
    PIPELINE        reduce using rule 76 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 76 (condition -> number condition_operator number .)
    SEMICOLON       reduce using rule 76 (condition -> number condition_operator number .)


state 191

    (77) condition -> STR condition_operator STR .

    AND             reduce using rule 77 (condition -> STR condition_operator STR .)
    OR              reduce using rule 77 (condition -> STR condition_operator STR .)
    AMPERSAND       reduce using rule 77 (condition -> STR condition_operator STR .)
    PIPELINE        reduce using rule 77 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 77 (condition -> STR condition_operator STR .)
    SEMICOLON       reduce using rule 77 (condition -> STR condition_operator STR .)


state 192

    (78) condition -> booleanOp condition_operator booleanOp .

    AND             reduce using rule 78 (condition -> booleanOp condition_operator booleanOp .)
    OR              reduce using rule 78 (condition -> booleanOp condition_operator booleanOp .)
    AMPERSAND       reduce using rule 78 (condition -> booleanOp condition_operator booleanOp .)
    PIPELINE        reduce using rule 78 (condition -> booleanOp condition_operator booleanOp .)
    RPAREN          reduce using rule 78 (condition -> booleanOp condition_operator booleanOp .)
    SEMICOLON       reduce using rule 78 (condition -> booleanOp condition_operator booleanOp .)


state 193

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 34
    INT             shift and go to state 71
    STRING          shift and go to state 72
    BOOL            shift and go to state 73
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    MAP             shift and go to state 31

    datatype                       shift and go to state 222
    returnType                     shift and go to state 33
    map_identifier                 shift and go to state 74

state 194

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT . OF LPAREN IDENTIFIER RPAREN SEMICOLON

    OF              shift and go to state 223


state 195

    (111) booloperation -> IDENTIFIER condition_connector . booleanOp
    (112) booloperation -> IDENTIFIER condition_connector . IDENTIFIER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 224
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    booleanOp                      shift and go to state 225

state 196

    (106) semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .

    STRING          reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    INT             reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    FOR             reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    WHILE           reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    FINAL           reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    IDENTIFIER      reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    BOOL            reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    LIST            reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    MAP             reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    IF              reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    VAR             reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    INTEGER         reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    FLOAT           reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    STR             reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    BOOLEAN         reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    DOUBLE          reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    DYNAMIC         reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    VOID            reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    TRUE            reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    FALSE           reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    $end            reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)
    RCURLYBRACKET   reduce using rule 106 (semanticbool -> BOOL IDENTIFIER EQUAL booleanOp SEMICOLON .)


state 197

    (110) booloperation -> booleanOp condition_connector . booleanOp
    (113) booloperation -> booleanOp condition_connector . IDENTIFIER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 227
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    booleanOp                      shift and go to state 226

state 198

    (107) semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .

    STRING          reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    INT             reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    FOR             reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    WHILE           reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    FINAL           reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    IDENTIFIER      reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    BOOL            reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    LIST            reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    MAP             reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    IF              reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    VAR             reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    INTEGER         reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    FLOAT           reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    STR             reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    BOOLEAN         reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    DOUBLE          reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    DYNAMIC         reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    VOID            reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    TRUE            reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    FALSE           reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    $end            reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)
    RCURLYBRACKET   reduce using rule 107 (semanticbool -> BOOL IDENTIFIER EQUAL booloperations SEMICOLON .)


state 199

    (115) booloperations -> booloperation condition_connector . booloperations
    (114) booloperations -> . booloperation
    (115) booloperations -> . booloperation condition_connector booloperations
    (110) booloperation -> . booleanOp condition_connector booleanOp
    (111) booloperation -> . IDENTIFIER condition_connector booleanOp
    (112) booloperation -> . IDENTIFIER condition_connector IDENTIFIER
    (113) booloperation -> . booleanOp condition_connector IDENTIFIER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 138
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    booloperation                  shift and go to state 141
    booloperations                 shift and go to state 228
    booleanOp                      shift and go to state 229

state 200

    (116) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 230


state 201

    (117) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 231


state 202

    (118) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 232


state 203

    (119) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 233


state 204

    (120) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER . EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    EQUAL           shift and go to state 234


state 205

    (18) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 235


state 206

    (40) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (11) class_content_repeat -> . class_content
    (12) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . semanticbool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (85) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (106) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (116) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    STRING          shift and go to state 19
    INT             shift and go to state 20
    FOR             shift and go to state 21
    WHILE           shift and go to state 22
    FINAL           shift and go to state 23
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 26
    LIST            shift and go to state 28
    MAP             shift and go to state 31
    IF              shift and go to state 32
    VAR             shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    class_content_repeat           shift and go to state 236
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    semanticbool                   shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    booleanOp                      shift and go to state 27
    returnType                     shift and go to state 33
    number                         shift and go to state 35

state 207

    (15) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 237


state 208

    (33) map_pairs -> map_pair COMMA . map_pairs
    (32) map_pairs -> . map_pair
    (33) map_pairs -> . map_pair COMMA map_pairs
    (31) map_pair -> . map_key COLON map_value
    (34) map_key -> . value
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    INTEGER         shift and go to state 156
    FLOAT           shift and go to state 157
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    IDENTIFIER      shift and go to state 149
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    map_pair                       shift and go to state 153
    map_pairs                      shift and go to state 238
    map_key                        shift and go to state 154
    value                          shift and go to state 155
    booleanOp                      shift and go to state 27

state 209

    (31) map_pair -> map_key COLON . map_value
    (35) map_value -> . value
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    INTEGER         shift and go to state 156
    FLOAT           shift and go to state 157
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    IDENTIFIER      shift and go to state 149
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    map_value                      shift and go to state 239
    value                          shift and go to state 240
    booleanOp                      shift and go to state 27

state 210

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN . expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 113
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    expression                     shift and go to state 241
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    number                         shift and go to state 35
    booleanOp                      shift and go to state 27

state 211

    (85) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 242


state 212

    (90) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 243


state 213

    (93) optFunction_arguments -> optFunction_argument .
    (94) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 93 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 244


state 214

    (92) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 34
    INT             shift and go to state 71
    STRING          shift and go to state 72
    BOOL            shift and go to state 73
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    MAP             shift and go to state 31

    datatype                       shift and go to state 245
    returnType                     shift and go to state 33
    map_identifier                 shift and go to state 74

state 215

    (133) expressionString -> STR operatorExpressionString expressionString .

    SEMICOLON       reduce using rule 133 (expressionString -> STR operatorExpressionString expressionString .)


state 216

    (139) expressionInteger -> IDENTIFIER operatorExpression expressionInteger .

    SEMICOLON       reduce using rule 139 (expressionInteger -> IDENTIFIER operatorExpression expressionInteger .)


state 217

    (137) expressionInteger -> number operatorExpression expressionInteger .

    SEMICOLON       reduce using rule 137 (expressionInteger -> number operatorExpression expressionInteger .)


state 218

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON . expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 113
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    expression                     shift and go to state 246
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    number                         shift and go to state 35
    booleanOp                      shift and go to state 27

state 219

    (45) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (12) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . semanticbool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (85) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (106) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (116) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    RCURLYBRACKET   shift and go to state 247
    STRING          shift and go to state 19
    INT             shift and go to state 20
    FOR             shift and go to state 21
    WHILE           shift and go to state 22
    FINAL           shift and go to state 23
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 26
    LIST            shift and go to state 28
    MAP             shift and go to state 31
    IF              shift and go to state 32
    VAR             shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    class_content                  shift and go to state 43
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    semanticbool                   shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    booleanOp                      shift and go to state 27
    returnType                     shift and go to state 33
    number                         shift and go to state 35

state 220

    (61) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 61 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 61 (negation_values -> EXMARK deniable_values .)
    AMPERSAND       reduce using rule 61 (negation_values -> EXMARK deniable_values .)
    PIPELINE        reduce using rule 61 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 61 (negation_values -> EXMARK deniable_values .)
    SEMICOLON       reduce using rule 61 (negation_values -> EXMARK deniable_values .)


state 221

    (74) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 74 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 74 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    AMPERSAND       reduce using rule 74 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    PIPELINE        reduce using rule 74 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 74 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 74 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 222

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN RPAREN SEMICOLON

    GREATERTHAN     shift and go to state 248


state 223

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF . LPAREN IDENTIFIER RPAREN SEMICOLON

    LPAREN          shift and go to state 249


state 224

    (112) booloperation -> IDENTIFIER condition_connector IDENTIFIER .

    AND             reduce using rule 112 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    OR              reduce using rule 112 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    AMPERSAND       reduce using rule 112 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    PIPELINE        reduce using rule 112 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)
    SEMICOLON       reduce using rule 112 (booloperation -> IDENTIFIER condition_connector IDENTIFIER .)


state 225

    (111) booloperation -> IDENTIFIER condition_connector booleanOp .

    AND             reduce using rule 111 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    OR              reduce using rule 111 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    AMPERSAND       reduce using rule 111 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    PIPELINE        reduce using rule 111 (booloperation -> IDENTIFIER condition_connector booleanOp .)
    SEMICOLON       reduce using rule 111 (booloperation -> IDENTIFIER condition_connector booleanOp .)


state 226

    (110) booloperation -> booleanOp condition_connector booleanOp .

    AND             reduce using rule 110 (booloperation -> booleanOp condition_connector booleanOp .)
    OR              reduce using rule 110 (booloperation -> booleanOp condition_connector booleanOp .)
    AMPERSAND       reduce using rule 110 (booloperation -> booleanOp condition_connector booleanOp .)
    PIPELINE        reduce using rule 110 (booloperation -> booleanOp condition_connector booleanOp .)
    SEMICOLON       reduce using rule 110 (booloperation -> booleanOp condition_connector booleanOp .)


state 227

    (113) booloperation -> booleanOp condition_connector IDENTIFIER .

    AND             reduce using rule 113 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    OR              reduce using rule 113 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    AMPERSAND       reduce using rule 113 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    PIPELINE        reduce using rule 113 (booloperation -> booleanOp condition_connector IDENTIFIER .)
    SEMICOLON       reduce using rule 113 (booloperation -> booleanOp condition_connector IDENTIFIER .)


state 228

    (115) booloperations -> booloperation condition_connector booloperations .

    SEMICOLON       reduce using rule 115 (booloperations -> booloperation condition_connector booloperations .)


state 229

    (110) booloperation -> booleanOp . condition_connector booleanOp
    (113) booloperation -> booleanOp . condition_connector IDENTIFIER
    (81) condition_connector -> . AND
    (82) condition_connector -> . OR
    (83) condition_connector -> . AMPERSAND AMPERSAND
    (84) condition_connector -> . PIPELINE PIPELINE

    AND             shift and go to state 124
    OR              shift and go to state 125
    AMPERSAND       shift and go to state 126
    PIPELINE        shift and go to state 127

    condition_connector            shift and go to state 197

state 230

    (116) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 250


state 231

    (117) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 251


state 232

    (118) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 252


state 233

    (119) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 253


state 234

    (120) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL . LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON

    LSQUAREBRACKET  shift and go to state 254


state 235

    (18) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 18 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 18 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 18 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 236

    (40) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (12) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . while
    (8) class_content -> . stack
    (9) class_content -> . inferedReturnFunction
    (10) class_content -> . expression SEMICOLON
    (13) class_content -> . semanticbool
    (14) class_content -> . semanticlist
    (15) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (36) ifElseStatement -> . ifStatement
    (37) ifElseStatement -> . ifStatement elifStatement_repeat
    (85) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (104) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (105) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (131) declarationExpression -> . STRING IDENTIFIER EQUAL expressionString SEMICOLON
    (135) declarationExpression -> . INT IDENTIFIER EQUAL expressionInteger SEMICOLON
    (43) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET
    (45) while -> . WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (47) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (48) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (106) semanticbool -> . BOOL IDENTIFIER EQUAL booleanOp SEMICOLON
    (107) semanticbool -> . BOOL IDENTIFIER EQUAL booloperations SEMICOLON
    (116) semanticlist -> . LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON
    (117) semanticlist -> . LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON
    (118) semanticlist -> . LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON
    (119) semanticlist -> . LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON
    (120) semanticlist -> . LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON
    (16) map_identifier -> . MAP
    (17) map_identifier -> . MAP map_type_specified
    (40) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (19) datatype -> . returnType
    (20) datatype -> . VAR
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (21) returnType -> . INT
    (22) returnType -> . STRING
    (23) returnType -> . BOOL
    (24) returnType -> . DOUBLE
    (25) returnType -> . DYNAMIC
    (26) returnType -> . VOID
    (27) returnType -> . map_identifier
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    RCURLYBRACKET   shift and go to state 255
    STRING          shift and go to state 19
    INT             shift and go to state 20
    FOR             shift and go to state 21
    WHILE           shift and go to state 22
    FINAL           shift and go to state 23
    IDENTIFIER      shift and go to state 16
    BOOL            shift and go to state 26
    LIST            shift and go to state 28
    MAP             shift and go to state 31
    IF              shift and go to state 32
    VAR             shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    DOUBLE          shift and go to state 30
    DYNAMIC         shift and go to state 29
    VOID            shift and go to state 40
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    class_content                  shift and go to state 43
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    while                          shift and go to state 9
    stack                          shift and go to state 10
    inferedReturnFunction          shift and go to state 11
    expression                     shift and go to state 12
    semanticbool                   shift and go to state 13
    semanticlist                   shift and go to state 14
    map_identifier                 shift and go to state 15
    ifStatement                    shift and go to state 17
    datatype                       shift and go to state 18
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    booleanOp                      shift and go to state 27
    returnType                     shift and go to state 33
    number                         shift and go to state 35

state 237

    (15) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    STRING          reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INT             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FOR             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    WHILE           reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FINAL           reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOL            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    LIST            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAP             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IF              reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VAR             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INTEGER         reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FLOAT           reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STR             reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VOID            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    TRUE            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FALSE           reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    $end            reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 15 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 238

    (33) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 33 (map_pairs -> map_pair COMMA map_pairs .)


state 239

    (31) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 31 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 31 (map_pair -> map_key COLON map_value .)


state 240

    (35) map_value -> value .

    COMMA           reduce using rule 35 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 35 (map_value -> value .)


state 241

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression . SEMICOLON RCURLYBRACKET

    SEMICOLON       shift and go to state 256


state 242

    (85) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 257


state 243

    (90) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 90 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 244

    (94) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (93) optFunction_arguments -> . optFunction_argument
    (94) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (92) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 214

    optFunction_argument           shift and go to state 213
    optFunction_arguments          shift and go to state 258

state 245

    (92) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 259


state 246

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression . RPAREN LCURLYBRACKET RCURLYBRACKET

    RPAREN          shift and go to state 260


state 247

    (45) while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    STRING          reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 45 (while -> WHILE LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 248

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 261


state 249

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN . IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 262


state 250

    (116) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelist RSQUAREBRACKET SEMICOLON
    (121) insidelist -> . value
    (122) insidelist -> . value COMMA insidelist
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    INTEGER         shift and go to state 156
    FLOAT           shift and go to state 157
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    IDENTIFIER      shift and go to state 149
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    insidelist                     shift and go to state 263
    value                          shift and go to state 264
    booleanOp                      shift and go to state 27

state 251

    (117) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistint RSQUAREBRACKET SEMICOLON
    (123) insidelistint -> . INTEGER
    (124) insidelistint -> . INTEGER COMMA insidelistint

    INTEGER         shift and go to state 266

    insidelistint                  shift and go to state 265

state 252

    (118) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insideliststr RSQUAREBRACKET SEMICOLON
    (125) insideliststr -> . STR
    (126) insideliststr -> . STR COMMA insideliststr

    STR             shift and go to state 268

    insideliststr                  shift and go to state 267

state 253

    (119) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistbool RSQUAREBRACKET SEMICOLON
    (127) insidelistbool -> . booleanOp
    (128) insidelistbool -> . booleanOp COMMA insidelistbool
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    insidelistbool                 shift and go to state 269
    booleanOp                      shift and go to state 270

state 254

    (120) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET . insidelistdouble RSQUAREBRACKET SEMICOLON
    (129) insidelistdouble -> . FLOAT
    (130) insidelistdouble -> . FLOAT COMMA insidelistdouble

    FLOAT           shift and go to state 272

    insidelistdouble               shift and go to state 271

state 255

    (40) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    WHILE           reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    LIST            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    TRUE            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FALSE           reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 40 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 256

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 273


state 257

    (85) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (95) expression -> . operableTypes operatorExpression operableTypes
    (96) expression -> . value
    (97) expression -> . operableTypes operatorExpression operatorExpression
    (98) operableTypes -> . IDENTIFIER
    (99) operableTypes -> . number
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (71) number -> . FLOAT
    (72) number -> . INTEGER
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    IDENTIFIER      shift and go to state 113
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    expression                     shift and go to state 274
    operableTypes                  shift and go to state 24
    value                          shift and go to state 25
    number                         shift and go to state 35
    booleanOp                      shift and go to state 27

state 258

    (94) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 94 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 259

    (92) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 92 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 92 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 260

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN . LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 275


state 261

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . opt_value RPAREN SEMICOLON
    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . RPAREN SEMICOLON
    (55) opt_value -> . value
    (56) opt_value -> . empty
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (28) empty -> .
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 277
    INTEGER         shift and go to state 156
    FLOAT           shift and go to state 157
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    IDENTIFIER      shift and go to state 149
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

  ! RPAREN          [ reduce using rule 28 (empty -> .) ]

    opt_value                      shift and go to state 276
    value                          shift and go to state 278
    empty                          shift and go to state 279
    booleanOp                      shift and go to state 27

state 262

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER . RPAREN SEMICOLON

    RPAREN          shift and go to state 280


state 263

    (116) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 281


state 264

    (121) insidelist -> value .
    (122) insidelist -> value . COMMA insidelist

    RSQUAREBRACKET  reduce using rule 121 (insidelist -> value .)
    COMMA           shift and go to state 282


state 265

    (117) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 283


state 266

    (123) insidelistint -> INTEGER .
    (124) insidelistint -> INTEGER . COMMA insidelistint

    RSQUAREBRACKET  reduce using rule 123 (insidelistint -> INTEGER .)
    COMMA           shift and go to state 284


state 267

    (118) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 285


state 268

    (125) insideliststr -> STR .
    (126) insideliststr -> STR . COMMA insideliststr

    RSQUAREBRACKET  reduce using rule 125 (insideliststr -> STR .)
    COMMA           shift and go to state 286


state 269

    (119) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 287


state 270

    (127) insidelistbool -> booleanOp .
    (128) insidelistbool -> booleanOp . COMMA insidelistbool

    RSQUAREBRACKET  reduce using rule 127 (insidelistbool -> booleanOp .)
    COMMA           shift and go to state 288


state 271

    (120) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble . RSQUAREBRACKET SEMICOLON

    RSQUAREBRACKET  shift and go to state 289


state 272

    (129) insidelistdouble -> FLOAT .
    (130) insidelistdouble -> FLOAT . COMMA insidelistdouble

    RSQUAREBRACKET  reduce using rule 129 (insidelistdouble -> FLOAT .)
    COMMA           shift and go to state 290


state 273

    (48) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .

    STRING          reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INT             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FOR             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    WHILE           reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FINAL           reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOL            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    LIST            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAP             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IF              reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VAR             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INTEGER         reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FLOAT           reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STR             reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOLEAN         reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DOUBLE          reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DYNAMIC         reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VOID            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    TRUE            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FALSE           reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    $end            reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 48 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)


state 274

    (85) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 291


state 275

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 292


state 276

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value . RPAREN SEMICOLON

    RPAREN          shift and go to state 293


state 277

    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 294


state 278

    (55) opt_value -> value .

    RPAREN          reduce using rule 55 (opt_value -> value .)


state 279

    (56) opt_value -> empty .

    RPAREN          reduce using rule 56 (opt_value -> empty .)


state 280

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 295


state 281

    (116) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 296


state 282

    (122) insidelist -> value COMMA . insidelist
    (121) insidelist -> . value
    (122) insidelist -> . value COMMA insidelist
    (49) value -> . INTEGER
    (50) value -> . FLOAT
    (51) value -> . STR
    (52) value -> . BOOLEAN
    (53) value -> . IDENTIFIER
    (54) value -> . booleanOp
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    INTEGER         shift and go to state 156
    FLOAT           shift and go to state 157
    STR             shift and go to state 38
    BOOLEAN         shift and go to state 39
    IDENTIFIER      shift and go to state 149
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    value                          shift and go to state 264
    insidelist                     shift and go to state 297
    booleanOp                      shift and go to state 27

state 283

    (117) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 298


state 284

    (124) insidelistint -> INTEGER COMMA . insidelistint
    (123) insidelistint -> . INTEGER
    (124) insidelistint -> . INTEGER COMMA insidelistint

    INTEGER         shift and go to state 266

    insidelistint                  shift and go to state 299

state 285

    (118) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 300


state 286

    (126) insideliststr -> STR COMMA . insideliststr
    (125) insideliststr -> . STR
    (126) insideliststr -> . STR COMMA insideliststr

    STR             shift and go to state 268

    insideliststr                  shift and go to state 301

state 287

    (119) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 302


state 288

    (128) insidelistbool -> booleanOp COMMA . insidelistbool
    (127) insidelistbool -> . booleanOp
    (128) insidelistbool -> . booleanOp COMMA insidelistbool
    (108) booleanOp -> . TRUE
    (109) booleanOp -> . FALSE

    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    booleanOp                      shift and go to state 270
    insidelistbool                 shift and go to state 303

state 289

    (120) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 304


state 290

    (130) insidelistdouble -> FLOAT COMMA . insidelistdouble
    (129) insidelistdouble -> . FLOAT
    (130) insidelistdouble -> . FLOAT COMMA insidelistdouble

    FLOAT           shift and go to state 272

    insidelistdouble               shift and go to state 305

state 291

    (85) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    STRING          reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INT             reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FOR             reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    WHILE           reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FINAL           reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOL            reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    LIST            reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAP             reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IF              reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VAR             reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INTEGER         reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FLOAT           reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STR             reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOLEAN         reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DOUBLE          reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DYNAMIC         reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VOID            reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    TRUE            reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FALSE           reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    $end            reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 85 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)


state 292

    (43) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .

    STRING          reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FOR             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    WHILE           reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FINAL           reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    LIST            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    IF              reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VAR             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INTEGER         reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FLOAT           reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STR             reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOLEAN         reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    TRUE            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    FALSE           reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    $end            reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 43 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON expression RPAREN LCURLYBRACKET RCURLYBRACKET .)


state 293

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 306


state 294

    (46) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .

    STRING          reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STR             reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 46 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)


state 295

    (47) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .

    STRING          reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INT             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FOR             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    WHILE           reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FINAL           reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOL            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    LIST            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAP             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IF              reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VAR             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INTEGER         reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STR             reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VOID            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    TRUE            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FALSE           reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    $end            reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 47 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)


state 296

    (116) semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 116 (semanticlist -> LIST LESSTHAN DYNAMIC GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelist RSQUAREBRACKET SEMICOLON .)


state 297

    (122) insidelist -> value COMMA insidelist .

    RSQUAREBRACKET  reduce using rule 122 (insidelist -> value COMMA insidelist .)


state 298

    (117) semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 117 (semanticlist -> LIST LESSTHAN INT GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistint RSQUAREBRACKET SEMICOLON .)


state 299

    (124) insidelistint -> INTEGER COMMA insidelistint .

    RSQUAREBRACKET  reduce using rule 124 (insidelistint -> INTEGER COMMA insidelistint .)


state 300

    (118) semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 118 (semanticlist -> LIST LESSTHAN STRING GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insideliststr RSQUAREBRACKET SEMICOLON .)


state 301

    (126) insideliststr -> STR COMMA insideliststr .

    RSQUAREBRACKET  reduce using rule 126 (insideliststr -> STR COMMA insideliststr .)


state 302

    (119) semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 119 (semanticlist -> LIST LESSTHAN BOOL GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistbool RSQUAREBRACKET SEMICOLON .)


state 303

    (128) insidelistbool -> booleanOp COMMA insidelistbool .

    RSQUAREBRACKET  reduce using rule 128 (insidelistbool -> booleanOp COMMA insidelistbool .)


state 304

    (120) semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .

    STRING          reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    INT             reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FOR             reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    WHILE           reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FINAL           reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    BOOL            reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    LIST            reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    MAP             reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    IF              reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    VAR             reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    INTEGER         reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FLOAT           reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    STR             reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    VOID            reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    TRUE            reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    FALSE           reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    $end            reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 120 (semanticlist -> LIST LESSTHAN DOUBLE GREATERTHAN IDENTIFIER EQUAL LSQUAREBRACKET insidelistdouble RSQUAREBRACKET SEMICOLON .)


state 305

    (130) insidelistdouble -> FLOAT COMMA insidelistdouble .

    RSQUAREBRACKET  reduce using rule 130 (insidelistdouble -> FLOAT COMMA insidelistdouble .)


state 306

    (44) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .

    STRING          reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INT             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FOR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    WHILE           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FINAL           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOL            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    LIST            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAP             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IF              reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VAR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VOID            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    TRUE            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FALSE           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    $end            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 15 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 19 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 20 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 26 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 261 resolved as shift
