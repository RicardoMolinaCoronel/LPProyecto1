Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    APOSTROPHE
    ASYNC
    AWAIT
    CATCH
    CLOSE
    COMMENT
    DIVISION
    DOLLAR
    DOT
    DOUBQUOTMARK
    EXIT
    FILE
    FOR
    IMPORT
    IN
    IS
    ITERABLE
    LIST
    LSQUAREBRACKET
    MAIN
    METHOD
    MINUS
    NOTEQUAL
    OPENWRITE
    PRINT
    READLINESYNC
    RETURN
    RSQUAREBRACKET
    SET
    TIMES
    TRY
    WHILE
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> map ifElseStatement function_lambda
Rule 2     map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 3     map_identifier -> MAP
Rule 4     map_identifier -> MAP map_type_specified
Rule 5     map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 6     datatype -> INT
Rule 7     datatype -> STRING
Rule 8     datatype -> BOOL
Rule 9     datatype -> DOUBLE
Rule 10    datatype -> DYNAMIC
Rule 11    datatype -> VAR
Rule 12    datatype -> VOID
Rule 13    datatype -> map_identifier
Rule 14    returnType -> INT
Rule 15    returnType -> STRING
Rule 16    returnType -> BOOL
Rule 17    returnType -> DOUBLE
Rule 18    returnType -> DYNAMIC
Rule 19    returnType -> VOID
Rule 20    returnType -> map_identifier
Rule 21    empty -> <empty>
Rule 22    map_content -> map_pairs
Rule 23    map_content -> empty
Rule 24    map_pair -> map_key COLON map_value
Rule 25    map_pairs -> map_pair
Rule 26    map_pairs -> map_pair COMMA map_pairs
Rule 27    map_key -> value
Rule 28    map_value -> value
Rule 29    ifElseStatement -> ifStatement
Rule 30    ifElseStatement -> ifStatement elifStatement_repeat
Rule 31    elifStatement_repeat -> elifStatement
Rule 32    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 33    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET
Rule 34    elifStatement -> ELSE ifStatement
Rule 35    elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET
Rule 36    value -> INTEGER
Rule 37    value -> FLOAT
Rule 38    value -> STR
Rule 39    value -> BOOLEAN
Rule 40    value -> IDENTIFIER
Rule 41    deniable_values -> IDENTIFIER
Rule 42    deniable_values -> BOOLEAN
Rule 43    negation_values -> deniable_values
Rule 44    negation_values -> EXMARK deniable_values
Rule 45    condition_values -> negation_values
Rule 46    condition_values -> INTEGER
Rule 47    condition_values -> FLOAT
Rule 48    condition_values -> STR
Rule 49    condition_operator -> DOUBLEQUAL
Rule 50    condition_operator -> LESSTHAN
Rule 51    condition_operator -> GREATERTHAN
Rule 52    number -> FLOAT
Rule 53    number -> INTEGER
Rule 54    condition -> IDENTIFIER condition_operator condition_values
Rule 55    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 56    condition -> BOOLEAN condition_operator BOOLEAN
Rule 57    condition -> number condition_operator number
Rule 58    condition -> STR condition_operator STR
Rule 59    conditions -> condition
Rule 60    conditions -> condition condition_connector conditions
Rule 61    condition_connector -> AND
Rule 62    condition_connector -> OR
Rule 63    function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 64    function_argument -> datatype IDENTIFIER
Rule 65    function_argument -> empty
Rule 66    function_arguments_repeat -> function_argument
Rule 67    function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 68    optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 69    optFunction_argumentsExpression -> empty
Rule 70    optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 71    optFunction_arguments -> optFunction_argument
Rule 72    optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 73    expression -> IDENTIFIER PLUS IDENTIFIER

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 61
APOSTROPHE           : 
ASYNC                : 
AWAIT                : 
BOOL                 : 8 16
BOOLEAN              : 39 42 56 56
CATCH                : 
CLOSE                : 
COLON                : 24
COMMA                : 5 26 67 72
COMMENT              : 
DIVISION             : 
DOLLAR               : 
DOT                  : 
DOUBLE               : 9 17
DOUBLEQUAL           : 49
DOUBQUOTMARK         : 
DYNAMIC              : 10 18
ELSE                 : 34 35
EQUAL                : 2 63
EXIT                 : 
EXMARK               : 44 55
FILE                 : 
FLOAT                : 37 47 52
FOR                  : 
GREATERTHAN          : 5 51 63
IDENTIFIER           : 2 40 41 54 55 63 64 70 73 73
IF                   : 33
IMPORT               : 
IN                   : 
INT                  : 6 14
INTEGER              : 36 46 53
IS                   : 
ITERABLE             : 
LCURLYBRACKET        : 2 33 35 68
LESSTHAN             : 5 50
LIST                 : 
LPAREN               : 33 63
LSQUAREBRACKET       : 
MAIN                 : 
MAP                  : 3 4
METHOD               : 
MINUS                : 
NOTEQUAL             : 
OPENWRITE            : 
OR                   : 62
PLUS                 : 73
PRINT                : 
RCURLYBRACKET        : 2 33 35 68
READLINESYNC         : 
REQUIRED             : 70
RETURN               : 
RPAREN               : 33 63
RSQUAREBRACKET       : 
SEMICOLON            : 2 63
SET                  : 
STR                  : 38 48 58 58
STRING               : 7 15
TIMES                : 
TRY                  : 
VAR                  : 11
VOID                 : 12 19
WHILE                : 
WRITE                : 
error                : 

Nonterminals, with rules where they appear

class                : 0
condition            : 59 60
condition_connector  : 60
condition_operator   : 54 55 56 57 58
condition_values     : 54 55
conditions           : 33 60
datatype             : 5 5 64 70
deniable_values      : 43 44
elifStatement        : 31 32
elifStatement_repeat : 30 32
empty                : 23 65 69
expression           : 63
function_argument    : 66 67
function_arguments_repeat : 63 67
function_lambda      : 1
ifElseStatement      : 1
ifStatement          : 29 30 34
map                  : 1
map_content          : 2
map_identifier       : 2 13 20
map_key              : 24
map_pair             : 25 26
map_pairs            : 22 26
map_type_specified   : 4
map_value            : 24
negation_values      : 45
number               : 57 57
optFunction_argument : 71 72
optFunction_arguments : 68 72
optFunction_argumentsExpression : 63
returnType           : 63
value                : 27 28

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . map ifElseStatement function_lambda
    (2) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    MAP             shift and go to state 4

    class                          shift and go to state 1
    map                            shift and go to state 2
    map_identifier                 shift and go to state 3

state 1

    (0) S' -> class .



state 2

    (1) class -> map . ifElseStatement function_lambda
    (29) ifElseStatement -> . ifStatement
    (30) ifElseStatement -> . ifStatement elifStatement_repeat
    (33) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET

    IF              shift and go to state 7

    ifElseStatement                shift and go to state 5
    ifStatement                    shift and go to state 6

state 3

    (2) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    IDENTIFIER      shift and go to state 8


state 4

    (3) map_identifier -> MAP .
    (4) map_identifier -> MAP . map_type_specified
    (5) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 3 (map_identifier -> MAP .)
    COMMA           reduce using rule 3 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 3 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 10

    map_type_specified             shift and go to state 9

state 5

    (1) class -> map ifElseStatement . function_lambda
    (63) function_lambda -> . returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (14) returnType -> . INT
    (15) returnType -> . STRING
    (16) returnType -> . BOOL
    (17) returnType -> . DOUBLE
    (18) returnType -> . DYNAMIC
    (19) returnType -> . VOID
    (20) returnType -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    DOUBLE          shift and go to state 16
    DYNAMIC         shift and go to state 17
    VOID            shift and go to state 18
    MAP             shift and go to state 4

    function_lambda                shift and go to state 11
    returnType                     shift and go to state 12
    map_identifier                 shift and go to state 19

state 6

    (29) ifElseStatement -> ifStatement .
    (30) ifElseStatement -> ifStatement . elifStatement_repeat
    (31) elifStatement_repeat -> . elifStatement
    (32) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (34) elifStatement -> . ELSE ifStatement
    (35) elifStatement -> . ELSE LCURLYBRACKET RCURLYBRACKET

    INT             reduce using rule 29 (ifElseStatement -> ifStatement .)
    STRING          reduce using rule 29 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 29 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 29 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 29 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 29 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 29 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 22

    elifStatement_repeat           shift and go to state 20
    elifStatement                  shift and go to state 21

state 7

    (33) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET

    LPAREN          shift and go to state 23


state 8

    (2) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 24


state 9

    (4) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 4 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 4 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 4 (map_identifier -> MAP map_type_specified .)


state 10

    (5) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    MAP             shift and go to state 4

    datatype                       shift and go to state 25
    map_identifier                 shift and go to state 33

state 11

    (1) class -> map ifElseStatement function_lambda .

    $end            reduce using rule 1 (class -> map ifElseStatement function_lambda .)


state 12

    (63) function_lambda -> returnType . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON

    IDENTIFIER      shift and go to state 34


state 13

    (14) returnType -> INT .

    IDENTIFIER      reduce using rule 14 (returnType -> INT .)


state 14

    (15) returnType -> STRING .

    IDENTIFIER      reduce using rule 15 (returnType -> STRING .)


state 15

    (16) returnType -> BOOL .

    IDENTIFIER      reduce using rule 16 (returnType -> BOOL .)


state 16

    (17) returnType -> DOUBLE .

    IDENTIFIER      reduce using rule 17 (returnType -> DOUBLE .)


state 17

    (18) returnType -> DYNAMIC .

    IDENTIFIER      reduce using rule 18 (returnType -> DYNAMIC .)


state 18

    (19) returnType -> VOID .

    IDENTIFIER      reduce using rule 19 (returnType -> VOID .)


state 19

    (20) returnType -> map_identifier .

    IDENTIFIER      reduce using rule 20 (returnType -> map_identifier .)


state 20

    (30) ifElseStatement -> ifStatement elifStatement_repeat .

    INT             reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STRING          reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 30 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 21

    (31) elifStatement_repeat -> elifStatement .
    (32) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (31) elifStatement_repeat -> . elifStatement
    (32) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (34) elifStatement -> . ELSE ifStatement
    (35) elifStatement -> . ELSE LCURLYBRACKET RCURLYBRACKET

    INT             reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    STRING          reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 31 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 22

    elifStatement                  shift and go to state 21
    elifStatement_repeat           shift and go to state 35

state 22

    (34) elifStatement -> ELSE . ifStatement
    (35) elifStatement -> ELSE . LCURLYBRACKET RCURLYBRACKET
    (33) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 37
    IF              shift and go to state 7

    ifStatement                    shift and go to state 36

state 23

    (33) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET RCURLYBRACKET
    (59) conditions -> . condition
    (60) conditions -> . condition condition_connector conditions
    (54) condition -> . IDENTIFIER condition_operator condition_values
    (55) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (56) condition -> . BOOLEAN condition_operator BOOLEAN
    (57) condition -> . number condition_operator number
    (58) condition -> . STR condition_operator STR
    (52) number -> . FLOAT
    (53) number -> . INTEGER

    IDENTIFIER      shift and go to state 40
    EXMARK          shift and go to state 41
    BOOLEAN         shift and go to state 42
    STR             shift and go to state 44
    FLOAT           shift and go to state 45
    INTEGER         shift and go to state 46

    conditions                     shift and go to state 38
    condition                      shift and go to state 39
    number                         shift and go to state 43

state 24

    (2) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 47


state 25

    (5) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 48


state 26

    (6) datatype -> INT .

    COMMA           reduce using rule 6 (datatype -> INT .)
    GREATERTHAN     reduce using rule 6 (datatype -> INT .)
    IDENTIFIER      reduce using rule 6 (datatype -> INT .)


state 27

    (7) datatype -> STRING .

    COMMA           reduce using rule 7 (datatype -> STRING .)
    GREATERTHAN     reduce using rule 7 (datatype -> STRING .)
    IDENTIFIER      reduce using rule 7 (datatype -> STRING .)


state 28

    (8) datatype -> BOOL .

    COMMA           reduce using rule 8 (datatype -> BOOL .)
    GREATERTHAN     reduce using rule 8 (datatype -> BOOL .)
    IDENTIFIER      reduce using rule 8 (datatype -> BOOL .)


state 29

    (9) datatype -> DOUBLE .

    COMMA           reduce using rule 9 (datatype -> DOUBLE .)
    GREATERTHAN     reduce using rule 9 (datatype -> DOUBLE .)
    IDENTIFIER      reduce using rule 9 (datatype -> DOUBLE .)


state 30

    (10) datatype -> DYNAMIC .

    COMMA           reduce using rule 10 (datatype -> DYNAMIC .)
    GREATERTHAN     reduce using rule 10 (datatype -> DYNAMIC .)
    IDENTIFIER      reduce using rule 10 (datatype -> DYNAMIC .)


state 31

    (11) datatype -> VAR .

    COMMA           reduce using rule 11 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 11 (datatype -> VAR .)
    IDENTIFIER      reduce using rule 11 (datatype -> VAR .)


state 32

    (12) datatype -> VOID .

    COMMA           reduce using rule 12 (datatype -> VOID .)
    GREATERTHAN     reduce using rule 12 (datatype -> VOID .)
    IDENTIFIER      reduce using rule 12 (datatype -> VOID .)


state 33

    (13) datatype -> map_identifier .

    COMMA           reduce using rule 13 (datatype -> map_identifier .)
    GREATERTHAN     reduce using rule 13 (datatype -> map_identifier .)
    IDENTIFIER      reduce using rule 13 (datatype -> map_identifier .)


state 34

    (63) function_lambda -> returnType IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON

    LPAREN          shift and go to state 49


state 35

    (32) elifStatement_repeat -> elifStatement elifStatement_repeat .

    INT             reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STRING          reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 32 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 36

    (34) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 34 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 34 (elifStatement -> ELSE ifStatement .)


state 37

    (35) elifStatement -> ELSE LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 50


state 38

    (33) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET RCURLYBRACKET

    RPAREN          shift and go to state 51


state 39

    (59) conditions -> condition .
    (60) conditions -> condition . condition_connector conditions
    (61) condition_connector -> . AND
    (62) condition_connector -> . OR

    RPAREN          reduce using rule 59 (conditions -> condition .)
    AND             shift and go to state 53
    OR              shift and go to state 54

    condition_connector            shift and go to state 52

state 40

    (54) condition -> IDENTIFIER . condition_operator condition_values
    (49) condition_operator -> . DOUBLEQUAL
    (50) condition_operator -> . LESSTHAN
    (51) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 56
    LESSTHAN        shift and go to state 57
    GREATERTHAN     shift and go to state 58

    condition_operator             shift and go to state 55

state 41

    (55) condition -> EXMARK . IDENTIFIER condition_operator condition_values

    IDENTIFIER      shift and go to state 59


state 42

    (56) condition -> BOOLEAN . condition_operator BOOLEAN
    (49) condition_operator -> . DOUBLEQUAL
    (50) condition_operator -> . LESSTHAN
    (51) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 56
    LESSTHAN        shift and go to state 57
    GREATERTHAN     shift and go to state 58

    condition_operator             shift and go to state 60

state 43

    (57) condition -> number . condition_operator number
    (49) condition_operator -> . DOUBLEQUAL
    (50) condition_operator -> . LESSTHAN
    (51) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 56
    LESSTHAN        shift and go to state 57
    GREATERTHAN     shift and go to state 58

    condition_operator             shift and go to state 61

state 44

    (58) condition -> STR . condition_operator STR
    (49) condition_operator -> . DOUBLEQUAL
    (50) condition_operator -> . LESSTHAN
    (51) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 56
    LESSTHAN        shift and go to state 57
    GREATERTHAN     shift and go to state 58

    condition_operator             shift and go to state 62

state 45

    (52) number -> FLOAT .

    DOUBLEQUAL      reduce using rule 52 (number -> FLOAT .)
    LESSTHAN        reduce using rule 52 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 52 (number -> FLOAT .)
    AND             reduce using rule 52 (number -> FLOAT .)
    OR              reduce using rule 52 (number -> FLOAT .)
    RPAREN          reduce using rule 52 (number -> FLOAT .)


state 46

    (53) number -> INTEGER .

    DOUBLEQUAL      reduce using rule 53 (number -> INTEGER .)
    LESSTHAN        reduce using rule 53 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 53 (number -> INTEGER .)
    AND             reduce using rule 53 (number -> INTEGER .)
    OR              reduce using rule 53 (number -> INTEGER .)
    RPAREN          reduce using rule 53 (number -> INTEGER .)


state 47

    (2) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (22) map_content -> . map_pairs
    (23) map_content -> . empty
    (25) map_pairs -> . map_pair
    (26) map_pairs -> . map_pair COMMA map_pairs
    (21) empty -> .
    (24) map_pair -> . map_key COLON map_value
    (27) map_key -> . value
    (36) value -> . INTEGER
    (37) value -> . FLOAT
    (38) value -> . STR
    (39) value -> . BOOLEAN
    (40) value -> . IDENTIFIER

    RCURLYBRACKET   reduce using rule 21 (empty -> .)
    INTEGER         shift and go to state 70
    FLOAT           shift and go to state 71
    STR             shift and go to state 72
    BOOLEAN         shift and go to state 73
    IDENTIFIER      shift and go to state 63

    map_content                    shift and go to state 64
    map_pairs                      shift and go to state 65
    empty                          shift and go to state 66
    map_pair                       shift and go to state 67
    map_key                        shift and go to state 68
    value                          shift and go to state 69

state 48

    (5) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    MAP             shift and go to state 4

    datatype                       shift and go to state 74
    map_identifier                 shift and go to state 33

state 49

    (63) function_lambda -> returnType IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (66) function_arguments_repeat -> . function_argument
    (67) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (64) function_argument -> . datatype IDENTIFIER
    (65) function_argument -> . empty
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (21) empty -> .
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    COMMA           reduce using rule 21 (empty -> .)
    LCURLYBRACKET   reduce using rule 21 (empty -> .)
    RPAREN          reduce using rule 21 (empty -> .)
    MAP             shift and go to state 4

    function_arguments_repeat      shift and go to state 75
    function_argument              shift and go to state 76
    datatype                       shift and go to state 77
    empty                          shift and go to state 78
    map_identifier                 shift and go to state 33

state 50

    (35) elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .

    ELSE            reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    STRING          reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 35 (elifStatement -> ELSE LCURLYBRACKET RCURLYBRACKET .)


state 51

    (33) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 79


state 52

    (60) conditions -> condition condition_connector . conditions
    (59) conditions -> . condition
    (60) conditions -> . condition condition_connector conditions
    (54) condition -> . IDENTIFIER condition_operator condition_values
    (55) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (56) condition -> . BOOLEAN condition_operator BOOLEAN
    (57) condition -> . number condition_operator number
    (58) condition -> . STR condition_operator STR
    (52) number -> . FLOAT
    (53) number -> . INTEGER

    IDENTIFIER      shift and go to state 40
    EXMARK          shift and go to state 41
    BOOLEAN         shift and go to state 42
    STR             shift and go to state 44
    FLOAT           shift and go to state 45
    INTEGER         shift and go to state 46

    condition                      shift and go to state 39
    conditions                     shift and go to state 80
    number                         shift and go to state 43

state 53

    (61) condition_connector -> AND .

    IDENTIFIER      reduce using rule 61 (condition_connector -> AND .)
    EXMARK          reduce using rule 61 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 61 (condition_connector -> AND .)
    STR             reduce using rule 61 (condition_connector -> AND .)
    FLOAT           reduce using rule 61 (condition_connector -> AND .)
    INTEGER         reduce using rule 61 (condition_connector -> AND .)


state 54

    (62) condition_connector -> OR .

    IDENTIFIER      reduce using rule 62 (condition_connector -> OR .)
    EXMARK          reduce using rule 62 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 62 (condition_connector -> OR .)
    STR             reduce using rule 62 (condition_connector -> OR .)
    FLOAT           reduce using rule 62 (condition_connector -> OR .)
    INTEGER         reduce using rule 62 (condition_connector -> OR .)


state 55

    (54) condition -> IDENTIFIER condition_operator . condition_values
    (45) condition_values -> . negation_values
    (46) condition_values -> . INTEGER
    (47) condition_values -> . FLOAT
    (48) condition_values -> . STR
    (43) negation_values -> . deniable_values
    (44) negation_values -> . EXMARK deniable_values
    (41) deniable_values -> . IDENTIFIER
    (42) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 84
    FLOAT           shift and go to state 85
    STR             shift and go to state 86
    EXMARK          shift and go to state 88
    IDENTIFIER      shift and go to state 81
    BOOLEAN         shift and go to state 89

    condition_values               shift and go to state 82
    negation_values                shift and go to state 83
    deniable_values                shift and go to state 87

state 56

    (49) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 49 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 49 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 49 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 49 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 49 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 49 (condition_operator -> DOUBLEQUAL .)


state 57

    (50) condition_operator -> LESSTHAN .

    INTEGER         reduce using rule 50 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 50 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 50 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 50 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 50 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 50 (condition_operator -> LESSTHAN .)


state 58

    (51) condition_operator -> GREATERTHAN .

    INTEGER         reduce using rule 51 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 51 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 51 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 51 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 51 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 51 (condition_operator -> GREATERTHAN .)


state 59

    (55) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (49) condition_operator -> . DOUBLEQUAL
    (50) condition_operator -> . LESSTHAN
    (51) condition_operator -> . GREATERTHAN

    DOUBLEQUAL      shift and go to state 56
    LESSTHAN        shift and go to state 57
    GREATERTHAN     shift and go to state 58

    condition_operator             shift and go to state 90

state 60

    (56) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 91


state 61

    (57) condition -> number condition_operator . number
    (52) number -> . FLOAT
    (53) number -> . INTEGER

    FLOAT           shift and go to state 45
    INTEGER         shift and go to state 46

    number                         shift and go to state 92

state 62

    (58) condition -> STR condition_operator . STR

    STR             shift and go to state 93


state 63

    (40) value -> IDENTIFIER .

    COLON           reduce using rule 40 (value -> IDENTIFIER .)
    COMMA           reduce using rule 40 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 40 (value -> IDENTIFIER .)


state 64

    (2) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 94


state 65

    (22) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 22 (map_content -> map_pairs .)


state 66

    (23) map_content -> empty .

    RCURLYBRACKET   reduce using rule 23 (map_content -> empty .)


state 67

    (25) map_pairs -> map_pair .
    (26) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 25 (map_pairs -> map_pair .)
    COMMA           shift and go to state 95


state 68

    (24) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 96


state 69

    (27) map_key -> value .

    COLON           reduce using rule 27 (map_key -> value .)


state 70

    (36) value -> INTEGER .

    COLON           reduce using rule 36 (value -> INTEGER .)
    COMMA           reduce using rule 36 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 36 (value -> INTEGER .)


state 71

    (37) value -> FLOAT .

    COLON           reduce using rule 37 (value -> FLOAT .)
    COMMA           reduce using rule 37 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 37 (value -> FLOAT .)


state 72

    (38) value -> STR .

    COLON           reduce using rule 38 (value -> STR .)
    COMMA           reduce using rule 38 (value -> STR .)
    RCURLYBRACKET   reduce using rule 38 (value -> STR .)


state 73

    (39) value -> BOOLEAN .

    COLON           reduce using rule 39 (value -> BOOLEAN .)
    COMMA           reduce using rule 39 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 39 (value -> BOOLEAN .)


state 74

    (5) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 97


state 75

    (63) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (68) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (69) optFunction_argumentsExpression -> . empty
    (21) empty -> .

    LCURLYBRACKET   shift and go to state 99
    RPAREN          reduce using rule 21 (empty -> .)

    optFunction_argumentsExpression shift and go to state 98
    empty                          shift and go to state 100

state 76

    (66) function_arguments_repeat -> function_argument .
    (67) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    LCURLYBRACKET   reduce using rule 66 (function_arguments_repeat -> function_argument .)
    RPAREN          reduce using rule 66 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 101


state 77

    (64) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 102


state 78

    (65) function_argument -> empty .

    COMMA           reduce using rule 65 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 65 (function_argument -> empty .)
    RPAREN          reduce using rule 65 (function_argument -> empty .)


state 79

    (33) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 103


state 80

    (60) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 60 (conditions -> condition condition_connector conditions .)


state 81

    (41) deniable_values -> IDENTIFIER .

    AND             reduce using rule 41 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 41 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 41 (deniable_values -> IDENTIFIER .)


state 82

    (54) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 54 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 54 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 54 (condition -> IDENTIFIER condition_operator condition_values .)


state 83

    (45) condition_values -> negation_values .

    AND             reduce using rule 45 (condition_values -> negation_values .)
    OR              reduce using rule 45 (condition_values -> negation_values .)
    RPAREN          reduce using rule 45 (condition_values -> negation_values .)


state 84

    (46) condition_values -> INTEGER .

    AND             reduce using rule 46 (condition_values -> INTEGER .)
    OR              reduce using rule 46 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 46 (condition_values -> INTEGER .)


state 85

    (47) condition_values -> FLOAT .

    AND             reduce using rule 47 (condition_values -> FLOAT .)
    OR              reduce using rule 47 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 47 (condition_values -> FLOAT .)


state 86

    (48) condition_values -> STR .

    AND             reduce using rule 48 (condition_values -> STR .)
    OR              reduce using rule 48 (condition_values -> STR .)
    RPAREN          reduce using rule 48 (condition_values -> STR .)


state 87

    (43) negation_values -> deniable_values .

    AND             reduce using rule 43 (negation_values -> deniable_values .)
    OR              reduce using rule 43 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 43 (negation_values -> deniable_values .)


state 88

    (44) negation_values -> EXMARK . deniable_values
    (41) deniable_values -> . IDENTIFIER
    (42) deniable_values -> . BOOLEAN

    IDENTIFIER      shift and go to state 81
    BOOLEAN         shift and go to state 89

    deniable_values                shift and go to state 104

state 89

    (42) deniable_values -> BOOLEAN .

    AND             reduce using rule 42 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 42 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 42 (deniable_values -> BOOLEAN .)


state 90

    (55) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (45) condition_values -> . negation_values
    (46) condition_values -> . INTEGER
    (47) condition_values -> . FLOAT
    (48) condition_values -> . STR
    (43) negation_values -> . deniable_values
    (44) negation_values -> . EXMARK deniable_values
    (41) deniable_values -> . IDENTIFIER
    (42) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 84
    FLOAT           shift and go to state 85
    STR             shift and go to state 86
    EXMARK          shift and go to state 88
    IDENTIFIER      shift and go to state 81
    BOOLEAN         shift and go to state 89

    condition_values               shift and go to state 105
    negation_values                shift and go to state 83
    deniable_values                shift and go to state 87

state 91

    (56) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 56 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 56 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 56 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 92

    (57) condition -> number condition_operator number .

    AND             reduce using rule 57 (condition -> number condition_operator number .)
    OR              reduce using rule 57 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 57 (condition -> number condition_operator number .)


state 93

    (58) condition -> STR condition_operator STR .

    AND             reduce using rule 58 (condition -> STR condition_operator STR .)
    OR              reduce using rule 58 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 58 (condition -> STR condition_operator STR .)


state 94

    (2) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 106


state 95

    (26) map_pairs -> map_pair COMMA . map_pairs
    (25) map_pairs -> . map_pair
    (26) map_pairs -> . map_pair COMMA map_pairs
    (24) map_pair -> . map_key COLON map_value
    (27) map_key -> . value
    (36) value -> . INTEGER
    (37) value -> . FLOAT
    (38) value -> . STR
    (39) value -> . BOOLEAN
    (40) value -> . IDENTIFIER

    INTEGER         shift and go to state 70
    FLOAT           shift and go to state 71
    STR             shift and go to state 72
    BOOLEAN         shift and go to state 73
    IDENTIFIER      shift and go to state 63

    map_pair                       shift and go to state 67
    map_pairs                      shift and go to state 107
    map_key                        shift and go to state 68
    value                          shift and go to state 69

state 96

    (24) map_pair -> map_key COLON . map_value
    (28) map_value -> . value
    (36) value -> . INTEGER
    (37) value -> . FLOAT
    (38) value -> . STR
    (39) value -> . BOOLEAN
    (40) value -> . IDENTIFIER

    INTEGER         shift and go to state 70
    FLOAT           shift and go to state 71
    STR             shift and go to state 72
    BOOLEAN         shift and go to state 73
    IDENTIFIER      shift and go to state 63

    map_value                      shift and go to state 108
    value                          shift and go to state 109

state 97

    (5) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 5 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 5 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 5 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 98

    (63) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 110


state 99

    (68) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (71) optFunction_arguments -> . optFunction_argument
    (72) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (70) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 113

    optFunction_arguments          shift and go to state 111
    optFunction_argument           shift and go to state 112

state 100

    (69) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 69 (optFunction_argumentsExpression -> empty .)


state 101

    (67) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (66) function_arguments_repeat -> . function_argument
    (67) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (64) function_argument -> . datatype IDENTIFIER
    (65) function_argument -> . empty
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (21) empty -> .
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    COMMA           reduce using rule 21 (empty -> .)
    LCURLYBRACKET   reduce using rule 21 (empty -> .)
    RPAREN          reduce using rule 21 (empty -> .)
    MAP             shift and go to state 4

    function_argument              shift and go to state 76
    function_arguments_repeat      shift and go to state 114
    datatype                       shift and go to state 77
    empty                          shift and go to state 78
    map_identifier                 shift and go to state 33

state 102

    (64) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 64 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 64 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 64 (function_argument -> datatype IDENTIFIER .)


state 103

    (33) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .

    ELSE            reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    INT             reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    STRING          reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    BOOL            reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DOUBLE          reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    DYNAMIC         reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    VOID            reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)
    MAP             reduce using rule 33 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET RCURLYBRACKET .)


state 104

    (44) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 44 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 44 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 44 (negation_values -> EXMARK deniable_values .)


state 105

    (55) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 55 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 55 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 55 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 106

    (2) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    IF              reduce using rule 2 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 107

    (26) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 26 (map_pairs -> map_pair COMMA map_pairs .)


state 108

    (24) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 24 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 24 (map_pair -> map_key COLON map_value .)


state 109

    (28) map_value -> value .

    COMMA           reduce using rule 28 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 28 (map_value -> value .)


state 110

    (63) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 115


state 111

    (68) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 116


state 112

    (71) optFunction_arguments -> optFunction_argument .
    (72) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 71 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 117


state 113

    (70) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (6) datatype -> . INT
    (7) datatype -> . STRING
    (8) datatype -> . BOOL
    (9) datatype -> . DOUBLE
    (10) datatype -> . DYNAMIC
    (11) datatype -> . VAR
    (12) datatype -> . VOID
    (13) datatype -> . map_identifier
    (3) map_identifier -> . MAP
    (4) map_identifier -> . MAP map_type_specified

    INT             shift and go to state 26
    STRING          shift and go to state 27
    BOOL            shift and go to state 28
    DOUBLE          shift and go to state 29
    DYNAMIC         shift and go to state 30
    VAR             shift and go to state 31
    VOID            shift and go to state 32
    MAP             shift and go to state 4

    datatype                       shift and go to state 118
    map_identifier                 shift and go to state 33

state 114

    (67) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    LCURLYBRACKET   reduce using rule 67 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    RPAREN          reduce using rule 67 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 115

    (63) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 119


state 116

    (68) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 68 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 117

    (72) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (71) optFunction_arguments -> . optFunction_argument
    (72) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (70) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 113

    optFunction_argument           shift and go to state 112
    optFunction_arguments          shift and go to state 120

state 118

    (70) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 121


state 119

    (63) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (73) expression -> . IDENTIFIER PLUS IDENTIFIER

    IDENTIFIER      shift and go to state 122

    expression                     shift and go to state 123

state 120

    (72) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 72 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 121

    (70) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 70 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 70 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 122

    (73) expression -> IDENTIFIER . PLUS IDENTIFIER

    PLUS            shift and go to state 124


state 123

    (63) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 125


state 124

    (73) expression -> IDENTIFIER PLUS . IDENTIFIER

    IDENTIFIER      shift and go to state 126


state 125

    (63) function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    $end            reduce using rule 63 (function_lambda -> returnType IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)


state 126

    (73) expression -> IDENTIFIER PLUS IDENTIFIER .

    SEMICOLON       reduce using rule 73 (expression -> IDENTIFIER PLUS IDENTIFIER .)

