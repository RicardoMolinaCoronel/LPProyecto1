Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    APOSTROPHE
    ASYNC
    AWAIT
    CATCH
    CLOSE
    COMMENT
    DOLLAR
    DOUBQUOTMARK
    EXIT
    FILE
    IMPORT
    IN
    IS
    ITERABLE
    LIST
    LSQUAREBRACKET
    MAIN
    METHOD
    NOTEQUAL
    OPENWRITE
    PRINT
    READLINESYNC
    RSQUAREBRACKET
    SET
    TRY
    WHILE
    WRITE

Grammar

Rule 0     S' -> class
Rule 1     class -> class_content_repeat
Rule 2     class_content -> map
Rule 3     class_content -> ifElseStatement
Rule 4     class_content -> function_lambda
Rule 5     class_content -> declarationExpression
Rule 6     class_content -> forStatement
Rule 7     class_content -> stack
Rule 8     class_content -> inferedReturnFunction
Rule 9     class_content -> expression SEMICOLON
Rule 10    class_content_repeat -> class_content
Rule 11    class_content_repeat -> class_content_repeat class_content
Rule 12    map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
Rule 13    map_identifier -> MAP
Rule 14    map_identifier -> MAP map_type_specified
Rule 15    map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN
Rule 16    datatype -> returnType
Rule 17    datatype -> VAR
Rule 18    returnType -> INT
Rule 19    returnType -> STRING
Rule 20    returnType -> BOOL
Rule 21    returnType -> DOUBLE
Rule 22    returnType -> DYNAMIC
Rule 23    returnType -> VOID
Rule 24    returnType -> map_identifier
Rule 25    empty -> <empty>
Rule 26    map_content -> map_pairs
Rule 27    map_content -> empty
Rule 28    map_pair -> map_key COLON map_value
Rule 29    map_pairs -> map_pair
Rule 30    map_pairs -> map_pair COMMA map_pairs
Rule 31    map_key -> value
Rule 32    map_value -> value
Rule 33    ifElseStatement -> ifStatement
Rule 34    ifElseStatement -> ifStatement elifStatement_repeat
Rule 35    elifStatement_repeat -> elifStatement
Rule 36    elifStatement_repeat -> elifStatement elifStatement_repeat
Rule 37    ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 38    elifStatement -> ELSE ifStatement
Rule 39    elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 40    forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
Rule 41    taskStatement -> IDENTIFIER operatorExpression operatorExpression
Rule 42    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
Rule 43    stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
Rule 44    stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
Rule 45    inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
Rule 46    value -> INTEGER
Rule 47    value -> FLOAT
Rule 48    value -> STR
Rule 49    value -> BOOLEAN
Rule 50    value -> IDENTIFIER
Rule 51    opt_value -> value
Rule 52    opt_value -> empty
Rule 53    deniable_values -> IDENTIFIER
Rule 54    deniable_values -> BOOLEAN
Rule 55    negation_values -> deniable_values
Rule 56    negation_values -> EXMARK deniable_values
Rule 57    condition_values -> negation_values
Rule 58    condition_values -> INTEGER
Rule 59    condition_values -> FLOAT
Rule 60    condition_values -> STR
Rule 61    condition_operator -> DOUBLEQUAL
Rule 62    condition_operator -> LESSTHAN
Rule 63    condition_operator -> GREATERTHAN
Rule 64    condition_operator -> LESSTHAN EQUAL
Rule 65    condition_operator -> GREATERTHAN EQUAL
Rule 66    number -> FLOAT
Rule 67    number -> INTEGER
Rule 68    condition -> IDENTIFIER condition_operator condition_values
Rule 69    condition -> EXMARK IDENTIFIER condition_operator condition_values
Rule 70    condition -> BOOLEAN condition_operator BOOLEAN
Rule 71    condition -> number condition_operator number
Rule 72    condition -> STR condition_operator STR
Rule 73    conditions -> condition
Rule 74    conditions -> condition condition_connector conditions
Rule 75    condition_connector -> AND
Rule 76    condition_connector -> OR
Rule 77    function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
Rule 78    function_argument -> datatype IDENTIFIER
Rule 79    function_argument -> empty
Rule 80    function_arguments_repeat -> function_argument
Rule 81    function_arguments_repeat -> function_argument COMMA function_arguments_repeat
Rule 82    optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET
Rule 83    optFunction_argumentsExpression -> empty
Rule 84    optFunction_argument -> REQUIRED datatype IDENTIFIER
Rule 85    optFunction_arguments -> optFunction_argument
Rule 86    optFunction_arguments -> optFunction_argument COMMA optFunction_arguments
Rule 87    expression -> operableTypes operatorExpression operableTypes
Rule 88    expression -> value
Rule 89    operableTypes -> IDENTIFIER
Rule 90    operableTypes -> number
Rule 91    operatorExpression -> PLUS
Rule 92    operatorExpression -> MINUS
Rule 93    operatorExpression -> TIMES
Rule 94    operatorExpression -> DIVISION
Rule 95    declarationExpression -> datatype IDENTIFIER SEMICOLON
Rule 96    declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 75
APOSTROPHE           : 
ASYNC                : 
AWAIT                : 
BOOL                 : 20
BOOLEAN              : 49 54 70 70
CATCH                : 
CLOSE                : 
COLON                : 28
COMMA                : 15 30 81 86
COMMENT              : 
DIVISION             : 94
DOLLAR               : 
DOT                  : 44
DOUBLE               : 21
DOUBLEQUAL           : 61
DOUBQUOTMARK         : 
DYNAMIC              : 22
ELSE                 : 38 39
EQUAL                : 12 42 43 44 64 65 77 96
EXIT                 : 
EXMARK               : 56 69
FILE                 : 
FINAL                : 42 43 44
FLOAT                : 47 59 66
FOR                  : 40
GREATERTHAN          : 15 42 43 63 65 77
IDENTIFIER           : 12 41 42 43 44 44 45 50 53 68 69 77 78 84 89 95 96
IF                   : 37
IMPORT               : 
IN                   : 
INT                  : 18
INTEGER              : 46 58 67
IS                   : 
ITERABLE             : 
LCURLYBRACKET        : 12 37 39 40 45 82
LESSTHAN             : 15 42 43 62 64
LIST                 : 
LPAREN               : 37 40 42 43 44 45 77
LSQUAREBRACKET       : 
MAIN                 : 
MAP                  : 13 14
METHOD               : 
MINUS                : 92
NOTEQUAL             : 
OF                   : 44
OPENWRITE            : 
OR                   : 76
PLUS                 : 91
PRINT                : 
RCURLYBRACKET        : 12 37 39 40 45 82
READLINESYNC         : 
REQUIRED             : 84
RETURN               : 45
RPAREN               : 37 40 42 43 44 45 77
RSQUAREBRACKET       : 
SEMICOLON            : 9 12 40 40 42 43 44 45 77 95 96
SET                  : 
STACK                : 42 43 44
STR                  : 48 60 72 72
STRING               : 19
TIMES                : 93
TRY                  : 
VAR                  : 17
VOID                 : 23
WHILE                : 
WRITE                : 
error                : 

Nonterminals, with rules where they appear

class                : 0
class_content        : 10 11
class_content_repeat : 1 11 37 39 40
condition            : 40 73 74
condition_connector  : 74
condition_operator   : 68 69 70 71 72
condition_values     : 68 69
conditions           : 37 74
datatype             : 15 15 42 43 77 78 84 95 96
declarationExpression : 5 40
deniable_values      : 55 56
elifStatement        : 35 36
elifStatement_repeat : 34 36
empty                : 27 52 79 83
expression           : 9 45 77 96
forStatement         : 6
function_argument    : 80 81
function_arguments_repeat : 45 77 81
function_lambda      : 4
ifElseStatement      : 3
ifStatement          : 33 34 38
inferedReturnFunction : 8
map                  : 2
map_content          : 12
map_identifier       : 12 24
map_key              : 28
map_pair             : 29 30
map_pairs            : 26 30
map_type_specified   : 14
map_value            : 28
negation_values      : 57
number               : 71 71 90
operableTypes        : 87 87
operatorExpression   : 41 41 87
optFunction_argument : 85 86
optFunction_arguments : 82 86
optFunction_argumentsExpression : 77
opt_value            : 42
returnType           : 16
stack                : 7
taskStatement        : 40
value                : 31 32 51 88

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . class_content_repeat
    (10) class_content_repeat -> . class_content
    (11) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . stack
    (8) class_content -> . inferedReturnFunction
    (9) class_content -> . expression SEMICOLON
    (12) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) ifElseStatement -> . ifStatement
    (34) ifElseStatement -> . ifStatement elifStatement_repeat
    (77) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (40) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (42) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (45) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    FOR             shift and go to state 16
    FINAL           shift and go to state 17
    IDENTIFIER      shift and go to state 13
    MAP             shift and go to state 20
    IF              shift and go to state 21
    VAR             shift and go to state 23
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34

    class                          shift and go to state 1
    class_content_repeat           shift and go to state 2
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    stack                          shift and go to state 9
    inferedReturnFunction          shift and go to state 10
    expression                     shift and go to state 11
    map_identifier                 shift and go to state 12
    ifStatement                    shift and go to state 14
    datatype                       shift and go to state 15
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    returnType                     shift and go to state 22
    number                         shift and go to state 24

state 1

    (0) S' -> class .



state 2

    (1) class -> class_content_repeat .
    (11) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . stack
    (8) class_content -> . inferedReturnFunction
    (9) class_content -> . expression SEMICOLON
    (12) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) ifElseStatement -> . ifStatement
    (34) ifElseStatement -> . ifStatement elifStatement_repeat
    (77) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (40) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (42) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (45) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    $end            reduce using rule 1 (class -> class_content_repeat .)
    FOR             shift and go to state 16
    FINAL           shift and go to state 17
    IDENTIFIER      shift and go to state 13
    MAP             shift and go to state 20
    IF              shift and go to state 21
    VAR             shift and go to state 23
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34

    class_content                  shift and go to state 35
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    stack                          shift and go to state 9
    inferedReturnFunction          shift and go to state 10
    expression                     shift and go to state 11
    map_identifier                 shift and go to state 12
    ifStatement                    shift and go to state 14
    datatype                       shift and go to state 15
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    returnType                     shift and go to state 22
    number                         shift and go to state 24

state 3

    (10) class_content_repeat -> class_content .

    FOR             reduce using rule 10 (class_content_repeat -> class_content .)
    FINAL           reduce using rule 10 (class_content_repeat -> class_content .)
    IDENTIFIER      reduce using rule 10 (class_content_repeat -> class_content .)
    MAP             reduce using rule 10 (class_content_repeat -> class_content .)
    IF              reduce using rule 10 (class_content_repeat -> class_content .)
    VAR             reduce using rule 10 (class_content_repeat -> class_content .)
    INTEGER         reduce using rule 10 (class_content_repeat -> class_content .)
    FLOAT           reduce using rule 10 (class_content_repeat -> class_content .)
    STR             reduce using rule 10 (class_content_repeat -> class_content .)
    BOOLEAN         reduce using rule 10 (class_content_repeat -> class_content .)
    INT             reduce using rule 10 (class_content_repeat -> class_content .)
    STRING          reduce using rule 10 (class_content_repeat -> class_content .)
    BOOL            reduce using rule 10 (class_content_repeat -> class_content .)
    DOUBLE          reduce using rule 10 (class_content_repeat -> class_content .)
    DYNAMIC         reduce using rule 10 (class_content_repeat -> class_content .)
    VOID            reduce using rule 10 (class_content_repeat -> class_content .)
    $end            reduce using rule 10 (class_content_repeat -> class_content .)
    RCURLYBRACKET   reduce using rule 10 (class_content_repeat -> class_content .)


state 4

    (2) class_content -> map .

    FOR             reduce using rule 2 (class_content -> map .)
    FINAL           reduce using rule 2 (class_content -> map .)
    IDENTIFIER      reduce using rule 2 (class_content -> map .)
    MAP             reduce using rule 2 (class_content -> map .)
    IF              reduce using rule 2 (class_content -> map .)
    VAR             reduce using rule 2 (class_content -> map .)
    INTEGER         reduce using rule 2 (class_content -> map .)
    FLOAT           reduce using rule 2 (class_content -> map .)
    STR             reduce using rule 2 (class_content -> map .)
    BOOLEAN         reduce using rule 2 (class_content -> map .)
    INT             reduce using rule 2 (class_content -> map .)
    STRING          reduce using rule 2 (class_content -> map .)
    BOOL            reduce using rule 2 (class_content -> map .)
    DOUBLE          reduce using rule 2 (class_content -> map .)
    DYNAMIC         reduce using rule 2 (class_content -> map .)
    VOID            reduce using rule 2 (class_content -> map .)
    $end            reduce using rule 2 (class_content -> map .)
    RCURLYBRACKET   reduce using rule 2 (class_content -> map .)


state 5

    (3) class_content -> ifElseStatement .

    FOR             reduce using rule 3 (class_content -> ifElseStatement .)
    FINAL           reduce using rule 3 (class_content -> ifElseStatement .)
    IDENTIFIER      reduce using rule 3 (class_content -> ifElseStatement .)
    MAP             reduce using rule 3 (class_content -> ifElseStatement .)
    IF              reduce using rule 3 (class_content -> ifElseStatement .)
    VAR             reduce using rule 3 (class_content -> ifElseStatement .)
    INTEGER         reduce using rule 3 (class_content -> ifElseStatement .)
    FLOAT           reduce using rule 3 (class_content -> ifElseStatement .)
    STR             reduce using rule 3 (class_content -> ifElseStatement .)
    BOOLEAN         reduce using rule 3 (class_content -> ifElseStatement .)
    INT             reduce using rule 3 (class_content -> ifElseStatement .)
    STRING          reduce using rule 3 (class_content -> ifElseStatement .)
    BOOL            reduce using rule 3 (class_content -> ifElseStatement .)
    DOUBLE          reduce using rule 3 (class_content -> ifElseStatement .)
    DYNAMIC         reduce using rule 3 (class_content -> ifElseStatement .)
    VOID            reduce using rule 3 (class_content -> ifElseStatement .)
    $end            reduce using rule 3 (class_content -> ifElseStatement .)
    RCURLYBRACKET   reduce using rule 3 (class_content -> ifElseStatement .)


state 6

    (4) class_content -> function_lambda .

    FOR             reduce using rule 4 (class_content -> function_lambda .)
    FINAL           reduce using rule 4 (class_content -> function_lambda .)
    IDENTIFIER      reduce using rule 4 (class_content -> function_lambda .)
    MAP             reduce using rule 4 (class_content -> function_lambda .)
    IF              reduce using rule 4 (class_content -> function_lambda .)
    VAR             reduce using rule 4 (class_content -> function_lambda .)
    INTEGER         reduce using rule 4 (class_content -> function_lambda .)
    FLOAT           reduce using rule 4 (class_content -> function_lambda .)
    STR             reduce using rule 4 (class_content -> function_lambda .)
    BOOLEAN         reduce using rule 4 (class_content -> function_lambda .)
    INT             reduce using rule 4 (class_content -> function_lambda .)
    STRING          reduce using rule 4 (class_content -> function_lambda .)
    BOOL            reduce using rule 4 (class_content -> function_lambda .)
    DOUBLE          reduce using rule 4 (class_content -> function_lambda .)
    DYNAMIC         reduce using rule 4 (class_content -> function_lambda .)
    VOID            reduce using rule 4 (class_content -> function_lambda .)
    $end            reduce using rule 4 (class_content -> function_lambda .)
    RCURLYBRACKET   reduce using rule 4 (class_content -> function_lambda .)


state 7

    (5) class_content -> declarationExpression .

    FOR             reduce using rule 5 (class_content -> declarationExpression .)
    FINAL           reduce using rule 5 (class_content -> declarationExpression .)
    IDENTIFIER      reduce using rule 5 (class_content -> declarationExpression .)
    MAP             reduce using rule 5 (class_content -> declarationExpression .)
    IF              reduce using rule 5 (class_content -> declarationExpression .)
    VAR             reduce using rule 5 (class_content -> declarationExpression .)
    INTEGER         reduce using rule 5 (class_content -> declarationExpression .)
    FLOAT           reduce using rule 5 (class_content -> declarationExpression .)
    STR             reduce using rule 5 (class_content -> declarationExpression .)
    BOOLEAN         reduce using rule 5 (class_content -> declarationExpression .)
    INT             reduce using rule 5 (class_content -> declarationExpression .)
    STRING          reduce using rule 5 (class_content -> declarationExpression .)
    BOOL            reduce using rule 5 (class_content -> declarationExpression .)
    DOUBLE          reduce using rule 5 (class_content -> declarationExpression .)
    DYNAMIC         reduce using rule 5 (class_content -> declarationExpression .)
    VOID            reduce using rule 5 (class_content -> declarationExpression .)
    $end            reduce using rule 5 (class_content -> declarationExpression .)
    RCURLYBRACKET   reduce using rule 5 (class_content -> declarationExpression .)


state 8

    (6) class_content -> forStatement .

    FOR             reduce using rule 6 (class_content -> forStatement .)
    FINAL           reduce using rule 6 (class_content -> forStatement .)
    IDENTIFIER      reduce using rule 6 (class_content -> forStatement .)
    MAP             reduce using rule 6 (class_content -> forStatement .)
    IF              reduce using rule 6 (class_content -> forStatement .)
    VAR             reduce using rule 6 (class_content -> forStatement .)
    INTEGER         reduce using rule 6 (class_content -> forStatement .)
    FLOAT           reduce using rule 6 (class_content -> forStatement .)
    STR             reduce using rule 6 (class_content -> forStatement .)
    BOOLEAN         reduce using rule 6 (class_content -> forStatement .)
    INT             reduce using rule 6 (class_content -> forStatement .)
    STRING          reduce using rule 6 (class_content -> forStatement .)
    BOOL            reduce using rule 6 (class_content -> forStatement .)
    DOUBLE          reduce using rule 6 (class_content -> forStatement .)
    DYNAMIC         reduce using rule 6 (class_content -> forStatement .)
    VOID            reduce using rule 6 (class_content -> forStatement .)
    $end            reduce using rule 6 (class_content -> forStatement .)
    RCURLYBRACKET   reduce using rule 6 (class_content -> forStatement .)


state 9

    (7) class_content -> stack .

    FOR             reduce using rule 7 (class_content -> stack .)
    FINAL           reduce using rule 7 (class_content -> stack .)
    IDENTIFIER      reduce using rule 7 (class_content -> stack .)
    MAP             reduce using rule 7 (class_content -> stack .)
    IF              reduce using rule 7 (class_content -> stack .)
    VAR             reduce using rule 7 (class_content -> stack .)
    INTEGER         reduce using rule 7 (class_content -> stack .)
    FLOAT           reduce using rule 7 (class_content -> stack .)
    STR             reduce using rule 7 (class_content -> stack .)
    BOOLEAN         reduce using rule 7 (class_content -> stack .)
    INT             reduce using rule 7 (class_content -> stack .)
    STRING          reduce using rule 7 (class_content -> stack .)
    BOOL            reduce using rule 7 (class_content -> stack .)
    DOUBLE          reduce using rule 7 (class_content -> stack .)
    DYNAMIC         reduce using rule 7 (class_content -> stack .)
    VOID            reduce using rule 7 (class_content -> stack .)
    $end            reduce using rule 7 (class_content -> stack .)
    RCURLYBRACKET   reduce using rule 7 (class_content -> stack .)


state 10

    (8) class_content -> inferedReturnFunction .

    FOR             reduce using rule 8 (class_content -> inferedReturnFunction .)
    FINAL           reduce using rule 8 (class_content -> inferedReturnFunction .)
    IDENTIFIER      reduce using rule 8 (class_content -> inferedReturnFunction .)
    MAP             reduce using rule 8 (class_content -> inferedReturnFunction .)
    IF              reduce using rule 8 (class_content -> inferedReturnFunction .)
    VAR             reduce using rule 8 (class_content -> inferedReturnFunction .)
    INTEGER         reduce using rule 8 (class_content -> inferedReturnFunction .)
    FLOAT           reduce using rule 8 (class_content -> inferedReturnFunction .)
    STR             reduce using rule 8 (class_content -> inferedReturnFunction .)
    BOOLEAN         reduce using rule 8 (class_content -> inferedReturnFunction .)
    INT             reduce using rule 8 (class_content -> inferedReturnFunction .)
    STRING          reduce using rule 8 (class_content -> inferedReturnFunction .)
    BOOL            reduce using rule 8 (class_content -> inferedReturnFunction .)
    DOUBLE          reduce using rule 8 (class_content -> inferedReturnFunction .)
    DYNAMIC         reduce using rule 8 (class_content -> inferedReturnFunction .)
    VOID            reduce using rule 8 (class_content -> inferedReturnFunction .)
    $end            reduce using rule 8 (class_content -> inferedReturnFunction .)
    RCURLYBRACKET   reduce using rule 8 (class_content -> inferedReturnFunction .)


state 11

    (9) class_content -> expression . SEMICOLON

    SEMICOLON       shift and go to state 36


state 12

    (12) map -> map_identifier . IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (24) returnType -> map_identifier .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 37

  ! IDENTIFIER      [ reduce using rule 24 (returnType -> map_identifier .) ]


state 13

    (45) inferedReturnFunction -> IDENTIFIER . LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (89) operableTypes -> IDENTIFIER .
    (50) value -> IDENTIFIER .

    LPAREN          shift and go to state 38
    PLUS            reduce using rule 89 (operableTypes -> IDENTIFIER .)
    MINUS           reduce using rule 89 (operableTypes -> IDENTIFIER .)
    TIMES           reduce using rule 89 (operableTypes -> IDENTIFIER .)
    DIVISION        reduce using rule 89 (operableTypes -> IDENTIFIER .)
    SEMICOLON       reduce using rule 50 (value -> IDENTIFIER .)


state 14

    (33) ifElseStatement -> ifStatement .
    (34) ifElseStatement -> ifStatement . elifStatement_repeat
    (35) elifStatement_repeat -> . elifStatement
    (36) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (38) elifStatement -> . ELSE ifStatement
    (39) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    FOR             reduce using rule 33 (ifElseStatement -> ifStatement .)
    FINAL           reduce using rule 33 (ifElseStatement -> ifStatement .)
    IDENTIFIER      reduce using rule 33 (ifElseStatement -> ifStatement .)
    MAP             reduce using rule 33 (ifElseStatement -> ifStatement .)
    IF              reduce using rule 33 (ifElseStatement -> ifStatement .)
    VAR             reduce using rule 33 (ifElseStatement -> ifStatement .)
    INTEGER         reduce using rule 33 (ifElseStatement -> ifStatement .)
    FLOAT           reduce using rule 33 (ifElseStatement -> ifStatement .)
    STR             reduce using rule 33 (ifElseStatement -> ifStatement .)
    BOOLEAN         reduce using rule 33 (ifElseStatement -> ifStatement .)
    INT             reduce using rule 33 (ifElseStatement -> ifStatement .)
    STRING          reduce using rule 33 (ifElseStatement -> ifStatement .)
    BOOL            reduce using rule 33 (ifElseStatement -> ifStatement .)
    DOUBLE          reduce using rule 33 (ifElseStatement -> ifStatement .)
    DYNAMIC         reduce using rule 33 (ifElseStatement -> ifStatement .)
    VOID            reduce using rule 33 (ifElseStatement -> ifStatement .)
    $end            reduce using rule 33 (ifElseStatement -> ifStatement .)
    RCURLYBRACKET   reduce using rule 33 (ifElseStatement -> ifStatement .)
    ELSE            shift and go to state 41

    elifStatement_repeat           shift and go to state 39
    elifStatement                  shift and go to state 40

state 15

    (77) function_lambda -> datatype . IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> datatype . IDENTIFIER SEMICOLON
    (96) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 42


state 16

    (40) forStatement -> FOR . LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 43


state 17

    (42) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> FINAL . IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> FINAL . IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 44


state 18

    (87) expression -> operableTypes . operatorExpression operableTypes
    (91) operatorExpression -> . PLUS
    (92) operatorExpression -> . MINUS
    (93) operatorExpression -> . TIMES
    (94) operatorExpression -> . DIVISION

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVISION        shift and go to state 49

    operatorExpression             shift and go to state 45

state 19

    (88) expression -> value .

    SEMICOLON       reduce using rule 88 (expression -> value .)


state 20

    (13) map_identifier -> MAP .
    (14) map_identifier -> MAP . map_type_specified
    (15) map_type_specified -> . LESSTHAN datatype COMMA datatype GREATERTHAN

    IDENTIFIER      reduce using rule 13 (map_identifier -> MAP .)
    COMMA           reduce using rule 13 (map_identifier -> MAP .)
    GREATERTHAN     reduce using rule 13 (map_identifier -> MAP .)
    LESSTHAN        shift and go to state 51

    map_type_specified             shift and go to state 50

state 21

    (37) ifStatement -> IF . LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LPAREN          shift and go to state 52


state 22

    (16) datatype -> returnType .

    IDENTIFIER      reduce using rule 16 (datatype -> returnType .)
    COMMA           reduce using rule 16 (datatype -> returnType .)
    GREATERTHAN     reduce using rule 16 (datatype -> returnType .)


state 23

    (17) datatype -> VAR .

    IDENTIFIER      reduce using rule 17 (datatype -> VAR .)
    COMMA           reduce using rule 17 (datatype -> VAR .)
    GREATERTHAN     reduce using rule 17 (datatype -> VAR .)


state 24

    (90) operableTypes -> number .

    PLUS            reduce using rule 90 (operableTypes -> number .)
    MINUS           reduce using rule 90 (operableTypes -> number .)
    TIMES           reduce using rule 90 (operableTypes -> number .)
    DIVISION        reduce using rule 90 (operableTypes -> number .)
    SEMICOLON       reduce using rule 90 (operableTypes -> number .)


state 25

    (46) value -> INTEGER .
    (67) number -> INTEGER .

    SEMICOLON       reduce using rule 46 (value -> INTEGER .)
    PLUS            reduce using rule 67 (number -> INTEGER .)
    MINUS           reduce using rule 67 (number -> INTEGER .)
    TIMES           reduce using rule 67 (number -> INTEGER .)
    DIVISION        reduce using rule 67 (number -> INTEGER .)


state 26

    (47) value -> FLOAT .
    (66) number -> FLOAT .

    SEMICOLON       reduce using rule 47 (value -> FLOAT .)
    PLUS            reduce using rule 66 (number -> FLOAT .)
    MINUS           reduce using rule 66 (number -> FLOAT .)
    TIMES           reduce using rule 66 (number -> FLOAT .)
    DIVISION        reduce using rule 66 (number -> FLOAT .)


state 27

    (48) value -> STR .

    SEMICOLON       reduce using rule 48 (value -> STR .)
    COLON           reduce using rule 48 (value -> STR .)
    COMMA           reduce using rule 48 (value -> STR .)
    RCURLYBRACKET   reduce using rule 48 (value -> STR .)
    RPAREN          reduce using rule 48 (value -> STR .)


state 28

    (49) value -> BOOLEAN .

    SEMICOLON       reduce using rule 49 (value -> BOOLEAN .)
    COLON           reduce using rule 49 (value -> BOOLEAN .)
    COMMA           reduce using rule 49 (value -> BOOLEAN .)
    RCURLYBRACKET   reduce using rule 49 (value -> BOOLEAN .)
    RPAREN          reduce using rule 49 (value -> BOOLEAN .)


state 29

    (18) returnType -> INT .

    IDENTIFIER      reduce using rule 18 (returnType -> INT .)
    COMMA           reduce using rule 18 (returnType -> INT .)
    GREATERTHAN     reduce using rule 18 (returnType -> INT .)


state 30

    (19) returnType -> STRING .

    IDENTIFIER      reduce using rule 19 (returnType -> STRING .)
    COMMA           reduce using rule 19 (returnType -> STRING .)
    GREATERTHAN     reduce using rule 19 (returnType -> STRING .)


state 31

    (20) returnType -> BOOL .

    IDENTIFIER      reduce using rule 20 (returnType -> BOOL .)
    COMMA           reduce using rule 20 (returnType -> BOOL .)
    GREATERTHAN     reduce using rule 20 (returnType -> BOOL .)


state 32

    (21) returnType -> DOUBLE .

    IDENTIFIER      reduce using rule 21 (returnType -> DOUBLE .)
    COMMA           reduce using rule 21 (returnType -> DOUBLE .)
    GREATERTHAN     reduce using rule 21 (returnType -> DOUBLE .)


state 33

    (22) returnType -> DYNAMIC .

    IDENTIFIER      reduce using rule 22 (returnType -> DYNAMIC .)
    COMMA           reduce using rule 22 (returnType -> DYNAMIC .)
    GREATERTHAN     reduce using rule 22 (returnType -> DYNAMIC .)


state 34

    (23) returnType -> VOID .

    IDENTIFIER      reduce using rule 23 (returnType -> VOID .)
    COMMA           reduce using rule 23 (returnType -> VOID .)
    GREATERTHAN     reduce using rule 23 (returnType -> VOID .)


state 35

    (11) class_content_repeat -> class_content_repeat class_content .

    FOR             reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    FINAL           reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    IDENTIFIER      reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    MAP             reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    IF              reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    VAR             reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    INTEGER         reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    FLOAT           reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    STR             reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    BOOLEAN         reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    INT             reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    STRING          reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    BOOL            reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    DOUBLE          reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    DYNAMIC         reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    VOID            reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    $end            reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)
    RCURLYBRACKET   reduce using rule 11 (class_content_repeat -> class_content_repeat class_content .)


state 36

    (9) class_content -> expression SEMICOLON .

    FOR             reduce using rule 9 (class_content -> expression SEMICOLON .)
    FINAL           reduce using rule 9 (class_content -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 9 (class_content -> expression SEMICOLON .)
    MAP             reduce using rule 9 (class_content -> expression SEMICOLON .)
    IF              reduce using rule 9 (class_content -> expression SEMICOLON .)
    VAR             reduce using rule 9 (class_content -> expression SEMICOLON .)
    INTEGER         reduce using rule 9 (class_content -> expression SEMICOLON .)
    FLOAT           reduce using rule 9 (class_content -> expression SEMICOLON .)
    STR             reduce using rule 9 (class_content -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 9 (class_content -> expression SEMICOLON .)
    INT             reduce using rule 9 (class_content -> expression SEMICOLON .)
    STRING          reduce using rule 9 (class_content -> expression SEMICOLON .)
    BOOL            reduce using rule 9 (class_content -> expression SEMICOLON .)
    DOUBLE          reduce using rule 9 (class_content -> expression SEMICOLON .)
    DYNAMIC         reduce using rule 9 (class_content -> expression SEMICOLON .)
    VOID            reduce using rule 9 (class_content -> expression SEMICOLON .)
    $end            reduce using rule 9 (class_content -> expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 9 (class_content -> expression SEMICOLON .)


state 37

    (12) map -> map_identifier IDENTIFIER . EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    EQUAL           shift and go to state 53


state 38

    (45) inferedReturnFunction -> IDENTIFIER LPAREN . function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (80) function_arguments_repeat -> . function_argument
    (81) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (78) function_argument -> . datatype IDENTIFIER
    (79) function_argument -> . empty
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (25) empty -> .
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 23
    COMMA           reduce using rule 25 (empty -> .)
    RPAREN          reduce using rule 25 (empty -> .)
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34
    MAP             shift and go to state 20

    function_arguments_repeat      shift and go to state 54
    function_argument              shift and go to state 55
    datatype                       shift and go to state 56
    empty                          shift and go to state 57
    returnType                     shift and go to state 22
    map_identifier                 shift and go to state 58

state 39

    (34) ifElseStatement -> ifStatement elifStatement_repeat .

    FOR             reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FINAL           reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    MAP             reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    IF              reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VAR             reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STR             reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    INT             reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    STRING          reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    BOOL            reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    VOID            reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    $end            reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 34 (ifElseStatement -> ifStatement elifStatement_repeat .)


state 40

    (35) elifStatement_repeat -> elifStatement .
    (36) elifStatement_repeat -> elifStatement . elifStatement_repeat
    (35) elifStatement_repeat -> . elifStatement
    (36) elifStatement_repeat -> . elifStatement elifStatement_repeat
    (38) elifStatement -> . ELSE ifStatement
    (39) elifStatement -> . ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET

    FOR             reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    FINAL           reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    IDENTIFIER      reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    MAP             reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    IF              reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    VAR             reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    INTEGER         reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    FLOAT           reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    STR             reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    BOOLEAN         reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    INT             reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    STRING          reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    BOOL            reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    DOUBLE          reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    DYNAMIC         reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    VOID            reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    $end            reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    RCURLYBRACKET   reduce using rule 35 (elifStatement_repeat -> elifStatement .)
    ELSE            shift and go to state 41

    elifStatement                  shift and go to state 40
    elifStatement_repeat           shift and go to state 59

state 41

    (38) elifStatement -> ELSE . ifStatement
    (39) elifStatement -> ELSE . LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 61
    IF              shift and go to state 21

    ifStatement                    shift and go to state 60

state 42

    (77) function_lambda -> datatype IDENTIFIER . LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> datatype IDENTIFIER . SEMICOLON
    (96) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON

    LPAREN          shift and go to state 62
    SEMICOLON       shift and go to state 64
    EQUAL           shift and go to state 63


state 43

    (40) forStatement -> FOR LPAREN . declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 23
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34
    MAP             shift and go to state 20

    declarationExpression          shift and go to state 65
    datatype                       shift and go to state 66
    returnType                     shift and go to state 22
    map_identifier                 shift and go to state 58

state 44

    (42) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> FINAL IDENTIFIER . EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> FINAL IDENTIFIER . EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    EQUAL           shift and go to state 67


state 45

    (87) expression -> operableTypes operatorExpression . operableTypes
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    IDENTIFIER      shift and go to state 69
    FLOAT           shift and go to state 70
    INTEGER         shift and go to state 71

    operableTypes                  shift and go to state 68
    number                         shift and go to state 24

state 46

    (91) operatorExpression -> PLUS .

    IDENTIFIER      reduce using rule 91 (operatorExpression -> PLUS .)
    FLOAT           reduce using rule 91 (operatorExpression -> PLUS .)
    INTEGER         reduce using rule 91 (operatorExpression -> PLUS .)
    PLUS            reduce using rule 91 (operatorExpression -> PLUS .)
    MINUS           reduce using rule 91 (operatorExpression -> PLUS .)
    TIMES           reduce using rule 91 (operatorExpression -> PLUS .)
    DIVISION        reduce using rule 91 (operatorExpression -> PLUS .)
    RPAREN          reduce using rule 91 (operatorExpression -> PLUS .)


state 47

    (92) operatorExpression -> MINUS .

    IDENTIFIER      reduce using rule 92 (operatorExpression -> MINUS .)
    FLOAT           reduce using rule 92 (operatorExpression -> MINUS .)
    INTEGER         reduce using rule 92 (operatorExpression -> MINUS .)
    PLUS            reduce using rule 92 (operatorExpression -> MINUS .)
    MINUS           reduce using rule 92 (operatorExpression -> MINUS .)
    TIMES           reduce using rule 92 (operatorExpression -> MINUS .)
    DIVISION        reduce using rule 92 (operatorExpression -> MINUS .)
    RPAREN          reduce using rule 92 (operatorExpression -> MINUS .)


state 48

    (93) operatorExpression -> TIMES .

    IDENTIFIER      reduce using rule 93 (operatorExpression -> TIMES .)
    FLOAT           reduce using rule 93 (operatorExpression -> TIMES .)
    INTEGER         reduce using rule 93 (operatorExpression -> TIMES .)
    PLUS            reduce using rule 93 (operatorExpression -> TIMES .)
    MINUS           reduce using rule 93 (operatorExpression -> TIMES .)
    TIMES           reduce using rule 93 (operatorExpression -> TIMES .)
    DIVISION        reduce using rule 93 (operatorExpression -> TIMES .)
    RPAREN          reduce using rule 93 (operatorExpression -> TIMES .)


state 49

    (94) operatorExpression -> DIVISION .

    IDENTIFIER      reduce using rule 94 (operatorExpression -> DIVISION .)
    FLOAT           reduce using rule 94 (operatorExpression -> DIVISION .)
    INTEGER         reduce using rule 94 (operatorExpression -> DIVISION .)
    PLUS            reduce using rule 94 (operatorExpression -> DIVISION .)
    MINUS           reduce using rule 94 (operatorExpression -> DIVISION .)
    TIMES           reduce using rule 94 (operatorExpression -> DIVISION .)
    DIVISION        reduce using rule 94 (operatorExpression -> DIVISION .)
    RPAREN          reduce using rule 94 (operatorExpression -> DIVISION .)


state 50

    (14) map_identifier -> MAP map_type_specified .

    IDENTIFIER      reduce using rule 14 (map_identifier -> MAP map_type_specified .)
    COMMA           reduce using rule 14 (map_identifier -> MAP map_type_specified .)
    GREATERTHAN     reduce using rule 14 (map_identifier -> MAP map_type_specified .)


state 51

    (15) map_type_specified -> LESSTHAN . datatype COMMA datatype GREATERTHAN
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 23
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34
    MAP             shift and go to state 20

    datatype                       shift and go to state 72
    returnType                     shift and go to state 22
    map_identifier                 shift and go to state 58

state 52

    (37) ifStatement -> IF LPAREN . conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (73) conditions -> . condition
    (74) conditions -> . condition condition_connector conditions
    (68) condition -> . IDENTIFIER condition_operator condition_values
    (69) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (70) condition -> . BOOLEAN condition_operator BOOLEAN
    (71) condition -> . number condition_operator number
    (72) condition -> . STR condition_operator STR
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    IDENTIFIER      shift and go to state 75
    EXMARK          shift and go to state 76
    BOOLEAN         shift and go to state 77
    STR             shift and go to state 79
    FLOAT           shift and go to state 70
    INTEGER         shift and go to state 71

    conditions                     shift and go to state 73
    condition                      shift and go to state 74
    number                         shift and go to state 78

state 53

    (12) map -> map_identifier IDENTIFIER EQUAL . LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON

    LCURLYBRACKET   shift and go to state 80


state 54

    (45) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat . RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    RPAREN          shift and go to state 81


state 55

    (80) function_arguments_repeat -> function_argument .
    (81) function_arguments_repeat -> function_argument . COMMA function_arguments_repeat

    RPAREN          reduce using rule 80 (function_arguments_repeat -> function_argument .)
    LCURLYBRACKET   reduce using rule 80 (function_arguments_repeat -> function_argument .)
    COMMA           shift and go to state 82


state 56

    (78) function_argument -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 83


state 57

    (79) function_argument -> empty .

    COMMA           reduce using rule 79 (function_argument -> empty .)
    RPAREN          reduce using rule 79 (function_argument -> empty .)
    LCURLYBRACKET   reduce using rule 79 (function_argument -> empty .)


state 58

    (24) returnType -> map_identifier .

    IDENTIFIER      reduce using rule 24 (returnType -> map_identifier .)
    COMMA           reduce using rule 24 (returnType -> map_identifier .)
    GREATERTHAN     reduce using rule 24 (returnType -> map_identifier .)


state 59

    (36) elifStatement_repeat -> elifStatement elifStatement_repeat .

    FOR             reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FINAL           reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IDENTIFIER      reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    MAP             reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    IF              reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VAR             reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INTEGER         reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    FLOAT           reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STR             reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOLEAN         reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    INT             reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    STRING          reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    BOOL            reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DOUBLE          reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    DYNAMIC         reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    VOID            reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    $end            reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)
    RCURLYBRACKET   reduce using rule 36 (elifStatement_repeat -> elifStatement elifStatement_repeat .)


state 60

    (38) elifStatement -> ELSE ifStatement .

    ELSE            reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    FOR             reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    FINAL           reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    IDENTIFIER      reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    MAP             reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    IF              reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    VAR             reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    INTEGER         reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    FLOAT           reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    STR             reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    BOOLEAN         reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    INT             reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    STRING          reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    BOOL            reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    DOUBLE          reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    DYNAMIC         reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    VOID            reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    $end            reduce using rule 38 (elifStatement -> ELSE ifStatement .)
    RCURLYBRACKET   reduce using rule 38 (elifStatement -> ELSE ifStatement .)


state 61

    (39) elifStatement -> ELSE LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (10) class_content_repeat -> . class_content
    (11) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . stack
    (8) class_content -> . inferedReturnFunction
    (9) class_content -> . expression SEMICOLON
    (12) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) ifElseStatement -> . ifStatement
    (34) ifElseStatement -> . ifStatement elifStatement_repeat
    (77) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (40) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (42) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (45) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    FOR             shift and go to state 16
    FINAL           shift and go to state 17
    IDENTIFIER      shift and go to state 13
    MAP             shift and go to state 20
    IF              shift and go to state 21
    VAR             shift and go to state 23
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34

    class_content_repeat           shift and go to state 84
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    stack                          shift and go to state 9
    inferedReturnFunction          shift and go to state 10
    expression                     shift and go to state 11
    map_identifier                 shift and go to state 12
    ifStatement                    shift and go to state 14
    datatype                       shift and go to state 15
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    returnType                     shift and go to state 22
    number                         shift and go to state 24

state 62

    (77) function_lambda -> datatype IDENTIFIER LPAREN . function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (80) function_arguments_repeat -> . function_argument
    (81) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (78) function_argument -> . datatype IDENTIFIER
    (79) function_argument -> . empty
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (25) empty -> .
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 23
    COMMA           reduce using rule 25 (empty -> .)
    LCURLYBRACKET   reduce using rule 25 (empty -> .)
    RPAREN          reduce using rule 25 (empty -> .)
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34
    MAP             shift and go to state 20

    datatype                       shift and go to state 56
    function_arguments_repeat      shift and go to state 85
    function_argument              shift and go to state 55
    empty                          shift and go to state 57
    returnType                     shift and go to state 22
    map_identifier                 shift and go to state 58

state 63

    (96) declarationExpression -> datatype IDENTIFIER EQUAL . expression SEMICOLON
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    IDENTIFIER      shift and go to state 86
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28

    expression                     shift and go to state 87
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    number                         shift and go to state 24

state 64

    (95) declarationExpression -> datatype IDENTIFIER SEMICOLON .

    FOR             reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    FINAL           reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    MAP             reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    IF              reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    VAR             reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    STR             reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    INT             reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    DYNAMIC         reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    $end            reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)
    RCURLYBRACKET   reduce using rule 95 (declarationExpression -> datatype IDENTIFIER SEMICOLON .)


state 65

    (40) forStatement -> FOR LPAREN declarationExpression . SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    SEMICOLON       shift and go to state 88


state 66

    (95) declarationExpression -> datatype . IDENTIFIER SEMICOLON
    (96) declarationExpression -> datatype . IDENTIFIER EQUAL expression SEMICOLON

    IDENTIFIER      shift and go to state 89


state 67

    (42) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> FINAL IDENTIFIER EQUAL . STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> FINAL IDENTIFIER EQUAL . STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    STACK           shift and go to state 90


state 68

    (87) expression -> operableTypes operatorExpression operableTypes .

    SEMICOLON       reduce using rule 87 (expression -> operableTypes operatorExpression operableTypes .)


state 69

    (89) operableTypes -> IDENTIFIER .

    SEMICOLON       reduce using rule 89 (operableTypes -> IDENTIFIER .)


state 70

    (66) number -> FLOAT .

    SEMICOLON       reduce using rule 66 (number -> FLOAT .)
    DOUBLEQUAL      reduce using rule 66 (number -> FLOAT .)
    LESSTHAN        reduce using rule 66 (number -> FLOAT .)
    GREATERTHAN     reduce using rule 66 (number -> FLOAT .)
    AND             reduce using rule 66 (number -> FLOAT .)
    OR              reduce using rule 66 (number -> FLOAT .)
    RPAREN          reduce using rule 66 (number -> FLOAT .)


state 71

    (67) number -> INTEGER .

    SEMICOLON       reduce using rule 67 (number -> INTEGER .)
    DOUBLEQUAL      reduce using rule 67 (number -> INTEGER .)
    LESSTHAN        reduce using rule 67 (number -> INTEGER .)
    GREATERTHAN     reduce using rule 67 (number -> INTEGER .)
    AND             reduce using rule 67 (number -> INTEGER .)
    OR              reduce using rule 67 (number -> INTEGER .)
    RPAREN          reduce using rule 67 (number -> INTEGER .)


state 72

    (15) map_type_specified -> LESSTHAN datatype . COMMA datatype GREATERTHAN

    COMMA           shift and go to state 91


state 73

    (37) ifStatement -> IF LPAREN conditions . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 92


state 74

    (73) conditions -> condition .
    (74) conditions -> condition . condition_connector conditions
    (75) condition_connector -> . AND
    (76) condition_connector -> . OR

    RPAREN          reduce using rule 73 (conditions -> condition .)
    AND             shift and go to state 94
    OR              shift and go to state 95

    condition_connector            shift and go to state 93

state 75

    (68) condition -> IDENTIFIER . condition_operator condition_values
    (61) condition_operator -> . DOUBLEQUAL
    (62) condition_operator -> . LESSTHAN
    (63) condition_operator -> . GREATERTHAN
    (64) condition_operator -> . LESSTHAN EQUAL
    (65) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 97
    LESSTHAN        shift and go to state 98
    GREATERTHAN     shift and go to state 99

    condition_operator             shift and go to state 96

state 76

    (69) condition -> EXMARK . IDENTIFIER condition_operator condition_values

    IDENTIFIER      shift and go to state 100


state 77

    (70) condition -> BOOLEAN . condition_operator BOOLEAN
    (61) condition_operator -> . DOUBLEQUAL
    (62) condition_operator -> . LESSTHAN
    (63) condition_operator -> . GREATERTHAN
    (64) condition_operator -> . LESSTHAN EQUAL
    (65) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 97
    LESSTHAN        shift and go to state 98
    GREATERTHAN     shift and go to state 99

    condition_operator             shift and go to state 101

state 78

    (71) condition -> number . condition_operator number
    (61) condition_operator -> . DOUBLEQUAL
    (62) condition_operator -> . LESSTHAN
    (63) condition_operator -> . GREATERTHAN
    (64) condition_operator -> . LESSTHAN EQUAL
    (65) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 97
    LESSTHAN        shift and go to state 98
    GREATERTHAN     shift and go to state 99

    condition_operator             shift and go to state 102

state 79

    (72) condition -> STR . condition_operator STR
    (61) condition_operator -> . DOUBLEQUAL
    (62) condition_operator -> . LESSTHAN
    (63) condition_operator -> . GREATERTHAN
    (64) condition_operator -> . LESSTHAN EQUAL
    (65) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 97
    LESSTHAN        shift and go to state 98
    GREATERTHAN     shift and go to state 99

    condition_operator             shift and go to state 103

state 80

    (12) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET . map_content RCURLYBRACKET SEMICOLON
    (26) map_content -> . map_pairs
    (27) map_content -> . empty
    (29) map_pairs -> . map_pair
    (30) map_pairs -> . map_pair COMMA map_pairs
    (25) empty -> .
    (28) map_pair -> . map_key COLON map_value
    (31) map_key -> . value
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER

    RCURLYBRACKET   reduce using rule 25 (empty -> .)
    INTEGER         shift and go to state 111
    FLOAT           shift and go to state 112
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    IDENTIFIER      shift and go to state 104

    map_content                    shift and go to state 105
    map_pairs                      shift and go to state 106
    empty                          shift and go to state 107
    map_pair                       shift and go to state 108
    map_key                        shift and go to state 109
    value                          shift and go to state 110

state 81

    (45) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN . LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 113


state 82

    (81) function_arguments_repeat -> function_argument COMMA . function_arguments_repeat
    (80) function_arguments_repeat -> . function_argument
    (81) function_arguments_repeat -> . function_argument COMMA function_arguments_repeat
    (78) function_argument -> . datatype IDENTIFIER
    (79) function_argument -> . empty
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (25) empty -> .
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 23
    COMMA           reduce using rule 25 (empty -> .)
    RPAREN          reduce using rule 25 (empty -> .)
    LCURLYBRACKET   reduce using rule 25 (empty -> .)
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34
    MAP             shift and go to state 20

    function_argument              shift and go to state 55
    function_arguments_repeat      shift and go to state 114
    datatype                       shift and go to state 56
    empty                          shift and go to state 57
    returnType                     shift and go to state 22
    map_identifier                 shift and go to state 58

state 83

    (78) function_argument -> datatype IDENTIFIER .

    COMMA           reduce using rule 78 (function_argument -> datatype IDENTIFIER .)
    RPAREN          reduce using rule 78 (function_argument -> datatype IDENTIFIER .)
    LCURLYBRACKET   reduce using rule 78 (function_argument -> datatype IDENTIFIER .)


state 84

    (39) elifStatement -> ELSE LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (11) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . stack
    (8) class_content -> . inferedReturnFunction
    (9) class_content -> . expression SEMICOLON
    (12) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) ifElseStatement -> . ifStatement
    (34) ifElseStatement -> . ifStatement elifStatement_repeat
    (77) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (40) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (42) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (45) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    RCURLYBRACKET   shift and go to state 115
    FOR             shift and go to state 16
    FINAL           shift and go to state 17
    IDENTIFIER      shift and go to state 13
    MAP             shift and go to state 20
    IF              shift and go to state 21
    VAR             shift and go to state 23
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34

    class_content                  shift and go to state 35
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    stack                          shift and go to state 9
    inferedReturnFunction          shift and go to state 10
    expression                     shift and go to state 11
    map_identifier                 shift and go to state 12
    ifStatement                    shift and go to state 14
    datatype                       shift and go to state 15
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    returnType                     shift and go to state 22
    number                         shift and go to state 24

state 85

    (77) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat . optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (82) optFunction_argumentsExpression -> . LCURLYBRACKET optFunction_arguments RCURLYBRACKET
    (83) optFunction_argumentsExpression -> . empty
    (25) empty -> .

    LCURLYBRACKET   shift and go to state 117
    RPAREN          reduce using rule 25 (empty -> .)

    optFunction_argumentsExpression shift and go to state 116
    empty                          shift and go to state 118

state 86

    (89) operableTypes -> IDENTIFIER .
    (50) value -> IDENTIFIER .

    PLUS            reduce using rule 89 (operableTypes -> IDENTIFIER .)
    MINUS           reduce using rule 89 (operableTypes -> IDENTIFIER .)
    TIMES           reduce using rule 89 (operableTypes -> IDENTIFIER .)
    DIVISION        reduce using rule 89 (operableTypes -> IDENTIFIER .)
    SEMICOLON       reduce using rule 50 (value -> IDENTIFIER .)


state 87

    (96) declarationExpression -> datatype IDENTIFIER EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 119


state 88

    (40) forStatement -> FOR LPAREN declarationExpression SEMICOLON . condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (68) condition -> . IDENTIFIER condition_operator condition_values
    (69) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (70) condition -> . BOOLEAN condition_operator BOOLEAN
    (71) condition -> . number condition_operator number
    (72) condition -> . STR condition_operator STR
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    IDENTIFIER      shift and go to state 75
    EXMARK          shift and go to state 76
    BOOLEAN         shift and go to state 77
    STR             shift and go to state 79
    FLOAT           shift and go to state 70
    INTEGER         shift and go to state 71

    condition                      shift and go to state 120
    number                         shift and go to state 78

state 89

    (95) declarationExpression -> datatype IDENTIFIER . SEMICOLON
    (96) declarationExpression -> datatype IDENTIFIER . EQUAL expression SEMICOLON

    SEMICOLON       shift and go to state 64
    EQUAL           shift and go to state 63


state 90

    (42) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> FINAL IDENTIFIER EQUAL STACK . LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> FINAL IDENTIFIER EQUAL STACK . DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON

    LESSTHAN        shift and go to state 121
    DOT             shift and go to state 122


state 91

    (15) map_type_specified -> LESSTHAN datatype COMMA . datatype GREATERTHAN
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 23
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34
    MAP             shift and go to state 20

    datatype                       shift and go to state 123
    returnType                     shift and go to state 22
    map_identifier                 shift and go to state 58

state 92

    (37) ifStatement -> IF LPAREN conditions RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 124


state 93

    (74) conditions -> condition condition_connector . conditions
    (73) conditions -> . condition
    (74) conditions -> . condition condition_connector conditions
    (68) condition -> . IDENTIFIER condition_operator condition_values
    (69) condition -> . EXMARK IDENTIFIER condition_operator condition_values
    (70) condition -> . BOOLEAN condition_operator BOOLEAN
    (71) condition -> . number condition_operator number
    (72) condition -> . STR condition_operator STR
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    IDENTIFIER      shift and go to state 75
    EXMARK          shift and go to state 76
    BOOLEAN         shift and go to state 77
    STR             shift and go to state 79
    FLOAT           shift and go to state 70
    INTEGER         shift and go to state 71

    condition                      shift and go to state 74
    conditions                     shift and go to state 125
    number                         shift and go to state 78

state 94

    (75) condition_connector -> AND .

    IDENTIFIER      reduce using rule 75 (condition_connector -> AND .)
    EXMARK          reduce using rule 75 (condition_connector -> AND .)
    BOOLEAN         reduce using rule 75 (condition_connector -> AND .)
    STR             reduce using rule 75 (condition_connector -> AND .)
    FLOAT           reduce using rule 75 (condition_connector -> AND .)
    INTEGER         reduce using rule 75 (condition_connector -> AND .)


state 95

    (76) condition_connector -> OR .

    IDENTIFIER      reduce using rule 76 (condition_connector -> OR .)
    EXMARK          reduce using rule 76 (condition_connector -> OR .)
    BOOLEAN         reduce using rule 76 (condition_connector -> OR .)
    STR             reduce using rule 76 (condition_connector -> OR .)
    FLOAT           reduce using rule 76 (condition_connector -> OR .)
    INTEGER         reduce using rule 76 (condition_connector -> OR .)


state 96

    (68) condition -> IDENTIFIER condition_operator . condition_values
    (57) condition_values -> . negation_values
    (58) condition_values -> . INTEGER
    (59) condition_values -> . FLOAT
    (60) condition_values -> . STR
    (55) negation_values -> . deniable_values
    (56) negation_values -> . EXMARK deniable_values
    (53) deniable_values -> . IDENTIFIER
    (54) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 129
    FLOAT           shift and go to state 130
    STR             shift and go to state 131
    EXMARK          shift and go to state 133
    IDENTIFIER      shift and go to state 126
    BOOLEAN         shift and go to state 134

    condition_values               shift and go to state 127
    negation_values                shift and go to state 128
    deniable_values                shift and go to state 132

state 97

    (61) condition_operator -> DOUBLEQUAL .

    INTEGER         reduce using rule 61 (condition_operator -> DOUBLEQUAL .)
    FLOAT           reduce using rule 61 (condition_operator -> DOUBLEQUAL .)
    STR             reduce using rule 61 (condition_operator -> DOUBLEQUAL .)
    EXMARK          reduce using rule 61 (condition_operator -> DOUBLEQUAL .)
    IDENTIFIER      reduce using rule 61 (condition_operator -> DOUBLEQUAL .)
    BOOLEAN         reduce using rule 61 (condition_operator -> DOUBLEQUAL .)


state 98

    (62) condition_operator -> LESSTHAN .
    (64) condition_operator -> LESSTHAN . EQUAL

    INTEGER         reduce using rule 62 (condition_operator -> LESSTHAN .)
    FLOAT           reduce using rule 62 (condition_operator -> LESSTHAN .)
    STR             reduce using rule 62 (condition_operator -> LESSTHAN .)
    EXMARK          reduce using rule 62 (condition_operator -> LESSTHAN .)
    IDENTIFIER      reduce using rule 62 (condition_operator -> LESSTHAN .)
    BOOLEAN         reduce using rule 62 (condition_operator -> LESSTHAN .)
    EQUAL           shift and go to state 135


state 99

    (63) condition_operator -> GREATERTHAN .
    (65) condition_operator -> GREATERTHAN . EQUAL

    INTEGER         reduce using rule 63 (condition_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 63 (condition_operator -> GREATERTHAN .)
    STR             reduce using rule 63 (condition_operator -> GREATERTHAN .)
    EXMARK          reduce using rule 63 (condition_operator -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 63 (condition_operator -> GREATERTHAN .)
    BOOLEAN         reduce using rule 63 (condition_operator -> GREATERTHAN .)
    EQUAL           shift and go to state 136


state 100

    (69) condition -> EXMARK IDENTIFIER . condition_operator condition_values
    (61) condition_operator -> . DOUBLEQUAL
    (62) condition_operator -> . LESSTHAN
    (63) condition_operator -> . GREATERTHAN
    (64) condition_operator -> . LESSTHAN EQUAL
    (65) condition_operator -> . GREATERTHAN EQUAL

    DOUBLEQUAL      shift and go to state 97
    LESSTHAN        shift and go to state 98
    GREATERTHAN     shift and go to state 99

    condition_operator             shift and go to state 137

state 101

    (70) condition -> BOOLEAN condition_operator . BOOLEAN

    BOOLEAN         shift and go to state 138


state 102

    (71) condition -> number condition_operator . number
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    FLOAT           shift and go to state 70
    INTEGER         shift and go to state 71

    number                         shift and go to state 139

state 103

    (72) condition -> STR condition_operator . STR

    STR             shift and go to state 140


state 104

    (50) value -> IDENTIFIER .

    COLON           reduce using rule 50 (value -> IDENTIFIER .)
    COMMA           reduce using rule 50 (value -> IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 50 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 50 (value -> IDENTIFIER .)


state 105

    (12) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content . RCURLYBRACKET SEMICOLON

    RCURLYBRACKET   shift and go to state 141


state 106

    (26) map_content -> map_pairs .

    RCURLYBRACKET   reduce using rule 26 (map_content -> map_pairs .)


state 107

    (27) map_content -> empty .

    RCURLYBRACKET   reduce using rule 27 (map_content -> empty .)


state 108

    (29) map_pairs -> map_pair .
    (30) map_pairs -> map_pair . COMMA map_pairs

    RCURLYBRACKET   reduce using rule 29 (map_pairs -> map_pair .)
    COMMA           shift and go to state 142


state 109

    (28) map_pair -> map_key . COLON map_value

    COLON           shift and go to state 143


state 110

    (31) map_key -> value .

    COLON           reduce using rule 31 (map_key -> value .)


state 111

    (46) value -> INTEGER .

    COLON           reduce using rule 46 (value -> INTEGER .)
    COMMA           reduce using rule 46 (value -> INTEGER .)
    RCURLYBRACKET   reduce using rule 46 (value -> INTEGER .)
    RPAREN          reduce using rule 46 (value -> INTEGER .)


state 112

    (47) value -> FLOAT .

    COLON           reduce using rule 47 (value -> FLOAT .)
    COMMA           reduce using rule 47 (value -> FLOAT .)
    RCURLYBRACKET   reduce using rule 47 (value -> FLOAT .)
    RPAREN          reduce using rule 47 (value -> FLOAT .)


state 113

    (45) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET . RETURN expression SEMICOLON RCURLYBRACKET

    RETURN          shift and go to state 144


state 114

    (81) function_arguments_repeat -> function_argument COMMA function_arguments_repeat .

    RPAREN          reduce using rule 81 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)
    LCURLYBRACKET   reduce using rule 81 (function_arguments_repeat -> function_argument COMMA function_arguments_repeat .)


state 115

    (39) elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 39 (elifStatement -> ELSE LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 116

    (77) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression . RPAREN EQUAL GREATERTHAN expression SEMICOLON

    RPAREN          shift and go to state 145


state 117

    (82) optFunction_argumentsExpression -> LCURLYBRACKET . optFunction_arguments RCURLYBRACKET
    (85) optFunction_arguments -> . optFunction_argument
    (86) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (84) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 148

    optFunction_arguments          shift and go to state 146
    optFunction_argument           shift and go to state 147

state 118

    (83) optFunction_argumentsExpression -> empty .

    RPAREN          reduce using rule 83 (optFunction_argumentsExpression -> empty .)


state 119

    (96) declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .

    FOR             reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    MAP             reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    IF              reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VAR             reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INTEGER         reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STR             reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOLEAN         reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    INT             reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    STRING          reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    DYNAMIC         reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    VOID            reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    $end            reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 96 (declarationExpression -> datatype IDENTIFIER EQUAL expression SEMICOLON .)


state 120

    (40) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition . SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    SEMICOLON       shift and go to state 149


state 121

    (42) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN . datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 23
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34
    MAP             shift and go to state 20

    datatype                       shift and go to state 150
    returnType                     shift and go to state 22
    map_identifier                 shift and go to state 58

state 122

    (44) stack -> FINAL IDENTIFIER EQUAL STACK DOT . OF LPAREN IDENTIFIER RPAREN SEMICOLON

    OF              shift and go to state 151


state 123

    (15) map_type_specified -> LESSTHAN datatype COMMA datatype . GREATERTHAN

    GREATERTHAN     shift and go to state 152


state 124

    (37) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (10) class_content_repeat -> . class_content
    (11) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . stack
    (8) class_content -> . inferedReturnFunction
    (9) class_content -> . expression SEMICOLON
    (12) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) ifElseStatement -> . ifStatement
    (34) ifElseStatement -> . ifStatement elifStatement_repeat
    (77) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (40) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (42) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (45) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    FOR             shift and go to state 16
    FINAL           shift and go to state 17
    IDENTIFIER      shift and go to state 13
    MAP             shift and go to state 20
    IF              shift and go to state 21
    VAR             shift and go to state 23
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34

    class_content_repeat           shift and go to state 153
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    stack                          shift and go to state 9
    inferedReturnFunction          shift and go to state 10
    expression                     shift and go to state 11
    map_identifier                 shift and go to state 12
    ifStatement                    shift and go to state 14
    datatype                       shift and go to state 15
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    returnType                     shift and go to state 22
    number                         shift and go to state 24

state 125

    (74) conditions -> condition condition_connector conditions .

    RPAREN          reduce using rule 74 (conditions -> condition condition_connector conditions .)


state 126

    (53) deniable_values -> IDENTIFIER .

    AND             reduce using rule 53 (deniable_values -> IDENTIFIER .)
    OR              reduce using rule 53 (deniable_values -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (deniable_values -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (deniable_values -> IDENTIFIER .)


state 127

    (68) condition -> IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 68 (condition -> IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 68 (condition -> IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 68 (condition -> IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 68 (condition -> IDENTIFIER condition_operator condition_values .)


state 128

    (57) condition_values -> negation_values .

    AND             reduce using rule 57 (condition_values -> negation_values .)
    OR              reduce using rule 57 (condition_values -> negation_values .)
    RPAREN          reduce using rule 57 (condition_values -> negation_values .)
    SEMICOLON       reduce using rule 57 (condition_values -> negation_values .)


state 129

    (58) condition_values -> INTEGER .

    AND             reduce using rule 58 (condition_values -> INTEGER .)
    OR              reduce using rule 58 (condition_values -> INTEGER .)
    RPAREN          reduce using rule 58 (condition_values -> INTEGER .)
    SEMICOLON       reduce using rule 58 (condition_values -> INTEGER .)


state 130

    (59) condition_values -> FLOAT .

    AND             reduce using rule 59 (condition_values -> FLOAT .)
    OR              reduce using rule 59 (condition_values -> FLOAT .)
    RPAREN          reduce using rule 59 (condition_values -> FLOAT .)
    SEMICOLON       reduce using rule 59 (condition_values -> FLOAT .)


state 131

    (60) condition_values -> STR .

    AND             reduce using rule 60 (condition_values -> STR .)
    OR              reduce using rule 60 (condition_values -> STR .)
    RPAREN          reduce using rule 60 (condition_values -> STR .)
    SEMICOLON       reduce using rule 60 (condition_values -> STR .)


state 132

    (55) negation_values -> deniable_values .

    AND             reduce using rule 55 (negation_values -> deniable_values .)
    OR              reduce using rule 55 (negation_values -> deniable_values .)
    RPAREN          reduce using rule 55 (negation_values -> deniable_values .)
    SEMICOLON       reduce using rule 55 (negation_values -> deniable_values .)


state 133

    (56) negation_values -> EXMARK . deniable_values
    (53) deniable_values -> . IDENTIFIER
    (54) deniable_values -> . BOOLEAN

    IDENTIFIER      shift and go to state 126
    BOOLEAN         shift and go to state 134

    deniable_values                shift and go to state 154

state 134

    (54) deniable_values -> BOOLEAN .

    AND             reduce using rule 54 (deniable_values -> BOOLEAN .)
    OR              reduce using rule 54 (deniable_values -> BOOLEAN .)
    RPAREN          reduce using rule 54 (deniable_values -> BOOLEAN .)
    SEMICOLON       reduce using rule 54 (deniable_values -> BOOLEAN .)


state 135

    (64) condition_operator -> LESSTHAN EQUAL .

    INTEGER         reduce using rule 64 (condition_operator -> LESSTHAN EQUAL .)
    FLOAT           reduce using rule 64 (condition_operator -> LESSTHAN EQUAL .)
    STR             reduce using rule 64 (condition_operator -> LESSTHAN EQUAL .)
    EXMARK          reduce using rule 64 (condition_operator -> LESSTHAN EQUAL .)
    IDENTIFIER      reduce using rule 64 (condition_operator -> LESSTHAN EQUAL .)
    BOOLEAN         reduce using rule 64 (condition_operator -> LESSTHAN EQUAL .)


state 136

    (65) condition_operator -> GREATERTHAN EQUAL .

    INTEGER         reduce using rule 65 (condition_operator -> GREATERTHAN EQUAL .)
    FLOAT           reduce using rule 65 (condition_operator -> GREATERTHAN EQUAL .)
    STR             reduce using rule 65 (condition_operator -> GREATERTHAN EQUAL .)
    EXMARK          reduce using rule 65 (condition_operator -> GREATERTHAN EQUAL .)
    IDENTIFIER      reduce using rule 65 (condition_operator -> GREATERTHAN EQUAL .)
    BOOLEAN         reduce using rule 65 (condition_operator -> GREATERTHAN EQUAL .)


state 137

    (69) condition -> EXMARK IDENTIFIER condition_operator . condition_values
    (57) condition_values -> . negation_values
    (58) condition_values -> . INTEGER
    (59) condition_values -> . FLOAT
    (60) condition_values -> . STR
    (55) negation_values -> . deniable_values
    (56) negation_values -> . EXMARK deniable_values
    (53) deniable_values -> . IDENTIFIER
    (54) deniable_values -> . BOOLEAN

    INTEGER         shift and go to state 129
    FLOAT           shift and go to state 130
    STR             shift and go to state 131
    EXMARK          shift and go to state 133
    IDENTIFIER      shift and go to state 126
    BOOLEAN         shift and go to state 134

    condition_values               shift and go to state 155
    negation_values                shift and go to state 128
    deniable_values                shift and go to state 132

state 138

    (70) condition -> BOOLEAN condition_operator BOOLEAN .

    AND             reduce using rule 70 (condition -> BOOLEAN condition_operator BOOLEAN .)
    OR              reduce using rule 70 (condition -> BOOLEAN condition_operator BOOLEAN .)
    RPAREN          reduce using rule 70 (condition -> BOOLEAN condition_operator BOOLEAN .)
    SEMICOLON       reduce using rule 70 (condition -> BOOLEAN condition_operator BOOLEAN .)


state 139

    (71) condition -> number condition_operator number .

    AND             reduce using rule 71 (condition -> number condition_operator number .)
    OR              reduce using rule 71 (condition -> number condition_operator number .)
    RPAREN          reduce using rule 71 (condition -> number condition_operator number .)
    SEMICOLON       reduce using rule 71 (condition -> number condition_operator number .)


state 140

    (72) condition -> STR condition_operator STR .

    AND             reduce using rule 72 (condition -> STR condition_operator STR .)
    OR              reduce using rule 72 (condition -> STR condition_operator STR .)
    RPAREN          reduce using rule 72 (condition -> STR condition_operator STR .)
    SEMICOLON       reduce using rule 72 (condition -> STR condition_operator STR .)


state 141

    (12) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 156


state 142

    (30) map_pairs -> map_pair COMMA . map_pairs
    (29) map_pairs -> . map_pair
    (30) map_pairs -> . map_pair COMMA map_pairs
    (28) map_pair -> . map_key COLON map_value
    (31) map_key -> . value
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER

    INTEGER         shift and go to state 111
    FLOAT           shift and go to state 112
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    IDENTIFIER      shift and go to state 104

    map_pair                       shift and go to state 108
    map_pairs                      shift and go to state 157
    map_key                        shift and go to state 109
    value                          shift and go to state 110

state 143

    (28) map_pair -> map_key COLON . map_value
    (32) map_value -> . value
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER

    INTEGER         shift and go to state 111
    FLOAT           shift and go to state 112
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    IDENTIFIER      shift and go to state 104

    map_value                      shift and go to state 158
    value                          shift and go to state 159

state 144

    (45) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN . expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    IDENTIFIER      shift and go to state 86
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28

    expression                     shift and go to state 160
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    number                         shift and go to state 24

state 145

    (77) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN . EQUAL GREATERTHAN expression SEMICOLON

    EQUAL           shift and go to state 161


state 146

    (82) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 162


state 147

    (85) optFunction_arguments -> optFunction_argument .
    (86) optFunction_arguments -> optFunction_argument . COMMA optFunction_arguments

    RCURLYBRACKET   reduce using rule 85 (optFunction_arguments -> optFunction_argument .)
    COMMA           shift and go to state 163


state 148

    (84) optFunction_argument -> REQUIRED . datatype IDENTIFIER
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified

    VAR             shift and go to state 23
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34
    MAP             shift and go to state 20

    datatype                       shift and go to state 164
    returnType                     shift and go to state 22
    map_identifier                 shift and go to state 58

state 149

    (40) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON . taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (41) taskStatement -> . IDENTIFIER operatorExpression operatorExpression

    IDENTIFIER      shift and go to state 166

    taskStatement                  shift and go to state 165

state 150

    (42) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype . GREATERTHAN LPAREN RPAREN SEMICOLON

    GREATERTHAN     shift and go to state 167


state 151

    (44) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF . LPAREN IDENTIFIER RPAREN SEMICOLON

    LPAREN          shift and go to state 168


state 152

    (15) map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .

    IDENTIFIER      reduce using rule 15 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    COMMA           reduce using rule 15 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)
    GREATERTHAN     reduce using rule 15 (map_type_specified -> LESSTHAN datatype COMMA datatype GREATERTHAN .)


state 153

    (37) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (11) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . stack
    (8) class_content -> . inferedReturnFunction
    (9) class_content -> . expression SEMICOLON
    (12) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) ifElseStatement -> . ifStatement
    (34) ifElseStatement -> . ifStatement elifStatement_repeat
    (77) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (40) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (42) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (45) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    RCURLYBRACKET   shift and go to state 169
    FOR             shift and go to state 16
    FINAL           shift and go to state 17
    IDENTIFIER      shift and go to state 13
    MAP             shift and go to state 20
    IF              shift and go to state 21
    VAR             shift and go to state 23
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34

    class_content                  shift and go to state 35
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    declarationExpression          shift and go to state 7
    forStatement                   shift and go to state 8
    stack                          shift and go to state 9
    inferedReturnFunction          shift and go to state 10
    expression                     shift and go to state 11
    map_identifier                 shift and go to state 12
    ifStatement                    shift and go to state 14
    datatype                       shift and go to state 15
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    returnType                     shift and go to state 22
    number                         shift and go to state 24

state 154

    (56) negation_values -> EXMARK deniable_values .

    AND             reduce using rule 56 (negation_values -> EXMARK deniable_values .)
    OR              reduce using rule 56 (negation_values -> EXMARK deniable_values .)
    RPAREN          reduce using rule 56 (negation_values -> EXMARK deniable_values .)
    SEMICOLON       reduce using rule 56 (negation_values -> EXMARK deniable_values .)


state 155

    (69) condition -> EXMARK IDENTIFIER condition_operator condition_values .

    AND             reduce using rule 69 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    OR              reduce using rule 69 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    RPAREN          reduce using rule 69 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)
    SEMICOLON       reduce using rule 69 (condition -> EXMARK IDENTIFIER condition_operator condition_values .)


state 156

    (12) map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .

    FOR             reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FINAL           reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    MAP             reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    IF              reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VAR             reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INTEGER         reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    FLOAT           reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STR             reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    INT             reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    STRING          reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    BOOL            reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    VOID            reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    $end            reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)
    RCURLYBRACKET   reduce using rule 12 (map -> map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON .)


state 157

    (30) map_pairs -> map_pair COMMA map_pairs .

    RCURLYBRACKET   reduce using rule 30 (map_pairs -> map_pair COMMA map_pairs .)


state 158

    (28) map_pair -> map_key COLON map_value .

    COMMA           reduce using rule 28 (map_pair -> map_key COLON map_value .)
    RCURLYBRACKET   reduce using rule 28 (map_pair -> map_key COLON map_value .)


state 159

    (32) map_value -> value .

    COMMA           reduce using rule 32 (map_value -> value .)
    RCURLYBRACKET   reduce using rule 32 (map_value -> value .)


state 160

    (45) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression . SEMICOLON RCURLYBRACKET

    SEMICOLON       shift and go to state 170


state 161

    (77) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL . GREATERTHAN expression SEMICOLON

    GREATERTHAN     shift and go to state 171


state 162

    (82) optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .

    RPAREN          reduce using rule 82 (optFunction_argumentsExpression -> LCURLYBRACKET optFunction_arguments RCURLYBRACKET .)


state 163

    (86) optFunction_arguments -> optFunction_argument COMMA . optFunction_arguments
    (85) optFunction_arguments -> . optFunction_argument
    (86) optFunction_arguments -> . optFunction_argument COMMA optFunction_arguments
    (84) optFunction_argument -> . REQUIRED datatype IDENTIFIER

    REQUIRED        shift and go to state 148

    optFunction_argument           shift and go to state 147
    optFunction_arguments          shift and go to state 172

state 164

    (84) optFunction_argument -> REQUIRED datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 173


state 165

    (40) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement . RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET

    RPAREN          shift and go to state 174


state 166

    (41) taskStatement -> IDENTIFIER . operatorExpression operatorExpression
    (91) operatorExpression -> . PLUS
    (92) operatorExpression -> . MINUS
    (93) operatorExpression -> . TIMES
    (94) operatorExpression -> . DIVISION

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVISION        shift and go to state 49

    operatorExpression             shift and go to state 175

state 167

    (42) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 176


state 168

    (44) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN . IDENTIFIER RPAREN SEMICOLON

    IDENTIFIER      shift and go to state 177


state 169

    (37) ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    ELSE            reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FOR             reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 37 (ifStatement -> IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 170

    (45) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 178


state 171

    (77) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN . expression SEMICOLON
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    IDENTIFIER      shift and go to state 86
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28

    expression                     shift and go to state 179
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    number                         shift and go to state 24

state 172

    (86) optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .

    RCURLYBRACKET   reduce using rule 86 (optFunction_arguments -> optFunction_argument COMMA optFunction_arguments .)


state 173

    (84) optFunction_argument -> REQUIRED datatype IDENTIFIER .

    COMMA           reduce using rule 84 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)
    RCURLYBRACKET   reduce using rule 84 (optFunction_argument -> REQUIRED datatype IDENTIFIER .)


state 174

    (40) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN . LCURLYBRACKET class_content_repeat RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 180


state 175

    (41) taskStatement -> IDENTIFIER operatorExpression . operatorExpression
    (91) operatorExpression -> . PLUS
    (92) operatorExpression -> . MINUS
    (93) operatorExpression -> . TIMES
    (94) operatorExpression -> . DIVISION

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVISION        shift and go to state 49

    operatorExpression             shift and go to state 181

state 176

    (42) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . opt_value RPAREN SEMICOLON
    (43) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN . RPAREN SEMICOLON
    (51) opt_value -> . value
    (52) opt_value -> . empty
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (25) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 183
    INTEGER         shift and go to state 111
    FLOAT           shift and go to state 112
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    IDENTIFIER      shift and go to state 104

  ! RPAREN          [ reduce using rule 25 (empty -> .) ]

    opt_value                      shift and go to state 182
    value                          shift and go to state 184
    empty                          shift and go to state 185

state 177

    (44) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER . RPAREN SEMICOLON

    RPAREN          shift and go to state 186


state 178

    (45) inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .

    FOR             reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FINAL           reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    MAP             reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    IF              reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VAR             reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INTEGER         reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    FLOAT           reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STR             reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOLEAN         reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    INT             reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    STRING          reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    BOOL            reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DOUBLE          reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    DYNAMIC         reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    VOID            reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    $end            reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 45 (inferedReturnFunction -> IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET .)


state 179

    (77) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression . SEMICOLON

    SEMICOLON       shift and go to state 187


state 180

    (40) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET . class_content_repeat RCURLYBRACKET
    (10) class_content_repeat -> . class_content
    (11) class_content_repeat -> . class_content_repeat class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . stack
    (8) class_content -> . inferedReturnFunction
    (9) class_content -> . expression SEMICOLON
    (12) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) ifElseStatement -> . ifStatement
    (34) ifElseStatement -> . ifStatement elifStatement_repeat
    (77) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (40) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (42) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (45) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    FOR             shift and go to state 16
    FINAL           shift and go to state 17
    IDENTIFIER      shift and go to state 13
    MAP             shift and go to state 20
    IF              shift and go to state 21
    VAR             shift and go to state 23
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34

    declarationExpression          shift and go to state 7
    class_content_repeat           shift and go to state 188
    class_content                  shift and go to state 3
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    forStatement                   shift and go to state 8
    stack                          shift and go to state 9
    inferedReturnFunction          shift and go to state 10
    expression                     shift and go to state 11
    map_identifier                 shift and go to state 12
    ifStatement                    shift and go to state 14
    datatype                       shift and go to state 15
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    returnType                     shift and go to state 22
    number                         shift and go to state 24

state 181

    (41) taskStatement -> IDENTIFIER operatorExpression operatorExpression .

    RPAREN          reduce using rule 41 (taskStatement -> IDENTIFIER operatorExpression operatorExpression .)


state 182

    (42) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value . RPAREN SEMICOLON

    RPAREN          shift and go to state 189


state 183

    (43) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 190


state 184

    (51) opt_value -> value .

    RPAREN          reduce using rule 51 (opt_value -> value .)


state 185

    (52) opt_value -> empty .

    RPAREN          reduce using rule 52 (opt_value -> empty .)


state 186

    (44) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 191


state 187

    (77) function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .

    FOR             reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FINAL           reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    MAP             reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    IF              reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VAR             reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INTEGER         reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    FLOAT           reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STR             reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOLEAN         reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    INT             reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    STRING          reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    BOOL            reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DOUBLE          reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    DYNAMIC         reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    VOID            reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    $end            reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)
    RCURLYBRACKET   reduce using rule 77 (function_lambda -> datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON .)


state 188

    (40) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat . RCURLYBRACKET
    (11) class_content_repeat -> class_content_repeat . class_content
    (2) class_content -> . map
    (3) class_content -> . ifElseStatement
    (4) class_content -> . function_lambda
    (5) class_content -> . declarationExpression
    (6) class_content -> . forStatement
    (7) class_content -> . stack
    (8) class_content -> . inferedReturnFunction
    (9) class_content -> . expression SEMICOLON
    (12) map -> . map_identifier IDENTIFIER EQUAL LCURLYBRACKET map_content RCURLYBRACKET SEMICOLON
    (33) ifElseStatement -> . ifStatement
    (34) ifElseStatement -> . ifStatement elifStatement_repeat
    (77) function_lambda -> . datatype IDENTIFIER LPAREN function_arguments_repeat optFunction_argumentsExpression RPAREN EQUAL GREATERTHAN expression SEMICOLON
    (95) declarationExpression -> . datatype IDENTIFIER SEMICOLON
    (96) declarationExpression -> . datatype IDENTIFIER EQUAL expression SEMICOLON
    (40) forStatement -> . FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (42) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON
    (43) stack -> . FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON
    (44) stack -> . FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON
    (45) inferedReturnFunction -> . IDENTIFIER LPAREN function_arguments_repeat RPAREN LCURLYBRACKET RETURN expression SEMICOLON RCURLYBRACKET
    (87) expression -> . operableTypes operatorExpression operableTypes
    (88) expression -> . value
    (13) map_identifier -> . MAP
    (14) map_identifier -> . MAP map_type_specified
    (37) ifStatement -> . IF LPAREN conditions RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET
    (16) datatype -> . returnType
    (17) datatype -> . VAR
    (89) operableTypes -> . IDENTIFIER
    (90) operableTypes -> . number
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . STR
    (49) value -> . BOOLEAN
    (50) value -> . IDENTIFIER
    (18) returnType -> . INT
    (19) returnType -> . STRING
    (20) returnType -> . BOOL
    (21) returnType -> . DOUBLE
    (22) returnType -> . DYNAMIC
    (23) returnType -> . VOID
    (24) returnType -> . map_identifier
    (66) number -> . FLOAT
    (67) number -> . INTEGER

    RCURLYBRACKET   shift and go to state 192
    FOR             shift and go to state 16
    FINAL           shift and go to state 17
    IDENTIFIER      shift and go to state 13
    MAP             shift and go to state 20
    IF              shift and go to state 21
    VAR             shift and go to state 23
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 26
    STR             shift and go to state 27
    BOOLEAN         shift and go to state 28
    INT             shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31
    DOUBLE          shift and go to state 32
    DYNAMIC         shift and go to state 33
    VOID            shift and go to state 34

    declarationExpression          shift and go to state 7
    class_content                  shift and go to state 35
    map                            shift and go to state 4
    ifElseStatement                shift and go to state 5
    function_lambda                shift and go to state 6
    forStatement                   shift and go to state 8
    stack                          shift and go to state 9
    inferedReturnFunction          shift and go to state 10
    expression                     shift and go to state 11
    map_identifier                 shift and go to state 12
    ifStatement                    shift and go to state 14
    datatype                       shift and go to state 15
    operableTypes                  shift and go to state 18
    value                          shift and go to state 19
    returnType                     shift and go to state 22
    number                         shift and go to state 24

state 189

    (42) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 193


state 190

    (43) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .

    FOR             reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STR             reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 43 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN RPAREN SEMICOLON .)


state 191

    (44) stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .

    FOR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FINAL           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    MAP             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    IF              reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VAR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INTEGER         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STR             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    INT             reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    STRING          reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    BOOL            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    VOID            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    $end            reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 44 (stack -> FINAL IDENTIFIER EQUAL STACK DOT OF LPAREN IDENTIFIER RPAREN SEMICOLON .)


state 192

    (40) forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .

    FOR             reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FINAL           reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IDENTIFIER      reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    MAP             reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    IF              reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VAR             reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INTEGER         reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    FLOAT           reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STR             reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOLEAN         reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    INT             reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    STRING          reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    BOOL            reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DOUBLE          reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    DYNAMIC         reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    VOID            reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    $end            reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 40 (forStatement -> FOR LPAREN declarationExpression SEMICOLON condition SEMICOLON taskStatement RPAREN LCURLYBRACKET class_content_repeat RCURLYBRACKET .)


state 193

    (42) stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .

    FOR             reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FINAL           reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    MAP             reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    IF              reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VAR             reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STR             reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    INT             reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    STRING          reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    BOOL            reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    VOID            reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    $end            reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)
    RCURLYBRACKET   reduce using rule 42 (stack -> FINAL IDENTIFIER EQUAL STACK LESSTHAN datatype GREATERTHAN LPAREN opt_value RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 12 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 176 resolved as shift
